# çº¿æ€§ä»£æ•°ä¸çŸ©é˜µç†è®º - å›½é™…æ ‡å‡†æ·±åº¦æ‰©å±•ç‰ˆ

**ä¸»é¢˜ç¼–å·**: B.02.08
**åˆ›å»ºæ—¥æœŸ**: 2025å¹´11æœˆ21æ—¥
**æœ€åæ›´æ–°**: 2025å¹´11æœˆ21æ—¥

---

## ç›®å½• / Table of Contents

- [çº¿æ€§ä»£æ•°ä¸çŸ©é˜µç†è®º - å›½é™…æ ‡å‡†æ·±åº¦æ‰©å±•ç‰ˆ](#çº¿æ€§ä»£æ•°ä¸çŸ©é˜µç†è®º---å›½é™…æ ‡å‡†æ·±åº¦æ‰©å±•ç‰ˆ)
  - [ç›®å½• / Table of Contents](#ç›®å½•--table-of-contents)
  - [æ¦‚è¿°](#æ¦‚è¿°)
  - [ğŸ—ºï¸ çº¿æ€§ä»£æ•°æ ¸å¿ƒæ¦‚å¿µæ€ç»´å¯¼å›¾](#ï¸-çº¿æ€§ä»£æ•°æ ¸å¿ƒæ¦‚å¿µæ€ç»´å¯¼å›¾)
  - [ğŸ“Š çº¿æ€§ä»£æ•°æ ¸å¿ƒæ¦‚å¿µå¤šç»´çŸ¥è¯†çŸ©é˜µ](#-çº¿æ€§ä»£æ•°æ ¸å¿ƒæ¦‚å¿µå¤šç»´çŸ¥è¯†çŸ©é˜µ)
  - [1. å‘é‡ç©ºé—´ç†è®º](#1-å‘é‡ç©ºé—´ç†è®º)
    - [1.1 å‘é‡ç©ºé—´çš„å…¬ç†åŒ–å®šä¹‰](#11-å‘é‡ç©ºé—´çš„å…¬ç†åŒ–å®šä¹‰)
    - [1.2 çº¿æ€§æ— å…³ä¸åŸº](#12-çº¿æ€§æ— å…³ä¸åŸº)
  - [2. çŸ©é˜µç†è®º](#2-çŸ©é˜µç†è®º)
    - [2.1 çŸ©é˜µçš„åŸºæœ¬æ¦‚å¿µ](#21-çŸ©é˜µçš„åŸºæœ¬æ¦‚å¿µ)
    - [2.2 çŸ©é˜µåˆ†è§£ç†è®º](#22-çŸ©é˜µåˆ†è§£ç†è®º)
    - [2.3 çŸ©é˜µçš„æ•°å€¼æ€§è´¨](#23-çŸ©é˜µçš„æ•°å€¼æ€§è´¨)
  - [3. çº¿æ€§å˜æ¢ç†è®º](#3-çº¿æ€§å˜æ¢ç†è®º)
    - [3.1 çº¿æ€§å˜æ¢çš„å®šä¹‰ä¸æ€§è´¨](#31-çº¿æ€§å˜æ¢çš„å®šä¹‰ä¸æ€§è´¨)
    - [3.2 æ ¸ä¸åƒ](#32-æ ¸ä¸åƒ)
    - [3.3 çº¿æ€§å˜æ¢çš„çŸ©é˜µè¡¨ç¤º](#33-çº¿æ€§å˜æ¢çš„çŸ©é˜µè¡¨ç¤º)
  - [4. ç‰¹å¾å€¼ä¸ç‰¹å¾å‘é‡](#4-ç‰¹å¾å€¼ä¸ç‰¹å¾å‘é‡)
    - [4.1 ç‰¹å¾å€¼ä¸ç‰¹å¾å‘é‡çš„å®šä¹‰](#41-ç‰¹å¾å€¼ä¸ç‰¹å¾å‘é‡çš„å®šä¹‰)
    - [4.2 ç‰¹å¾å€¼çš„æ€§è´¨](#42-ç‰¹å¾å€¼çš„æ€§è´¨)
  - [5. å†…ç§¯ç©ºé—´ä¸æ­£äº¤æ€§](#5-å†…ç§¯ç©ºé—´ä¸æ­£äº¤æ€§)
    - [5.1 å†…ç§¯ç©ºé—´çš„å®šä¹‰](#51-å†…ç§¯ç©ºé—´çš„å®šä¹‰)
    - [5.2 æ­£äº¤æ€§ä¸Gram-Schmidtæ­£äº¤åŒ–](#52-æ­£äº¤æ€§ä¸gram-schmidtæ­£äº¤åŒ–)
  - [6. å¯¹è§’åŒ–ä¸Jordanæ ‡å‡†å½¢](#6-å¯¹è§’åŒ–ä¸jordanæ ‡å‡†å½¢)
    - [6.1 å¯¹è§’åŒ–](#61-å¯¹è§’åŒ–)
    - [6.2 Jordanæ ‡å‡†å½¢](#62-jordanæ ‡å‡†å½¢)
  - [7. åº”ç”¨ä¸å‰æ²¿å‘å±•](#7-åº”ç”¨ä¸å‰æ²¿å‘å±•)
    - [7.1 é‡å­è®¡ç®—ä¸­çš„çº¿æ€§ä»£æ•°](#71-é‡å­è®¡ç®—ä¸­çš„çº¿æ€§ä»£æ•°)
    - [7.2 æœºå™¨å­¦ä¹ ä¸­çš„çº¿æ€§ä»£æ•°](#72-æœºå™¨å­¦ä¹ ä¸­çš„çº¿æ€§ä»£æ•°)
    - [7.3 æ•°å€¼çº¿æ€§ä»£æ•°å‰æ²¿](#73-æ•°å€¼çº¿æ€§ä»£æ•°å‰æ²¿)
  - [å‚è€ƒæ–‡çŒ®](#å‚è€ƒæ–‡çŒ®)
    - [å›½é™…æ ‡å‡†æ–‡çŒ®](#å›½é™…æ ‡å‡†æ–‡çŒ®)
    - [å›½é™…å¤§å­¦æ ‡å‡†](#å›½é™…å¤§å­¦æ ‡å‡†)
    - [ç»å…¸æ•™æ](#ç»å…¸æ•™æ)
    - [å‰æ²¿å‘å±•](#å‰æ²¿å‘å±•)
  - [é™„å½•ï¼šå›½é™…æ ‡å‡†è¯æ˜æçº²ä¸ç»ƒä¹ æ¸…å•](#é™„å½•å›½é™…æ ‡å‡†è¯æ˜æçº²ä¸ç»ƒä¹ æ¸…å•)
    - [A. RREF ä¸ç§©-é›¶åŒ–åº¦å®šç†ï¼ˆè¯æ˜æçº²ï¼‰](#a-rref-ä¸ç§©-é›¶åŒ–åº¦å®šç†è¯æ˜æçº²)
    - [B. å››å¤§åŸºæœ¬å­ç©ºé—´ï¼ˆæ€§è´¨è¦ç‚¹ï¼‰](#b-å››å¤§åŸºæœ¬å­ç©ºé—´æ€§è´¨è¦ç‚¹)
    - [C. è°±å®šç†ä¸ Schur åˆ†è§£ï¼ˆè¯æ˜æçº²ï¼‰](#c-è°±å®šç†ä¸-schur-åˆ†è§£è¯æ˜æçº²)
    - [D. SVD ä¸ä¼ªé€†ï¼ˆå½¢å¼åŒ–æ¥å£è‰æ¡ˆï¼‰](#d-svd-ä¸ä¼ªé€†å½¢å¼åŒ–æ¥å£è‰æ¡ˆ)
    - [E. ç¤ºä¾‹ä¸ç»ƒä¹ ï¼ˆå»ºè®®ï¼‰](#e-ç¤ºä¾‹ä¸ç»ƒä¹ å»ºè®®)
    - [F. å¯è¿è¡Œç¤ºä¾‹ï¼šæ³•æ–¹ç¨‹ vs SVD æœ€å°äºŒä¹˜](#f-å¯è¿è¡Œç¤ºä¾‹æ³•æ–¹ç¨‹-vs-svd-æœ€å°äºŒä¹˜)
    - [G. æ­£å®šæ€§ç­‰ä»·æ¡ä»¶ä¸CholeskyéªŒè¯](#g-æ­£å®šæ€§ç­‰ä»·æ¡ä»¶ä¸choleskyéªŒè¯)

## æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäºå›½é™…Wikiæ ‡å‡†å’Œ2025å¹´å›½é™…è‘—åå¤§å­¦æ•°å­¦è¯¾ç¨‹ï¼Œå…¨é¢é˜è¿°çº¿æ€§ä»£æ•°ä¸çŸ©é˜µç†è®ºçš„æ ¸å¿ƒæ¦‚å¿µã€ä¸¥æ ¼è¯æ˜å’Œç°ä»£åº”ç”¨ã€‚

## ğŸ—ºï¸ çº¿æ€§ä»£æ•°æ ¸å¿ƒæ¦‚å¿µæ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((çº¿æ€§ä»£æ•°))
    å‘é‡ç©ºé—´
      å‘é‡ç©ºé—´
        å…¬ç†åŒ–å®šä¹‰
        å‘é‡ç©ºé—´æ€§è´¨
      çº¿æ€§æ— å…³
        çº¿æ€§æ— å…³å®šä¹‰
        åŸº
      ç»´æ•°
        ç»´æ•°å®šä¹‰
        åŸºçš„ä¸ªæ•°
    çŸ©é˜µç†è®º
      çŸ©é˜µ
        çŸ©é˜µå®šä¹‰
        çŸ©é˜µè¿ç®—
      çŸ©é˜µåˆ†è§£
        è¡Œåˆ—å¼
        ç‰¹å¾å€¼åˆ†è§£
        SVDåˆ†è§£
      çŸ©é˜µæ€§è´¨
        ç§©
        å¯é€†æ€§
    çº¿æ€§å˜æ¢
      çº¿æ€§å˜æ¢
        çº¿æ€§å˜æ¢å®šä¹‰
        çŸ©é˜µè¡¨ç¤º
      æ ¸ä¸åƒ
        æ ¸
        åƒ
        ç§©-é›¶åŒ–åº¦å®šç†
    ç‰¹å¾å€¼ç†è®º
      ç‰¹å¾å€¼
        ç‰¹å¾å€¼å®šä¹‰
        ç‰¹å¾å‘é‡
      å¯¹è§’åŒ–
        å¯¹è§’åŒ–
        Jordanæ ‡å‡†å½¢
    å†…ç§¯ç©ºé—´
      å†…ç§¯ç©ºé—´
        å†…ç§¯å®šä¹‰
        å†…ç§¯æ€§è´¨
      æ­£äº¤æ€§
        æ­£äº¤
        æ­£äº¤åŸº
        Gram-Schmidt
    åº”ç”¨
      æœºå™¨å­¦ä¹ 
        ä¸»æˆåˆ†åˆ†æ
        çº¿æ€§å›å½’
      é‡å­è®¡ç®—
        é‡å­æ€
        é‡å­é—¨
      æ•°å€¼è®¡ç®—
        çº¿æ€§æ–¹ç¨‹ç»„
        æœ€å°äºŒä¹˜
```

## ğŸ“Š çº¿æ€§ä»£æ•°æ ¸å¿ƒæ¦‚å¿µå¤šç»´çŸ¥è¯†çŸ©é˜µ

| æ¦‚å¿µç±»åˆ« | æ ¸å¿ƒæ¦‚å¿µ | å®šä¹‰è¦ç‚¹ | å…³é”®æ€§è´¨ | å…¸å‹ä¾‹å­ | åº”ç”¨åœºæ™¯ |
|---------|---------|---------|---------|---------|---------|
| å‘é‡ç©ºé—´ | å‘é‡ç©ºé—´ | å…¬ç†åŒ–å®šä¹‰ | çº¿æ€§ç»“æ„ | â„â¿, â„‚â¿ | æ•°å­¦åŸºç¡€ |
| å‘é‡ç©ºé—´ | åŸº | çº¿æ€§æ— å…³ç”Ÿæˆé›† | åŸºå”¯ä¸€æ€§ | æ ‡å‡†åŸº | å‘é‡è¡¨ç¤º |
| å‘é‡ç©ºé—´ | ç»´æ•° | åŸºçš„å‘é‡ä¸ªæ•° | ç»´æ•°å”¯ä¸€æ€§ | dim(â„â¿) = n | å‘é‡ç©ºé—´åˆ†ç±» |
| çŸ©é˜µç†è®º | çŸ©é˜µ | æ•°è¡¨ | çŸ©é˜µè¿ç®— | mÃ—nçŸ©é˜µ | çº¿æ€§å˜æ¢ |
| çŸ©é˜µç†è®º | è¡Œåˆ—å¼ | çŸ©é˜µå‡½æ•° | å¯é€†æ€§åˆ¤å®š | det(A) | çº¿æ€§æ–¹ç¨‹ç»„ |
| çŸ©é˜µç†è®º | ç§© | è¡Œ/åˆ—å‘é‡ç»„ç§© | ç§©å”¯ä¸€æ€§ | rank(A) | çº¿æ€§æ–¹ç¨‹ç»„ |
| çŸ©é˜µç†è®º | SVDåˆ†è§£ | å¥‡å¼‚å€¼åˆ†è§£ | å­˜åœ¨æ€§ | A = UÎ£V* | æ•°æ®é™ç»´ |
| çº¿æ€§å˜æ¢ | çº¿æ€§å˜æ¢ | ä¿æŒçº¿æ€§è¿ç®— | çŸ©é˜µè¡¨ç¤º | T: Vâ†’W | çº¿æ€§æ˜ å°„ |
| çº¿æ€§å˜æ¢ | æ ¸ä¸åƒ | é›¶ç©ºé—´ä¸å€¼åŸŸ | ç§©-é›¶åŒ–åº¦å®šç† | ker(T), im(T) | çº¿æ€§æ–¹ç¨‹ç»„ |
| ç‰¹å¾å€¼ç†è®º | ç‰¹å¾å€¼ | ç‰¹å¾æ–¹ç¨‹æ ¹ | ç‰¹å¾å€¼æ€§è´¨ | Î», v | å¯¹è§’åŒ– |
| ç‰¹å¾å€¼ç†è®º | å¯¹è§’åŒ– | ç›¸ä¼¼å¯¹è§’çŸ©é˜µ | å¯å¯¹è§’åŒ–æ¡ä»¶ | Pâ»Â¹AP = D | çŸ©é˜µç®€åŒ– |
| ç‰¹å¾å€¼ç†è®º | Jordanæ ‡å‡†å½¢ | å‡†å¯¹è§’çŸ©é˜µ | å­˜åœ¨æ€§ | Jordanå½¢ | çŸ©é˜µåˆ†ç±» |
| å†…ç§¯ç©ºé—´ | å†…ç§¯ç©ºé—´ | å†…ç§¯å®šä¹‰ | æ­£äº¤æ€§ | (Â·,Â·) | å‡ ä½•ç»“æ„ |
| å†…ç§¯ç©ºé—´ | æ­£äº¤åŸº | æ­£äº¤å‘é‡åŸº | æ ‡å‡†æ­£äº¤åŸº | æ­£äº¤åŸº | å‡½æ•°å±•å¼€ |
| åº”ç”¨ | ä¸»æˆåˆ†åˆ†æ | æ•°æ®é™ç»´ | SVD | PCA | æœºå™¨å­¦ä¹  |
| åº”ç”¨ | çº¿æ€§å›å½’ | æœ€å°äºŒä¹˜ | æ³•æ–¹ç¨‹ | çº¿æ€§å›å½’ | æ•°æ®åˆ†æ |

## 1. å‘é‡ç©ºé—´ç†è®º

### 1.1 å‘é‡ç©ºé—´çš„å…¬ç†åŒ–å®šä¹‰

**å®šä¹‰ 1.1** (å‘é‡ç©ºé—´)
è®¾ $F$ æ˜¯ä¸€ä¸ªåŸŸï¼Œ$V$ æ˜¯ä¸€ä¸ªé›†åˆï¼Œå‘é‡ç©ºé—´æ˜¯ä¸€ä¸ªæœ‰åºå››å…ƒç»„ $(V, F, +, \cdot)$ï¼Œå…¶ä¸­ï¼š

1. **åŠ æ³•ç¾¤**: $(V, +)$ æ„æˆé˜¿è´å°”ç¾¤
2. **æ ‡é‡ä¹˜æ³•**: $\cdot: F \times V \rightarrow V$
3. **åˆ†é…å¾‹**: $\forall a \in F \forall v, w \in V(a \cdot (v + w) = a \cdot v + a \cdot w)$
4. **ç»“åˆå¾‹**: $\forall a, b \in F \forall v \in V((a \cdot b) \cdot v = a \cdot (b \cdot v))$
5. **å•ä½å…ƒ**: $\forall v \in V(1 \cdot v = v)$

**å®šç† 1.1** (å‘é‡ç©ºé—´çš„åŸºæœ¬æ€§è´¨)
è®¾ $V$ æ˜¯åŸŸ $F$ ä¸Šçš„å‘é‡ç©ºé—´ï¼Œåˆ™ï¼š

1. $0 \cdot v = 0$ å¯¹æ‰€æœ‰ $v \in V$ æˆç«‹
2. $a \cdot 0 = 0$ å¯¹æ‰€æœ‰ $a \in F$ æˆç«‹
3. $(-a) \cdot v = -(a \cdot v)$ å¯¹æ‰€æœ‰ $a \in F, v \in V$ æˆç«‹

### 1.2 çº¿æ€§æ— å…³ä¸åŸº

**å®šä¹‰ 1.2** (çº¿æ€§æ— å…³)
å‘é‡ç»„ $\{v_1, v_2, \ldots, v_n\}$ ç§°ä¸ºçº¿æ€§æ— å…³ï¼Œå¦‚æœæ–¹ç¨‹
$$\sum_{i=1}^n a_i v_i = 0$$
åªæœ‰å¹³å‡¡è§£ $a_1 = a_2 = \cdots = a_n = 0$ã€‚

**å®šä¹‰ 1.3** (åŸº)
å‘é‡ç©ºé—´ $V$ çš„åŸºæ˜¯ $V$ çš„çº¿æ€§æ— å…³ç”Ÿæˆé›†ã€‚

**å®šç† 1.2** (åŸºçš„å­˜åœ¨æ€§ä¸å”¯ä¸€æ€§)
æ¯ä¸ªæœ‰é™ç»´å‘é‡ç©ºé—´éƒ½æœ‰åŸºï¼Œä¸”æ‰€æœ‰åŸºçš„å‘é‡ä¸ªæ•°ç›¸åŒã€‚

## 2. çŸ©é˜µç†è®º

### 2.1 çŸ©é˜µçš„åŸºæœ¬æ¦‚å¿µ

**å®šä¹‰ 2.1** (çŸ©é˜µ)
è®¾ $F$ æ˜¯ä¸€ä¸ªåŸŸï¼Œ$m, n \in \mathbb{N}$ï¼Œ$m \times n$ çŸ©é˜µæ˜¯å‡½æ•° $A: \{1,2,\ldots,m\} \times \{1,2,\ldots,n\} \rightarrow F$ã€‚

**çŸ©é˜µè¿ç®—**:

```python
import numpy as np
from typing import List, Tuple, Optional

class Matrix:
    """çŸ©é˜µç±» - åŸºäºå›½é™…æ ‡å‡†çš„å®ç°"""

    def __init__(self, data: List[List[float]], field: str = "R"):
        self.data = np.array(data, dtype=float)
        self.rows, self.cols = self.data.shape
        self.field = field

    def __add__(self, other: 'Matrix') -> 'Matrix':
        """çŸ©é˜µåŠ æ³•"""
        if self.rows != other.rows or self.cols != other.cols:
            raise ValueError("çŸ©é˜µç»´åº¦ä¸åŒ¹é…")
        return Matrix((self.data + other.data).tolist(), self.field)

    def __mul__(self, other: 'Matrix') -> 'Matrix':
        """çŸ©é˜µä¹˜æ³•"""
        if self.cols != other.rows:
            raise ValueError("çŸ©é˜µç»´åº¦ä¸åŒ¹é…")
        return Matrix((self.data @ other.data).tolist(), self.field)

    def transpose(self) -> 'Matrix':
        """çŸ©é˜µè½¬ç½®"""
        return Matrix(self.data.T.tolist(), self.field)

    def determinant(self) -> float:
        """è¡Œåˆ—å¼"""
        if self.rows != self.cols:
            raise ValueError("åªæœ‰æ–¹é˜µæ‰æœ‰è¡Œåˆ—å¼")
        return np.linalg.det(self.data)

    def rank(self) -> int:
        """çŸ©é˜µç§©"""
        return np.linalg.matrix_rank(self.data)

    def inverse(self) -> Optional['Matrix']:
        """çŸ©é˜µé€†"""
        if self.rows != self.cols:
            raise ValueError("åªæœ‰æ–¹é˜µæ‰æœ‰é€†çŸ©é˜µ")
        try:
            inv_data = np.linalg.inv(self.data)
            return Matrix(inv_data.tolist(), self.field)
        except np.linalg.LinAlgError:
            return None  # å¥‡å¼‚çŸ©é˜µ

    def eigenvalues(self) -> np.ndarray:
        """ç‰¹å¾å€¼"""
        if self.rows != self.cols:
            raise ValueError("åªæœ‰æ–¹é˜µæ‰æœ‰ç‰¹å¾å€¼")
        return np.linalg.eigvals(self.data)

    def eigenvectors(self) -> Tuple[np.ndarray, np.ndarray]:
        """ç‰¹å¾å€¼å’Œç‰¹å¾å‘é‡"""
        if self.rows != self.cols:
            raise ValueError("åªæœ‰æ–¹é˜µæ‰æœ‰ç‰¹å¾å‘é‡")
        return np.linalg.eig(self.data)
```

### 2.2 çŸ©é˜µåˆ†è§£ç†è®º

**LUåˆ†è§£**:

```python
def lu_decomposition(A: Matrix) -> Tuple[Matrix, Matrix]:
    """LUåˆ†è§£"""
    if A.rows != A.cols:
        raise ValueError("åªæœ‰æ–¹é˜µæ‰èƒ½è¿›è¡ŒLUåˆ†è§£")

    n = A.rows
    L = np.eye(n)
    U = A.data.copy()

    for k in range(n-1):
        for i in range(k+1, n):
            if U[k, k] == 0:
                raise ValueError("çŸ©é˜µä¸å¯è¿›è¡ŒLUåˆ†è§£")
            L[i, k] = U[i, k] / U[k, k]
            U[i, k:] -= L[i, k] * U[k, k:]

    return Matrix(L.tolist()), Matrix(U.tolist())

def qr_decomposition(A: Matrix) -> Tuple[Matrix, Matrix]:
    """QRåˆ†è§£"""
    Q, R = np.linalg.qr(A.data)
    return Matrix(Q.tolist()), Matrix(R.tolist())

def svd_decomposition(A: Matrix) -> Tuple[Matrix, np.ndarray, Matrix]:
    """å¥‡å¼‚å€¼åˆ†è§£"""
    U, s, Vt = np.linalg.svd(A.data)
    return Matrix(U.tolist()), s, Matrix(Vt.tolist())
```

### 2.3 çŸ©é˜µçš„æ•°å€¼æ€§è´¨

**å®šç† 2.1** (çŸ©é˜µèŒƒæ•°)
è®¾ $A$ æ˜¯ $m \times n$ çŸ©é˜µï¼Œåˆ™ï¼š

1. **FrobeniusèŒƒæ•°**: $\|A\|_F = \sqrt{\sum_{i=1}^m \sum_{j=1}^n |a_{ij}|^2}$
2. **ç®—å­èŒƒæ•°**: $\|A\|_2 = \max_{\|x\|_2 = 1} \|Ax\|_2$
3. **1-èŒƒæ•°**: $\|A\|_1 = \max_j \sum_{i=1}^m |a_{ij}|$
4. **âˆ-èŒƒæ•°**: $\|A\|_\infty = \max_i \sum_{j=1}^n |a_{ij}|$

**æ¡ä»¶æ•°**:

```python
def condition_number(A: Matrix, norm_type: str = "2") -> float:
    """è®¡ç®—çŸ©é˜µæ¡ä»¶æ•°"""
    if A.rows != A.cols:
        raise ValueError("åªæœ‰æ–¹é˜µæ‰æœ‰æ¡ä»¶æ•°")

    if norm_type == "2":
        return np.linalg.cond(A.data, 2)
    elif norm_type == "1":
        return np.linalg.cond(A.data, 1)
    elif norm_type == "inf":
        return np.linalg.cond(A.data, np.inf)
    else:
        raise ValueError("ä¸æ”¯æŒçš„èŒƒæ•°ç±»å‹")
```

## 3. çº¿æ€§å˜æ¢ç†è®º

### 3.1 çº¿æ€§å˜æ¢çš„å®šä¹‰ä¸æ€§è´¨

**å®šä¹‰ 3.1** (çº¿æ€§å˜æ¢)
è®¾ $V$ å’Œ $W$ æ˜¯åŸŸ $F$ ä¸Šçš„å‘é‡ç©ºé—´ï¼Œçº¿æ€§å˜æ¢æ˜¯å‡½æ•° $T: V \rightarrow W$ æ»¡è¶³ï¼š

1. **åŠ æ³•ä¿æŒ**: $\forall v, w \in V(T(v + w) = T(v) + T(w))$
2. **æ ‡é‡ä¹˜æ³•ä¿æŒ**: $\forall a \in F \forall v \in V(T(a \cdot v) = a \cdot T(v))$

**å®šç† 3.1** (çº¿æ€§å˜æ¢çš„åŸºæœ¬æ€§è´¨)
è®¾ $T: V \rightarrow W$ æ˜¯çº¿æ€§å˜æ¢ï¼Œåˆ™ï¼š

1. $T(0) = 0$
2. $T(-v) = -T(v)$ å¯¹æ‰€æœ‰ $v \in V$ æˆç«‹
3. $T(\sum_{i=1}^n a_i v_i) = \sum_{i=1}^n a_i T(v_i)$

### 3.2 æ ¸ä¸åƒ

**å®šä¹‰ 3.2** (æ ¸ä¸åƒ)
è®¾ $T: V \rightarrow W$ æ˜¯çº¿æ€§å˜æ¢ï¼š

1. **æ ¸**: $\ker(T) = \{v \in V : T(v) = 0\}$
2. **åƒ**: $\operatorname{im}(T) = \{T(v) : v \in V\}$

**å®šç† 3.2** (ç§©-é›¶åŒ–åº¦å®šç†)
è®¾ $T: V \rightarrow W$ æ˜¯çº¿æ€§å˜æ¢ï¼Œåˆ™ï¼š
$$\dim(\ker(T)) + \dim(\operatorname{im}(T)) = \dim(V)$$

### 3.3 çº¿æ€§å˜æ¢çš„çŸ©é˜µè¡¨ç¤º

**å®šç† 3.3** (çŸ©é˜µè¡¨ç¤ºå®šç†)
è®¾ $T: V \rightarrow W$ æ˜¯çº¿æ€§å˜æ¢ï¼Œ$\mathcal{B}_V = \{v_1, v_2, \ldots, v_n\}$ æ˜¯ $V$ çš„åŸºï¼Œ$\mathcal{B}_W = \{w_1, w_2, \ldots, w_m\}$ æ˜¯ $W$ çš„åŸºï¼Œåˆ™å­˜åœ¨å”¯ä¸€çš„ $m \times n$ çŸ©é˜µ $A$ ä½¿å¾—ï¼š
$$[T(v)]_{\mathcal{B}_W} = A[v]_{\mathcal{B}_V}$$

## 4. ç‰¹å¾å€¼ä¸ç‰¹å¾å‘é‡

### 4.1 ç‰¹å¾å€¼ä¸ç‰¹å¾å‘é‡çš„å®šä¹‰

**å®šä¹‰ 4.1** (ç‰¹å¾å€¼ä¸ç‰¹å¾å‘é‡)
è®¾ $T: V \rightarrow V$ æ˜¯çº¿æ€§å˜æ¢ï¼Œå¦‚æœå­˜åœ¨éé›¶å‘é‡ $v \in V$ å’Œæ ‡é‡ $\lambda \in F$ ä½¿å¾—ï¼š
$$T(v) = \lambda v$$
åˆ™ç§° $\lambda$ æ˜¯ $T$ çš„ç‰¹å¾å€¼ï¼Œ$v$ æ˜¯ $T$ çš„å¯¹åº”äº $\lambda$ çš„ç‰¹å¾å‘é‡ã€‚

**ç‰¹å¾å¤šé¡¹å¼**:

```python
def characteristic_polynomial(A: Matrix) -> np.poly1d:
    """è®¡ç®—ç‰¹å¾å¤šé¡¹å¼"""
    if A.rows != A.cols:
        raise ValueError("åªæœ‰æ–¹é˜µæ‰æœ‰ç‰¹å¾å¤šé¡¹å¼")

    # p(Î») = det(A - Î»I)
    return np.poly1d(np.poly(A.data))

def algebraic_multiplicity(A: Matrix, eigenvalue: complex) -> int:
    """è®¡ç®—ä»£æ•°é‡æ•°"""
    char_poly = characteristic_polynomial(A)
    roots = char_poly.roots

    # è®¡ç®—ç‰¹å¾å€¼åœ¨æ ¹ä¸­çš„é‡æ•°
    count = 0
    for root in roots:
        if abs(root - eigenvalue) < 1e-10:
            count += 1

    return count

def geometric_multiplicity(A: Matrix, eigenvalue: complex) -> int:
    """è®¡ç®—å‡ ä½•é‡æ•°"""
    n = A.rows
    I = np.eye(n)

    # è®¡ç®— ker(A - Î»I) çš„ç»´æ•°
    eigen_matrix = A.data - eigenvalue * I
    rank = np.linalg.matrix_rank(eigen_matrix)

    return n - rank
```

### 4.2 ç‰¹å¾å€¼çš„æ€§è´¨

**å®šç† 4.1** (ç‰¹å¾å€¼çš„åŸºæœ¬æ€§è´¨)
è®¾ $A$ æ˜¯ $n \times n$ çŸ©é˜µï¼Œ$\lambda_1, \lambda_2, \ldots, \lambda_n$ æ˜¯å…¶ç‰¹å¾å€¼ï¼Œåˆ™ï¼š

1. $\det(A) = \prod_{i=1}^n \lambda_i$
2. $\operatorname{tr}(A) = \sum_{i=1}^n \lambda_i$
3. $A$ çš„ç‰¹å¾å€¼ä¹Ÿæ˜¯ $A^T$ çš„ç‰¹å¾å€¼

**å®šç† 4.2** (Cayley-Hamiltonå®šç†)
è®¾ $A$ æ˜¯ $n \times n$ çŸ©é˜µï¼Œ$p(\lambda)$ æ˜¯å…¶ç‰¹å¾å¤šé¡¹å¼ï¼Œåˆ™ï¼š
$$p(A) = 0$$

## 5. å†…ç§¯ç©ºé—´ä¸æ­£äº¤æ€§

### 5.1 å†…ç§¯ç©ºé—´çš„å®šä¹‰

**å®šä¹‰ 5.1** (å†…ç§¯ç©ºé—´)
è®¾ $V$ æ˜¯åŸŸ $F$ ä¸Šçš„å‘é‡ç©ºé—´ï¼Œå†…ç§¯æ˜¯å‡½æ•° $\langle \cdot, \cdot \rangle: V \times V \rightarrow F$ æ»¡è¶³ï¼š

1. **å…±è½­å¯¹ç§°æ€§**: $\langle v, w \rangle = \overline{\langle w, v \rangle}$
2. **çº¿æ€§æ€§**: $\langle av + bw, u \rangle = a\langle v, u \rangle + b\langle w, u \rangle$
3. **æ­£å®šæ€§**: $\langle v, v \rangle \geq 0$ ä¸” $\langle v, v \rangle = 0 \Leftrightarrow v = 0$

**èŒƒæ•°**:

```python
def inner_product(v: np.ndarray, w: np.ndarray) -> complex:
    """è®¡ç®—å†…ç§¯"""
    return np.dot(v.conj(), w)

def norm(v: np.ndarray) -> float:
    """è®¡ç®—èŒƒæ•°"""
    return np.sqrt(np.real(inner_product(v, v)))

def distance(v: np.ndarray, w: np.ndarray) -> float:
    """è®¡ç®—è·ç¦»"""
    return norm(v - w)

def angle(v: np.ndarray, w: np.ndarray) -> float:
    """è®¡ç®—å¤¹è§’"""
    cos_angle = np.real(inner_product(v, w)) / (norm(v) * norm(w))
    return np.arccos(np.clip(cos_angle, -1, 1))
```

### 5.2 æ­£äº¤æ€§ä¸Gram-Schmidtæ­£äº¤åŒ–

**å®šä¹‰ 5.2** (æ­£äº¤æ€§)
å‘é‡ $v$ å’Œ $w$ ç§°ä¸ºæ­£äº¤ï¼Œå¦‚æœ $\langle v, w \rangle = 0$ã€‚

**Gram-Schmidtæ­£äº¤åŒ–**:

```python
def gram_schmidt_orthogonalization(vectors: List[np.ndarray]) -> List[np.ndarray]:
    """Gram-Schmidtæ­£äº¤åŒ–"""
    n = len(vectors)
    orthogonal_vectors = []

    for i in range(n):
        v = vectors[i].copy()

        # å‡å»å‰é¢æ‰€æœ‰æ­£äº¤å‘é‡çš„æŠ•å½±
        for j in range(i):
            proj = inner_product(v, orthogonal_vectors[j]) / inner_product(orthogonal_vectors[j], orthogonal_vectors[j])
            v = v - proj * orthogonal_vectors[j]

        # å½’ä¸€åŒ–
        norm_v = norm(v)
        if norm_v > 1e-10:  # é¿å…é›¶å‘é‡
            v = v / norm_v
            orthogonal_vectors.append(v)

    return orthogonal_vectors

def qr_decomposition_gram_schmidt(A: Matrix) -> Tuple[Matrix, Matrix]:
    """ä½¿ç”¨Gram-Schmidtçš„QRåˆ†è§£"""
    n = A.rows
    m = A.cols

    # æå–åˆ—å‘é‡
    columns = [A.data[:, j] for j in range(m)]

    # Gram-Schmidtæ­£äº¤åŒ–
    Q_columns = gram_schmidt_orthogonalization(columns)

    # æ„é€ QçŸ©é˜µ
    Q = np.column_stack(Q_columns)

    # è®¡ç®—RçŸ©é˜µ
    R = np.zeros((m, m))
    for i in range(m):
        for j in range(i, m):
            R[i, j] = inner_product(Q[:, i], A.data[:, j])

    return Matrix(Q.tolist()), Matrix(R.tolist())
```

## 6. å¯¹è§’åŒ–ä¸Jordanæ ‡å‡†å½¢

### 6.1 å¯¹è§’åŒ–

**å®šä¹‰ 6.1** (å¯¹è§’åŒ–)
çŸ©é˜µ $A$ ç§°ä¸ºå¯å¯¹è§’åŒ–ï¼Œå¦‚æœå­˜åœ¨å¯é€†çŸ©é˜µ $P$ ä½¿å¾—ï¼š
$$P^{-1}AP = D$$
å…¶ä¸­ $D$ æ˜¯å¯¹è§’çŸ©é˜µã€‚

**å®šç† 6.1** (å¯¹è§’åŒ–æ¡ä»¶)
$n \times n$ çŸ©é˜µ $A$ å¯å¯¹è§’åŒ–å½“ä¸”ä»…å½“ï¼š

1. $A$ æœ‰ $n$ ä¸ªçº¿æ€§æ— å…³çš„ç‰¹å¾å‘é‡
2. æ¯ä¸ªç‰¹å¾å€¼çš„ä»£æ•°é‡æ•°ç­‰äºå‡ ä½•é‡æ•°

```python
def is_diagonalizable(A: Matrix) -> bool:
    """åˆ¤æ–­çŸ©é˜µæ˜¯å¦å¯å¯¹è§’åŒ–"""
    eigenvalues = A.eigenvalues()

    for eigenvalue in eigenvalues:
        alg_mult = algebraic_multiplicity(A, eigenvalue)
        geom_mult = geometric_multiplicity(A, eigenvalue)

        if alg_mult != geom_mult:
            return False

    return True

def diagonalize(A: Matrix) -> Optional[Tuple[Matrix, Matrix]]:
    """å¯¹è§’åŒ–çŸ©é˜µ"""
    if not is_diagonalizable(A):
        return None

    eigenvalues, eigenvectors = A.eigenvectors()

    # PçŸ©é˜µæ˜¯ç‰¹å¾å‘é‡çŸ©é˜µ
    P = Matrix(eigenvectors.tolist())

    # DçŸ©é˜µæ˜¯å¯¹è§’çŸ©é˜µ
    D_data = np.diag(eigenvalues)
    D = Matrix(D_data.tolist())

    return P, D
```

### 6.2 Jordanæ ‡å‡†å½¢

**å®šä¹‰ 6.2** (Jordanå—)
$k \times k$ Jordanå—æ˜¯å½¢å¦‚ï¼š
$$
J_k(\lambda) = \begin{pmatrix}
\lambda & 1 & 0 & \cdots & 0 \\
0 & \lambda & 1 & \cdots & 0 \\
\vdots & \vdots & \ddots & \ddots & \vdots \\
0 & 0 & 0 & \lambda & 1 \\
0 & 0 & 0 & 0 & \lambda
\end{pmatrix}
$$
çš„çŸ©é˜µã€‚

**å®šç† 6.2** (Jordanæ ‡å‡†å½¢å®šç†)
æ¯ä¸ªå¤çŸ©é˜µéƒ½ç›¸ä¼¼äºä¸€ä¸ªJordanæ ‡å‡†å½¢çŸ©é˜µã€‚

```python
def jordan_canonical_form(A: Matrix) -> Tuple[Matrix, Matrix]:
    """è®¡ç®—Jordanæ ‡å‡†å½¢"""
    # è¿™æ˜¯ä¸€ä¸ªå¤æ‚çš„ç®—æ³•ï¼Œéœ€è¦è®¡ç®—å¹¿ä¹‰ç‰¹å¾å‘é‡
    eigenvalues, eigenvectors = A.eigenvectors()

    # æ„é€ JordançŸ©é˜µ
    J_data = np.zeros_like(A.data, dtype=complex)

    # è¿™é‡Œéœ€è¦å®ç°å®Œæ•´çš„Jordanåˆ†è§£ç®—æ³•
    # åŒ…æ‹¬è®¡ç®—å¹¿ä¹‰ç‰¹å¾å‘é‡å’ŒJordané“¾

    J = Matrix(J_data.tolist())
    P = Matrix(eigenvectors.tolist())

    return P, J
```

## 7. åº”ç”¨ä¸å‰æ²¿å‘å±•

### 7.1 é‡å­è®¡ç®—ä¸­çš„çº¿æ€§ä»£æ•°

**é‡å­æ¯”ç‰¹ä¸é‡å­é—¨**:

```python
import numpy as np
from typing import List, Tuple

class QuantumGate:
    """é‡å­é—¨ç±»"""

    def __init__(self, matrix: np.ndarray):
        self.matrix = matrix
        self.dim = matrix.shape[0]

        # éªŒè¯é…‰æ€§
        if not self.is_unitary():
            raise ValueError("é‡å­é—¨å¿…é¡»æ˜¯é…‰çŸ©é˜µ")

    def is_unitary(self) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºé…‰çŸ©é˜µ"""
        U_dagger = self.matrix.conj().T
        product = self.matrix @ U_dagger
        return np.allclose(product, np.eye(self.dim))

    def apply(self, state: np.ndarray) -> np.ndarray:
        """åº”ç”¨é‡å­é—¨åˆ°é‡å­æ€"""
        return self.matrix @ state

# å¸¸ç”¨é‡å­é—¨
class PauliGates:
    """Paulié—¨"""

    @staticmethod
    def X() -> QuantumGate:
        """Xé—¨ (NOTé—¨)"""
        return QuantumGate(np.array([[0, 1], [1, 0]]))

    @staticmethod
    def Y() -> QuantumGate:
        """Yé—¨"""
        return QuantumGate(np.array([[0, -1j], [1j, 0]]))

    @staticmethod
    def Z() -> QuantumGate:
        """Zé—¨"""
        return QuantumGate(np.array([[1, 0], [0, -1]]))

    @staticmethod
    def H() -> QuantumGate:
        """Hadamardé—¨"""
        return QuantumGate(np.array([[1, 1], [1, -1]]) / np.sqrt(2))

class QuantumCircuit:
    """é‡å­ç”µè·¯"""

    def __init__(self, num_qubits: int):
        self.num_qubits = num_qubits
        self.gates = []
        self.measurements = []

    def add_gate(self, gate: QuantumGate, qubit: int):
        """æ·»åŠ é‡å­é—¨"""
        self.gates.append((gate, qubit))

    def measure(self, qubit: int):
        """æ·»åŠ æµ‹é‡"""
        self.measurements.append(qubit)

    def execute(self, initial_state: np.ndarray) -> np.ndarray:
        """æ‰§è¡Œé‡å­ç”µè·¯"""
        state = initial_state.copy()

        for gate, qubit in self.gates:
            # è¿™é‡Œéœ€è¦å®ç°å¤šé‡å­æ¯”ç‰¹é—¨çš„å¼ é‡ç§¯
            # ç®€åŒ–ç‰ˆæœ¬ï¼šå‡è®¾æ˜¯å•é‡å­æ¯”ç‰¹é—¨
            if qubit == 0:
                state = gate.apply(state)

        return state
```

### 7.2 æœºå™¨å­¦ä¹ ä¸­çš„çº¿æ€§ä»£æ•°

**ä¸»æˆåˆ†åˆ†æ (PCA)**:

```python
def principal_component_analysis(data: np.ndarray, n_components: int) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """ä¸»æˆåˆ†åˆ†æ"""
    # ä¸­å¿ƒåŒ–æ•°æ®
    mean = np.mean(data, axis=0)
    centered_data = data - mean

    # è®¡ç®—åæ–¹å·®çŸ©é˜µ
    cov_matrix = np.cov(centered_data.T)

    # ç‰¹å¾å€¼åˆ†è§£
    eigenvalues, eigenvectors = np.linalg.eigh(cov_matrix)

    # é€‰æ‹©æœ€å¤§çš„n_componentsä¸ªç‰¹å¾å€¼
    selected_eigenvalues = eigenvalues[indices]
    selected_eigenvectors = eigenvectors[:, indices]

    # æŠ•å½±æ•°æ®
    projected_data = centered_data @ selected_eigenvectors

    return projected_data, selected_eigenvalues, selected_eigenvectors

def singular_value_decomposition_analysis(A: Matrix, k: int) -> Tuple[Matrix, np.ndarray, Matrix]:
    """æˆªæ–­å¥‡å¼‚å€¼åˆ†è§£"""
    U, s, Vt = svd_decomposition(A)

    # æˆªæ–­åˆ°kä¸ªå¥‡å¼‚å€¼
    U_k = U.data[:, :k]
    s_k = s[:k]
    Vt_k = Vt.data[:k, :]

    return Matrix(U_k.tolist()), s_k, Matrix(Vt_k.tolist())
```

### 7.3 æ•°å€¼çº¿æ€§ä»£æ•°å‰æ²¿

**å¿«é€ŸçŸ©é˜µä¹˜æ³•ç®—æ³•**:

```python
def strassen_matrix_multiplication(A: Matrix, B: Matrix) -> Matrix:
    """StrassençŸ©é˜µä¹˜æ³•ç®—æ³•"""
    if A.rows != A.cols or B.rows != B.cols or A.rows != B.rows:
        raise ValueError("Strassenç®—æ³•åªé€‚ç”¨äºç›¸åŒç»´åº¦çš„æ–¹é˜µ")

    n = A.rows

    # åŸºç¡€æƒ…å†µ
    if n <= 64:  # é˜ˆå€¼å¯è°ƒæ•´
        return A * B

    # åˆ†å—
    mid = n // 2

    A11 = Matrix(A.data[:mid, :mid].tolist())
    A12 = Matrix(A.data[:mid, mid:].tolist())
    A21 = Matrix(A.data[mid:, :mid].tolist())
    A22 = Matrix(A.data[mid:, mid:].tolist())

    B11 = Matrix(B.data[:mid, :mid].tolist())
    B12 = Matrix(B.data[:mid, mid:].tolist())
    B21 = Matrix(B.data[mid:, :mid].tolist())
    B22 = Matrix(B.data[mid:, mid:].tolist())

    # Strassençš„7ä¸ªä¹˜æ³•
    P1 = strassen_matrix_multiplication(A11, B12 - B22)
    P2 = strassen_matrix_multiplication(A11 + A12, B22)
    P3 = strassen_matrix_multiplication(A21 + A22, B11)
    P4 = strassen_matrix_multiplication(A22, B21 - B11)
    P5 = strassen_matrix_multiplication(A11 + A22, B11 + B22)
    P6 = strassen_matrix_multiplication(A12 - A22, B21 + B22)
    P7 = strassen_matrix_multiplication(A11 - A21, B11 + B12)

    # ç»„åˆç»“æœ
    C11 = P5 + P4 - P2 + P6
    C12 = P1 + P2
    C21 = P3 + P4
    C22 = P5 + P1 - P3 - P7

    # åˆå¹¶åˆ†å—
    result_data = np.block([[C11.data, C12.data], [C21.data, C22.data]])

    return Matrix(result_data.tolist())
```

## å‚è€ƒæ–‡çŒ®

### å›½é™…æ ‡å‡†æ–‡çŒ®

1. Wikipedia contributors. (2024). *Linear algebra*. Wikipedia.
2. Wikipedia contributors. (2024). *Matrix (mathematics)*. Wikipedia.
3. Wikipedia contributors. (2024). *Eigenvalues and eigenvectors*. Wikipedia.

### å›½é™…å¤§å­¦æ ‡å‡†

1. MIT Mathematics Department. (2025). *Linear Algebra*. MIT OpenCourseWare.
2. Stanford Mathematics Department. (2025). *Linear Algebra and Matrix Theory*. Stanford University.
3. Cambridge Mathematics Department. (2025). *Linear Algebra*. University of Cambridge.
4. Oxford Mathematics Department. (2025). *Linear Algebra*. University of Oxford.

### ç»å…¸æ•™æ

1. Axler, S. (2015). *Linear Algebra Done Right*. Springer.
2. Strang, G. (2016). *Introduction to Linear Algebra*. Wellesley-Cambridge Press.
3. Hoffman, K., & Kunze, R. (1971). *Linear Algebra*. Prentice-Hall.

### å‰æ²¿å‘å±•

1. Nielsen, M. A., & Chuang, I. L. (2010). *Quantum Computation and Quantum Information*. Cambridge University Press.
2. Bishop, C. M. (2006). *Pattern Recognition and Machine Learning*. Springer.
3. Golub, G. H., & Van Loan, C. F. (2013). *Matrix Computations*. Johns Hopkins University Press.

---

**æ–‡æ¡£ç‰ˆæœ¬**: 2.0
**æœ€åæ›´æ–°**: 2025å¹´1æœˆ
**ç»´æŠ¤è€…**: FormalMathé¡¹ç›®ç»„
**è®¸å¯è¯**: MIT License

## é™„å½•ï¼šå›½é™…æ ‡å‡†è¯æ˜æçº²ä¸ç»ƒä¹ æ¸…å•

### A. RREF ä¸ç§©-é›¶åŒ–åº¦å®šç†ï¼ˆè¯æ˜æçº²ï¼‰

- ç›®æ ‡ï¼šå¯¹ mÃ—n çŸ©é˜µ Aï¼Œç»æœ‰é™æ¬¡åˆç­‰è¡Œå˜æ¢åŒ–ä¸ºè¡Œæœ€ç®€å½¢ Rï¼ˆRREFï¼‰ã€‚
- å…³é”®ç‚¹ï¼š
  1) åˆç­‰è¡Œå˜æ¢ä¿æŒè§£é›†ç­‰ä»·ä¸ç§©ä¸å˜ï¼›
  2) RREF çš„ä¸»å…ƒåˆ—æ„æˆåˆ—ç©ºé—´çš„åŸºï¼›
  3) è‡ªç”±å˜é‡ä¸ªæ•° = n âˆ’ rank(A)ï¼›
  4) ç”±ç»´æ•°å…¬å¼å¾— rank(A)+nullity(A)=nã€‚
- æç¤ºï¼šç”¨é«˜æ–¯æ¶ˆå»æ„é€ ä¸»å…ƒåˆ—ï¼Œå†ç”¨çº¿æ€§æ— å…³ä¸ç”Ÿæˆæ€§éªŒè¯åŸºçš„æ€§è´¨ã€‚

### B. å››å¤§åŸºæœ¬å­ç©ºé—´ï¼ˆæ€§è´¨è¦ç‚¹ï¼‰

- Col(A) ä¸ N(Aáµ€) æ­£äº¤ï¼›Row(A)=Col(Aáµ€) ä¸ N(A) æ­£äº¤ã€‚
- ç»´æ•°å…³ç³»ï¼šdim Col(A)=rank(A)=dim Row(A)ï¼›dim N(A)=nâˆ’rank(A)ï¼›dim N(Aáµ€)=mâˆ’rank(A)ã€‚
- åº”ç”¨ï¼šæœ€å°äºŒä¹˜æ®‹å·® r=bâˆ’AxÌ‚âˆˆN(Aáµ€)ï¼Œä¸”ä¸ Col(A) æ­£äº¤ã€‚

### C. è°±å®šç†ä¸ Schur åˆ†è§£ï¼ˆè¯æ˜æçº²ï¼‰

- è°±å®šç†ï¼ˆå®å¯¹ç§°/Hermitianï¼‰ï¼š
  1) ä¸åŒç‰¹å¾å€¼çš„ç‰¹å¾å‘é‡æ­£äº¤ï¼›
  2) é€šè¿‡å½’ä¸€åŒ–ä¸æ‰©å……å¾—åˆ°æ­£äº¤ï¼ˆé…‰ï¼‰åŸºï¼›
  3) æ­£äº¤ï¼ˆé…‰ï¼‰å¯¹è§’åŒ–æˆç«‹ã€‚
- Schur åˆ†è§£ï¼ˆå¤ï¼‰ï¼š
  1) å•ä½é…‰ç›¸ä¼¼å¯å°† A åŒ–ä¸ºä¸Šä¸‰è§’ Tï¼ˆå¯¹è§’ä¸ºç‰¹å¾å€¼ï¼‰ï¼›
  2) ç”±Householder/QRè¿­ä»£æ„é€ æ•°å€¼ç®—æ³•ï¼›
  3) å®æƒ…å½¢ä¸ºå‡†ä¸Šä¸‰è§’ï¼ˆå«2Ã—2å…±è½­å—ï¼‰ã€‚

### D. SVD ä¸ä¼ªé€†ï¼ˆå½¢å¼åŒ–æ¥å£è‰æ¡ˆï¼‰

```python
from typing import Tuple
import numpy as np

class SVD:
    @staticmethod
    def decompose(A: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """è¿”å› U, s, Vtï¼Œæ»¡è¶³ A = U @ diag(s) @ Vt"""
        return np.linalg.svd(A, full_matrices=False)

class PseudoInverse:
    @staticmethod
    def pinv(A: np.ndarray, tol: float = 1e-12) -> np.ndarray:
        U, s, Vt = np.linalg.svd(A, full_matrices=False)
        s_plus = np.diag([1/si if si > tol else 0.0 for si in s])
        return Vt.T @ s_plus @ U.T
```

### E. ç¤ºä¾‹ä¸ç»ƒä¹ ï¼ˆå»ºè®®ï¼‰

- ç¤ºä¾‹1ï¼šç”¨ RREF åˆ¤å®š Ax=b æ˜¯å¦å¯è§£ï¼Œç»™å‡ºé€šè§£å‚æ•°è¡¨ç¤ºã€‚
- ç¤ºä¾‹2ï¼šæœ€å°äºŒä¹˜æ‹Ÿåˆç›´çº¿ï¼Œæ¯”è¾ƒæ³•æ–¹ç¨‹ä¸ SVD æ–¹æ¡ˆçš„æ•°å€¼ç¨³å®šæ€§ã€‚
- ç¤ºä¾‹3ï¼šåˆ¤æ–­çŸ©é˜µæ­£å®šæ€§ï¼ˆç‰¹å¾å€¼/Cholesky/ä¸»å­å¼ï¼‰ï¼Œå¹¶ç»™å‡ºç­‰ä»·æ¡ä»¶è¯æ˜ã€‚
- ç»ƒä¹ 1ï¼šè¯æ˜ Col(A) ä¸ N(Aáµ€) æ­£äº¤å¹¶ç»™å‡ºåä¾‹è¯´æ˜æ­£äº¤è¡¥ä»…åœ¨é€‚å½“å†…ç§¯ç©ºé—´ä¸‹æˆç«‹ã€‚
- ç»ƒä¹ 2ï¼šæ¨å¯¼ rank-nullity å¹¶åº”ç”¨äºå›¾æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µçš„é›¶ç©ºé—´ç»´æ•°åˆ†æã€‚
- ç»ƒä¹ 3ï¼šå®ç°æˆªæ–­ SVD çš„ä½ç§©é€¼è¿‘ï¼Œå¹¶åˆ†æè¯¯å·® âˆ¥Aâˆ’A_kâˆ¥â‚‚=Ïƒ_{k+1}ã€‚

### F. å¯è¿è¡Œç¤ºä¾‹ï¼šæ³•æ–¹ç¨‹ vs SVD æœ€å°äºŒä¹˜

```python
# æ¯”è¾ƒæ³•æ–¹ç¨‹ä¸SVDåœ¨ç—…æ€æƒ…å½¢ä¸‹çš„ç¨³å¥æ€§
import numpy as np

# æ„é€ ç—…æ€çŸ©é˜µï¼ˆå¥‡å¼‚å€¼è·¨è¶Šå¤šä¸ªæ•°é‡çº§ï¼‰
rng = np.random.default_rng(0)
U, _ = np.linalg.qr(rng.normal(size=(50, 10)))
Vt, _ = np.linalg.qr(rng.normal(size=(10, 10)))
s = np.geomspace(1, 1e-8, 10)  # å¥‡å¼‚å€¼é€’å‡
A = U[:, :10] @ np.diag(s) @ Vt.T
x_true = rng.normal(size=(10,))
b = A @ x_true + 1e-6 * rng.normal(size=(50,))

# æ³•æ–¹ç¨‹è§£ï¼ˆå¯èƒ½æ•°å€¼ä¸ç¨³ï¼‰
ATA = A.T @ A
ATb = A.T @ b
x_ne = np.linalg.solve(ATA, ATb)

# SVDä¼ªé€†è§£ï¼ˆæ›´ç¨³å¥ï¼‰
U_svd, s_svd, Vt_svd = np.linalg.svd(A, full_matrices=False)
s_plus = np.diag([1/si if si > 1e-12 else 0.0 for si in s_svd])
x_svd = Vt_svd.T @ s_plus @ U_svd.T @ b

err_ne = np.linalg.norm(x_ne - x_true)
err_svd = np.linalg.norm(x_svd - x_true)
cond2 = s_svd[0] / max(s_svd[-1], 1e-12)
print(f"2-æ¡ä»¶æ•° Îºâ‚‚(A) â‰ˆ {cond2:.2e}")
print(f"æ³•æ–¹ç¨‹è¯¯å·®: {err_ne:.3e}  |  SVDè¯¯å·®: {err_svd:.3e}")
```

### G. æ­£å®šæ€§ç­‰ä»·æ¡ä»¶ä¸CholeskyéªŒè¯

- æ­£å®šçŸ©é˜µç­‰ä»·æ¡ä»¶ï¼ˆå®å¯¹ç§° Aï¼‰ï¼š
  1) xáµ€Ax > 0(âˆ€xâ‰ 0)ï¼›
  2) æ‰€æœ‰ç‰¹å¾å€¼ > 0ï¼›
  3) å­˜åœ¨å”¯ä¸€ä¸‹ä¸‰è§’ Lï¼Œä½¿ A=LLáµ€ï¼ˆCholesky åˆ†è§£ï¼‰ï¼›
  4) æ‰€æœ‰é¡ºåºä¸»å­å¼ä¸ºæ­£ã€‚

```python
# ä¸‰ç§æ­£å®šæ€§æ£€æµ‹ï¼šç‰¹å¾å€¼ã€Choleskyã€ä¸»å­å¼ï¼ˆç¤ºæ„ï¼‰
import numpy as np

A = np.array([[4.0, 2.0, 0.0],
              [2.0, 3.0, 1.0],
              [0.0, 1.0, 2.0]])

# (1) ç‰¹å¾å€¼æ³•
w = np.linalg.eigvalsh(A)  # å¯¹ç§°é˜µç”¨eigvalshæ›´ç¨³
is_pd_eig = np.all(w > 0)

# (2) Choleskyï¼ˆæœ€æ¨èçš„æ•°å€¼æ–¹å¼ï¼‰
try:
    L = np.linalg.cholesky(A)
    is_pd_chol = True
except np.linalg.LinAlgError:
    is_pd_chol = False

# (3) ä¸»å­å¼ï¼ˆç¤ºæ„ï¼šä»…æ£€æŸ¥å‰kÃ—kä¸»å­å¼ï¼‰
def is_pd_leading_principal_minors(A: np.ndarray) -> bool:
    for k in range(1, A.shape[0] + 1):
        if np.linalg.det(A[:k, :k]) <= 0:
            return False
    return True

is_pd_principal = is_pd_leading_principal_minors(A)
print({
    'eig_method': is_pd_eig,
    'cholesky': is_pd_chol,
    'principal_minors': is_pd_principal
})
```

---

**äº¤äº’ä¸è¡¥å……èµ„æº / Interactive & Supplementary Resources**:

- [äº¤äº’å¼å›¾è¡¨å¢å¼ºï¼ˆçº¿æ€§å˜æ¢/ç‰¹å¾å€¼å¯è§†åŒ–ï¼‰](../../äº¤äº’å¼å›¾è¡¨å¢å¼º-2025å¹´1æœˆ.md)
- [å®šç†è¯æ˜è¡¥å……ï¼ˆç§©-é›¶åŒ–åº¦å®šç†ã€è°±å®šç†ï¼‰](../../å®šç†è¯æ˜è¡¥å……-2025å¹´1æœˆ.md)
- [åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……ï¼ˆçº¿æ€§æ— å…³/åŸº/çŸ©é˜µåä¾‹ï¼‰](../../åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……-2025å¹´1æœˆ.md)
- [å†å²èƒŒæ™¯è¡¥å……ï¼ˆçº¿æ€§ä»£æ•°ä¸çŸ©é˜µç†è®ºå‘å±•ï¼‰](../../å†å²èƒŒæ™¯è¡¥å……-2025å¹´1æœˆ.md)
