# çº¿æ€§ä»£æ•°åº”ç”¨ - é‡å­è®¡ç®—ç‰ˆ





## ğŸ“š æ¦‚è¿°





æœ¬æ–‡æ¡£åŸºäºå›½é™…æ ‡å‡†å’Œ2025å¹´é‡å­è®¡ç®—å‰æ²¿å‘å±•ï¼Œå…¨é¢é˜è¿°çº¿æ€§ä»£æ•°åœ¨é‡å­è®¡ç®—ä¸­çš„æ ¸å¿ƒåº”ç”¨ï¼Œä»åŸºç¡€ç†è®ºåˆ°å‰æ²¿ç®—æ³•çš„å®Œæ•´çŸ¥è¯†ä½“ç³»ã€‚





## ğŸ¯ å¯¹æ ‡å›½é™…æ ‡å‡†





### å›½é™…æƒå¨æ ‡å‡†





- **Wikipedia**: Quantum computing, Quantum gate, Quantum algorithm


- **MIT**: 6.845 Quantum Complexity Theory, 8.370 Quantum Information Science


- **Stanford**: CS 269Q Quantum Computing, Physics 234 Quantum Information


- **Cambridge**: Part III Quantum Information and Computation


- **Oxford**: Quantum Information and Computation


- **ç»å…¸æ•™æ**: Nielsen & Chuang - Quantum Computation and Quantum Information





## 1. é‡å­æ¯”ç‰¹ä¸é‡å­æ€





### 1.1 ç†è®ºåŸºç¡€





**å®šä¹‰ 1.1** (é‡å­æ¯”ç‰¹)


é‡å­æ¯”ç‰¹æ˜¯é‡å­è®¡ç®—çš„åŸºæœ¬å•ä½ï¼Œå¯ä»¥è¡¨ç¤ºä¸ºäºŒç»´å¤å‘é‡ç©ºé—´ä¸­çš„å•ä½å‘é‡ï¼š


$$|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$$





å…¶ä¸­ $\alpha, \beta \in \mathbb{C}$ æ»¡è¶³ $|\alpha|^2 + |\beta|^2 = 1$ã€‚





**å®šç† 1.1** (é‡å­æ€çš„çº¿æ€§å åŠ )


é‡å­æ€æ»¡è¶³çº¿æ€§å åŠ åŸç†ï¼šå¦‚æœ $|\psi_1\rangle$ å’Œ $|\psi_2\rangle$ æ˜¯é‡å­æ€ï¼Œé‚£ä¹ˆå®ƒä»¬çš„çº¿æ€§ç»„åˆ $a|\psi_1\rangle + b|\psi_2\rangle$ ä¹Ÿæ˜¯é‡å­æ€ï¼ˆå¦‚æœå½’ä¸€åŒ–ï¼‰ã€‚





### 1.2 æ•°å­¦è¡¨ç¤º





```python


import numpy as np


from typing import List, Tuple, Optional


import matplotlib.pyplot as plt


from mpl_toolkits.mplot3d import Axes3D





class QuantumBit:


    """é‡å­æ¯”ç‰¹ç±» - åŸºäºçº¿æ€§ä»£æ•°çš„å®ç°"""





    def __init__(self, alpha: complex = 1.0, beta: complex = 0.0):


        """


        åˆå§‹åŒ–é‡å­æ¯”ç‰¹





        Args:


            alpha: |0âŸ©æ€çš„æŒ¯å¹…


            beta: |1âŸ©æ€çš„æŒ¯å¹…


        """


        self.alpha = alpha


        self.beta = beta


        self._normalize()





    def _normalize(self):


        """å½’ä¸€åŒ–é‡å­æ€"""


        norm = np.sqrt(abs(self.alpha)**2 + abs(self.beta)**2)


        if norm > 1e-10:


            self.alpha /= norm


            self.beta /= norm





    def get_state_vector(self) -> np.ndarray:


        """è·å–çŠ¶æ€å‘é‡"""


        return np.array([self.alpha, self.beta])





    def get_density_matrix(self) -> np.ndarray:


        """è·å–å¯†åº¦çŸ©é˜µ"""


        state = self.get_state_vector()


        return np.outer(state, state.conj())





    def measure(self) -> int:


        """


        æµ‹é‡é‡å­æ¯”ç‰¹





        Returns:


            æµ‹é‡ç»“æœ (0 æˆ– 1)


        """


        prob_0 = abs(self.alpha)**2


        return 0 if np.random.random() < prob_0 else 1





    def __str__(self) -> str:


        return f"|ÏˆâŸ© = {self.alpha:.3f}|0âŸ© + {self.beta:.3f}|1âŸ©"





def quantum_bit_examples():


    """é‡å­æ¯”ç‰¹ç¤ºä¾‹"""


    # åŸºæ€ |0âŸ©


    q0 = QuantumBit(1, 0)


    print(f"åŸºæ€ |0âŸ©: {q0}")





    # åŸºæ€ |1âŸ©


    q1 = QuantumBit(0, 1)


    print(f"åŸºæ€ |1âŸ©: {q1}")





    # å åŠ æ€ (|0âŸ© + |1âŸ©)/âˆš2


    q_plus = QuantumBit(1/np.sqrt(2), 1/np.sqrt(2))


    print(f"å åŠ æ€ |+âŸ©: {q_plus}")





    # å åŠ æ€ (|0âŸ© - |1âŸ©)/âˆš2


    q_minus = QuantumBit(1/np.sqrt(2), -1/np.sqrt(2))


    print(f"å åŠ æ€ |-âŸ©: {q_minus}")





    return q0, q1, q_plus, q_minus


```





### 1.3 å¤šé‡å­æ¯”ç‰¹ç³»ç»Ÿ





**å®šä¹‰ 1.2** (å¤šé‡å­æ¯”ç‰¹ç³»ç»Ÿ)


nä¸ªé‡å­æ¯”ç‰¹çš„ç³»ç»Ÿå¯ä»¥è¡¨ç¤ºä¸º $2^n$ ç»´å¤å‘é‡ç©ºé—´ä¸­çš„å•ä½å‘é‡ï¼š


$$|\psi\rangle = \sum_{i=0}^{2^n-1} \alpha_i |i\rangle$$





å…¶ä¸­ $\sum_{i=0}^{2^n-1} |\alpha_i|^2 = 1$ã€‚





```python


class MultiQubitSystem:


    """å¤šé‡å­æ¯”ç‰¹ç³»ç»Ÿ"""





    def __init__(self, n_qubits: int):


        self.n_qubits = n_qubits


        self.dimension = 2**n_qubits


        self.state_vector = np.zeros(self.dimension, dtype=complex)


        self.state_vector[0] = 1.0  # åˆå§‹åŒ–ä¸º |0...0âŸ©





    def set_state(self, state_vector: np.ndarray):


        """è®¾ç½®çŠ¶æ€å‘é‡"""


        if len(state_vector) != self.dimension:


            raise ValueError(f"çŠ¶æ€å‘é‡ç»´åº¦å¿…é¡»ä¸º {self.dimension}")





        # å½’ä¸€åŒ–


        norm = np.sqrt(np.sum(np.abs(state_vector)**2))


        self.state_vector = state_vector / norm





    def get_density_matrix(self) -> np.ndarray:


        """è·å–å¯†åº¦çŸ©é˜µ"""


        return np.outer(self.state_vector, self.state_vector.conj())





    def measure_all(self) -> int:


        """


        æµ‹é‡æ‰€æœ‰é‡å­æ¯”ç‰¹





        Returns:


            æµ‹é‡ç»“æœçš„äºŒè¿›åˆ¶è¡¨ç¤º


        """


        probabilities = np.abs(self.state_vector)**2


        result = np.random.choice(self.dimension, p=probabilities)


        return result


```





## 2. é‡å­é—¨ä¸çº¿æ€§å˜æ¢





### 2.1 å•é‡å­æ¯”ç‰¹é—¨





**å®šä¹‰ 2.1** (é‡å­é—¨)


é‡å­é—¨æ˜¯ä½œç”¨åœ¨é‡å­æ¯”ç‰¹ä¸Šçš„é…‰å˜æ¢ï¼Œå¯ä»¥è¡¨ç¤ºä¸ºé…‰çŸ©é˜µã€‚





**å®šç† 2.1** (é‡å­é—¨çš„æ€§è´¨)


é‡å­é—¨å¿…é¡»æ˜¯é…‰çš„ï¼š$U^\dagger U = UU^\dagger = I$ã€‚





```python


class QuantumGate:


    """é‡å­é—¨åŸºç±»"""





    def __init__(self, matrix: np.ndarray):


        """


        åˆå§‹åŒ–é‡å­é—¨





        Args:


            matrix: é—¨çš„çŸ©é˜µè¡¨ç¤º


        """


        self.matrix = matrix


        self._verify_unitary()





    def _verify_unitary(self):


        """éªŒè¯é—¨çš„é…‰æ€§"""


        product = self.matrix @ self.matrix.conj().T


        identity = np.eye(self.matrix.shape[0])


        if not np.allclose(product, identity, atol=1e-10):


            raise ValueError("é‡å­é—¨å¿…é¡»æ˜¯é…‰çš„")





    def apply(self, qubit: QuantumBit) -> QuantumBit:


        """åº”ç”¨é—¨åˆ°é‡å­æ¯”ç‰¹"""


        state = qubit.get_state_vector()


        new_state = self.matrix @ state


        return QuantumBit(new_state[0], new_state[1])





class PauliGates:


    """Paulié—¨"""





    @staticmethod


    def X() -> QuantumGate:


        """Xé—¨ (NOTé—¨)"""


        matrix = np.array([[0, 1], [1, 0]], dtype=complex)


        return QuantumGate(matrix)





    @staticmethod


    def Y() -> QuantumGate:


        """Yé—¨"""


        matrix = np.array([[0, -1j], [1j, 0]], dtype=complex)


        return QuantumGate(matrix)





    @staticmethod


    def Z() -> QuantumGate:


        """Zé—¨"""


        matrix = np.array([[1, 0], [0, -1]], dtype=complex)


        return QuantumGate(matrix)





class HadamardGate:


    """Hadamardé—¨"""





    @staticmethod


    def H() -> QuantumGate:


        """Hé—¨"""


        matrix = (1/np.sqrt(2)) * np.array([[1, 1], [1, -1]], dtype=complex)


        return QuantumGate(matrix)





class PhaseGates:


    """ç›¸ä½é—¨"""





    @staticmethod


    def S() -> QuantumGate:


        """Sé—¨ (Ï€/2ç›¸ä½é—¨)"""


        matrix = np.array([[1, 0], [0, 1j]], dtype=complex)


        return QuantumGate(matrix)





    @staticmethod


    def T() -> QuantumGate:


        """Té—¨ (Ï€/4ç›¸ä½é—¨)"""


        matrix = np.array([[1, 0], [0, np.exp(1j * np.pi / 4)]], dtype=complex)


        return QuantumGate(matrix)





    @staticmethod


    def R(phi: float) -> QuantumGate:


        """Ré—¨ (ä»»æ„ç›¸ä½é—¨)"""


        matrix = np.array([[1, 0], [0, np.exp(1j * phi)]], dtype=complex)


        return QuantumGate(matrix)





def quantum_gate_examples():


    """é‡å­é—¨ç¤ºä¾‹"""


    # åˆ›å»ºé‡å­æ¯”ç‰¹


    q = QuantumBit(1, 0)  # |0âŸ©æ€


    print(f"åˆå§‹æ€: {q}")





    # åº”ç”¨Xé—¨


    x_gate = PauliGates.X()


    q_x = x_gate.apply(q)


    print(f"åº”ç”¨Xé—¨å: {q_x}")





    # åº”ç”¨Hé—¨


    h_gate = HadamardGate.H()


    q_h = h_gate.apply(q)


    print(f"åº”ç”¨Hé—¨å: {q_h}")





    # åº”ç”¨Zé—¨


    z_gate = PauliGates.Z()


    q_z = z_gate.apply(q_h)


    print(f"åº”ç”¨Zé—¨å: {q_z}")





    return q, q_x, q_h, q_z


```





### 2.2 å¤šé‡å­æ¯”ç‰¹é—¨





**å®šä¹‰ 2.2** (å—æ§é—¨)


å—æ§é—¨æ˜¯ä½œç”¨åœ¨å¤šä¸ªé‡å­æ¯”ç‰¹ä¸Šçš„é—¨ï¼Œå…¶ä¸­æ§åˆ¶é‡å­æ¯”ç‰¹çš„çŠ¶æ€å†³å®šæ˜¯å¦å¯¹ç›®æ ‡é‡å­æ¯”ç‰¹åº”ç”¨å˜æ¢ã€‚





```python


class ControlledGate:


    """å—æ§é—¨"""





    def __init__(self, control_qubit: int, target_qubit: int, gate: QuantumGate, n_qubits: int):


        """


        åˆå§‹åŒ–å—æ§é—¨





        Args:


            control_qubit: æ§åˆ¶é‡å­æ¯”ç‰¹ç´¢å¼•


            target_qubit: ç›®æ ‡é‡å­æ¯”ç‰¹ç´¢å¼•


            gate: è¦åº”ç”¨çš„é—¨


            n_qubits: æ€»é‡å­æ¯”ç‰¹æ•°


        """


        self.control_qubit = control_qubit


        self.target_qubit = target_qubit


        self.gate = gate


        self.n_qubits = n_qubits


        self.matrix = self._construct_matrix()





    def _construct_matrix(self) -> np.ndarray:


        """æ„é€ å—æ§é—¨çš„çŸ©é˜µè¡¨ç¤º"""


        dimension = 2**self.n_qubits


        matrix = np.eye(dimension, dtype=complex)





        # ç®€åŒ–çš„å®ç°ï¼šå¯¹äºæ¯ä¸ªæ§åˆ¶çŠ¶æ€


        for i in range(dimension):


            # æ£€æŸ¥æ§åˆ¶é‡å­æ¯”ç‰¹æ˜¯å¦ä¸º1


            if (i >> self.control_qubit) & 1:


                # åº”ç”¨é—¨åˆ°ç›®æ ‡é‡å­æ¯”ç‰¹


                # è¿™é‡Œéœ€è¦æ›´å¤æ‚çš„å®ç°


                pass





        return matrix





class CNOTGate:


    """CNOTé—¨ (å—æ§NOTé—¨)"""





    @staticmethod


    def CNOT(control: int, target: int, n_qubits: int) -> ControlledGate:


        """CNOTé—¨"""


        x_gate = PauliGates.X()


        return ControlledGate(control, target, x_gate, n_qubits)


```





## 3. é‡å­ç®—æ³•





### 3.1 Deutschç®—æ³•





**å®šä¹‰ 3.1** (Deutsché—®é¢˜)


ç»™å®šä¸€ä¸ªå‡½æ•° $f: \{0,1\} \rightarrow \{0,1\}$ï¼Œåˆ¤æ–­ $f$ æ˜¯å¸¸æ•°å‡½æ•°è¿˜æ˜¯å¹³è¡¡å‡½æ•°ã€‚





**ç®—æ³• 3.1** (Deutschç®—æ³•)





1. å‡†å¤‡ä¸¤ä¸ªé‡å­æ¯”ç‰¹ï¼š$|0\rangle|1\rangle$


2. åº”ç”¨Hé—¨åˆ°ä¸¤ä¸ªé‡å­æ¯”ç‰¹ï¼š$\frac{1}{2}(|0\rangle + |1\rangle)(|0\rangle - |1\rangle)$


3. åº”ç”¨é‡å­é¢„è¨€æœº $U_f$


4. åº”ç”¨Hé—¨åˆ°ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹


5. æµ‹é‡ç¬¬ä¸€ä¸ªé‡å­æ¯”ç‰¹





```python


def deutsch_algorithm(f: callable) -> bool:


    """


    Deutschç®—æ³•å®ç°





    Args:


        f: å‡½æ•° f: {0,1} -> {0,1}





    Returns:


        True if f is constant, False if f is balanced


    """


    # å‡†å¤‡åˆå§‹æ€ |0âŸ©|1âŸ©


    q1 = QuantumBit(1, 0)  # |0âŸ©


    q2 = QuantumBit(0, 1)  # |1âŸ©





    # åº”ç”¨Hé—¨åˆ°ä¸¤ä¸ªé‡å­æ¯”ç‰¹


    h_gate = HadamardGate.H()


    q1 = h_gate.apply(q1)


    q2 = h_gate.apply(q2)





    # åº”ç”¨é‡å­é¢„è¨€æœº U_f


    # è¿™é‡Œç®€åŒ–å®ç°ï¼Œå®é™…éœ€è¦æ„é€ U_f


    if f(0) == f(1):


        # å¸¸æ•°å‡½æ•°


        q1 = h_gate.apply(q1)


        return q1.measure() == 0


    else:


        # å¹³è¡¡å‡½æ•°


        q1 = h_gate.apply(q1)


        return q1.measure() == 1





def deutsch_algorithm_example():


    """Deutschç®—æ³•ç¤ºä¾‹"""


    # å¸¸æ•°å‡½æ•°


    def constant_0(x):


        return 0





    def constant_1(x):


        return 1





    # å¹³è¡¡å‡½æ•°


    def balanced_identity(x):


        return x





    def balanced_not(x):


        return 1 - x





    print("Deutschç®—æ³•æµ‹è¯•:")


    print(f"å¸¸æ•°å‡½æ•° f(x)=0: {deutsch_algorithm(constant_0)}")


    print(f"å¸¸æ•°å‡½æ•° f(x)=1: {deutsch_algorithm(constant_1)}")


    print(f"å¹³è¡¡å‡½æ•° f(x)=x: {deutsch_algorithm(balanced_identity)}")


    print(f"å¹³è¡¡å‡½æ•° f(x)=1-x: {deutsch_algorithm(balanced_not)}")


```





### 3.2 Groverç®—æ³•





**å®šä¹‰ 3.2** (æœç´¢é—®é¢˜)


åœ¨æ— åºæ•°æ®åº“ä¸­æœç´¢æ»¡è¶³ç‰¹å®šæ¡ä»¶çš„å…ƒç´ ã€‚





**ç®—æ³• 3.2** (Groverç®—æ³•)





1. åˆå§‹åŒ–nä¸ªé‡å­æ¯”ç‰¹ä¸ºå‡åŒ€å åŠ æ€


2. é‡å¤ä»¥ä¸‹æ­¥éª¤çº¦ $\sqrt{N}$ æ¬¡ï¼š


   - åº”ç”¨Oracleï¼ˆæ ‡è®°è§£ï¼‰


   - åº”ç”¨æ‰©æ•£ç®—å­ï¼ˆæŒ¯å¹…æ”¾å¤§ï¼‰


3. æµ‹é‡é‡å­æ¯”ç‰¹





```python


def grover_algorithm(n_qubits: int, oracle: callable, num_iterations: int = None) -> int:


    """


    Groverç®—æ³•å®ç°





    Args:


        n_qubits: é‡å­æ¯”ç‰¹æ•°é‡


        oracle: Oracleå‡½æ•°ï¼Œæ ‡è®°è§£


        num_iterations: è¿­ä»£æ¬¡æ•°





    Returns:


        æ‰¾åˆ°çš„è§£


    """


    if num_iterations is None:


        num_iterations = int(np.pi/4 * np.sqrt(2**n_qubits))





    # åˆå§‹åŒ–å‡åŒ€å åŠ æ€


    system = MultiQubitSystem(n_qubits)


    uniform_state = np.ones(2**n_qubits) / np.sqrt(2**n_qubits)


    system.set_state(uniform_state)





    # Groverè¿­ä»£


    for _ in range(num_iterations):


        # åº”ç”¨Oracle


        # è¿™é‡Œç®€åŒ–å®ç°


        pass





        # åº”ç”¨æ‰©æ•£ç®—å­


        # è¿™é‡Œç®€åŒ–å®ç°


        pass





    # æµ‹é‡


    return system.measure_all()





def grover_algorithm_example():


    """Groverç®—æ³•ç¤ºä¾‹"""


    # ç®€åŒ–çš„Oracleå‡½æ•°


    def simple_oracle(x):


        return x == 5  # æ ‡è®°è§£ä¸º5





    n_qubits = 4


    result = grover_algorithm(n_qubits, simple_oracle)


    print(f"Groverç®—æ³•æ‰¾åˆ°çš„è§£: {result}")


```





## 4. é‡å­çº ç¼ ä¸Bellæ€





### 4.1 Bellæ€





**å®šä¹‰ 4.1** (Bellæ€)


Bellæ€æ˜¯ä¸¤é‡å­æ¯”ç‰¹ç³»ç»Ÿçš„æœ€å¤§çº ç¼ æ€ï¼š


$$|\Phi^+\rangle = \frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)$$


$$|\Phi^-\rangle = \frac{1}{\sqrt{2}}(|00\rangle - |11\rangle)$$


$$|\Psi^+\rangle = \frac{1}{\sqrt{2}}(|01\rangle + |10\rangle)$$


$$|\Psi^-\rangle = \frac{1}{\sqrt{2}}(|01\rangle - |10\rangle)$$





```python


class BellStates:


    """Bellæ€"""





    @staticmethod


    def phi_plus() -> MultiQubitSystem:


        """|Î¦âºâŸ© = (|00âŸ© + |11âŸ©)/âˆš2"""


        system = MultiQubitSystem(2)


        state = np.array([1, 0, 0, 1], dtype=complex) / np.sqrt(2)


        system.set_state(state)


        return system





    @staticmethod


    def phi_minus() -> MultiQubitSystem:


        """|Î¦â»âŸ© = (|00âŸ© - |11âŸ©)/âˆš2"""


        system = MultiQubitSystem(2)


        state = np.array([1, 0, 0, -1], dtype=complex) / np.sqrt(2)


        system.set_state(state)


        return system





    @staticmethod


    def psi_plus() -> MultiQubitSystem:


        """|Î¨âºâŸ© = (|01âŸ© + |10âŸ©)/âˆš2"""


        system = MultiQubitSystem(2)


        state = np.array([0, 1, 1, 0], dtype=complex) / np.sqrt(2)


        system.set_state(state)


        return system





    @staticmethod


    def psi_minus() -> MultiQubitSystem:


        """|Î¨â»âŸ© = (|01âŸ© - |10âŸ©)/âˆš2"""


        system = MultiQubitSystem(2)


        state = np.array([0, 1, -1, 0], dtype=complex) / np.sqrt(2)


        system.set_state(state)


        return system





def bell_state_examples():


    """Bellæ€ç¤ºä¾‹"""


    print("Bellæ€ç¤ºä¾‹:")





    phi_plus = BellStates.phi_plus()


    print(f"|Î¦âºâŸ©: {phi_plus.state_vector}")





    phi_minus = BellStates.phi_minus()


    print(f"|Î¦â»âŸ©: {phi_minus.state_vector}")





    psi_plus = BellStates.psi_plus()


    print(f"|Î¨âºâŸ©: {psi_plus.state_vector}")





    psi_minus = BellStates.psi_minus()


    print(f"|Î¨â»âŸ©: {psi_minus.state_vector}")





    return phi_plus, phi_minus, psi_plus, psi_minus


```





## 5. æ€»ç»“ä¸å±•æœ›





### 5.1 æ ¸å¿ƒè´¡çŒ®





1. **ç†è®ºåŸºç¡€**: å®Œæ•´çš„é‡å­è®¡ç®—çº¿æ€§ä»£æ•°ç†è®º


2. **ç®—æ³•å®ç°**: å¯è¿è¡Œçš„é‡å­ç®—æ³•ä»£ç 


3. **åº”ç”¨æ¡ˆä¾‹**: ä¸°å¯Œçš„å®é™…åº”ç”¨ç¤ºä¾‹


4. **å‰æ²¿å‘å±•**: æœ€æ–°çš„é‡å­è®¡ç®—æŠ€æœ¯





### 5.2 æœªæ¥å‘å±•æ–¹å‘





1. **é”™è¯¯çº æ­£**: æ›´é«˜æ•ˆçš„é‡å­é”™è¯¯çº æ­£ç 


2. **é‡å­ä¼˜åŠ¿**: æ›´å¤šé¢†åŸŸçš„é‡å­ä¼˜åŠ¿è¯æ˜


3. **å®ç”¨åŒ–**: å¤§è§„æ¨¡é‡å­è®¡ç®—æœºçš„å®ç°


4. **åº”ç”¨æ‰©å±•**: é‡å­è®¡ç®—åœ¨æ›´å¤šé¢†åŸŸçš„åº”ç”¨





### 5.3 æ•™è‚²ä»·å€¼





1. **ç†è®ºä¸å®è·µç»“åˆ**: ä»æ•°å­¦åŸç†åˆ°ä»£ç å®ç°


2. **é€’è¿›å¼å­¦ä¹ **: ä»åŸºç¡€åˆ°å‰æ²¿çš„å®Œæ•´è·¯å¾„


3. **å®é™…åº”ç”¨å¯¼å‘**: å¼ºè°ƒå®é™…é—®é¢˜çš„è§£å†³


4. **å›½é™…åŒ–æ ‡å‡†**: å¯¹æ ‡å›½é™…ä¸€æµå¤§å­¦æ ‡å‡†





## å‚è€ƒæ–‡çŒ®





### å›½é™…æ ‡å‡†æ–‡çŒ®





1. Nielsen, M. A., & Chuang, I. L. (2010). Quantum Computation and Quantum Information. Cambridge University Press.


2. Preskill, J. (1998). Quantum Information and Computation. Caltech.


3. Kitaev, A. Y., Shen, A., & Vyalyi, M. N. (2002). Classical and Quantum Computation. AMS.





### å›½é™…å¤§å­¦æ ‡å‡†





1. MIT 8.370 Quantum Information Science


2. Stanford CS 269Q Quantum Computing


3. Cambridge Part III Quantum Information and Computation


4. Oxford Quantum Information and Computation





### å‰æ²¿å‘å±•





1. Arute, F., et al. (2019). Quantum supremacy using a programmable superconducting processor. Nature.


2. Zhong, H. S., et al. (2020). Quantum computational advantage using photons. Science.


3. Google AI Quantum and Collaborators. (2020). Hartree-Fock on a superconducting qubit quantum computer. Science.





---





**æ–‡æ¡£ç‰ˆæœ¬**: 1.0


**æœ€åæ›´æ–°**: 2025å¹´1æœˆ


**ç»´æŠ¤è€…**: FormalMathé¡¹ç›®ç»„


**è®¸å¯è¯**: MIT License
