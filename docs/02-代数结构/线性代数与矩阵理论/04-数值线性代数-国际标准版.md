# 数值线性代数 - 国际标准版

## 📚 概述

本文档基于国际标准和2025年著名大学数值分析课程，全面阐述数值线性代数的核心算法、稳定性分析和现代应用。

## 🎯 对标国际标准

### 国际权威标准

- **Wikipedia**: Numerical linear algebra, Matrix decomposition, Eigenvalue algorithm
- **MIT**: 18.335 Introduction to Numerical Methods
- **Stanford**: Math 104 Applied Matrix Theory
- **Cambridge**: Part II Numerical Analysis
- **Oxford**: Numerical Linear Algebra
- **Golub & Van Loan**: Matrix Computations (经典教材)

## 1. 矩阵分解理论

### 1.1 LU分解

**定义 1.1** (LU分解)
设 $A$ 是 $n \times n$ 矩阵，如果存在下三角矩阵 $L$ 和上三角矩阵 $U$ 使得：
$$A = LU$$
则称这是 $A$ 的LU分解。

**算法实现**:

```python
import numpy as np
from typing import Tuple, Optional

def lu_decomposition(A: np.ndarray, pivot: bool = True) -> Tuple[np.ndarray, np.ndarray, Optional[np.ndarray]]:
    """
    LU分解算法
    
    Args:
        A: 输入矩阵
        pivot: 是否使用选主元
        
    Returns:
        L: 下三角矩阵
        U: 上三角矩阵
        P: 置换矩阵（如果pivot=True）
    """
    n = A.shape[0]
    A_copy = A.copy().astype(float)
    
    if pivot:
        P = np.eye(n)
        L = np.eye(n)
        
        for k in range(n-1):
            # 选主元
            pivot_row = k + np.argmax(np.abs(A_copy[k:, k]))
            if pivot_row != k:
                A_copy[[k, pivot_row]] = A_copy[[pivot_row, k]]
                P[[k, pivot_row]] = P[[pivot_row, k]]
                if k > 0:
                    L[[k, pivot_row], :k] = L[[pivot_row, k], :k]
            
            # 消元
            for i in range(k+1, n):
                L[i, k] = A_copy[i, k] / A_copy[k, k]
                A_copy[i, k:] -= L[i, k] * A_copy[k, k:]
        
        U = np.triu(A_copy)
        return L, U, P
    else:
        L = np.eye(n)
        
        for k in range(n-1):
            for i in range(k+1, n):
                L[i, k] = A_copy[i, k] / A_copy[k, k]
                A_copy[i, k:] -= L[i, k] * A_copy[k, k:]
        
        U = np.triu(A_copy)
        return L, U, None

def solve_lu(L: np.ndarray, U: np.ndarray, b: np.ndarray, P: Optional[np.ndarray] = None) -> np.ndarray:
    """
    使用LU分解求解线性方程组 Ax = b
    """
    n = L.shape[0]
    
    # 前向代入 Ly = Pb
    if P is not None:
        y = np.linalg.solve(L, P @ b)
    else:
        y = np.linalg.solve(L, b)
    
    # 后向代入 Ux = y
    x = np.linalg.solve(U, y)
    
    return x
```

### 1.2 QR分解

**定义 1.2** (QR分解)
设 $A$ 是 $m \times n$ 矩阵，如果存在正交矩阵 $Q$ 和上三角矩阵 $R$ 使得：
$$A = QR$$
则称这是 $A$ 的QR分解。

**Gram-Schmidt正交化**:

```python
def gram_schmidt_qr(A: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    """
    使用Gram-Schmidt正交化的QR分解
    """
    m, n = A.shape
    Q = np.zeros((m, n))
    R = np.zeros((n, n))
    
    for j in range(n):
        v = A[:, j].copy()
        
        # 减去前面所有向量的投影
        for i in range(j):
            R[i, j] = np.dot(Q[:, i], A[:, j])
            v -= R[i, j] * Q[:, i]
        
        # 归一化
        R[j, j] = np.linalg.norm(v)
        if R[j, j] > 1e-12:
            Q[:, j] = v / R[j, j]
        else:
            Q[:, j] = v
    
    return Q, R

def householder_qr(A: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    """
    使用Householder变换的QR分解（更稳定）
    """
    m, n = A.shape
    A_copy = A.copy().astype(float)
    Q = np.eye(m)
    
    for k in range(min(m-1, n)):
        # 构造Householder向量
        x = A_copy[k:, k]
        e1 = np.zeros_like(x)
        e1[0] = 1
        
        u = x - np.linalg.norm(x) * e1
        if np.linalg.norm(u) > 1e-12:
            u = u / np.linalg.norm(u)
        else:
            u = np.zeros_like(u)
        
        # Householder矩阵 H = I - 2uu^T
        H = np.eye(m-k) - 2 * np.outer(u, u)
        
        # 更新A和Q
        A_copy[k:, k:] = H @ A_copy[k:, k:]
        Q[k:, :] = H @ Q[k:, :]
    
    R = np.triu(A_copy[:n, :])
    Q = Q.T
    
    return Q, R
```

### 1.3 奇异值分解 (SVD)

**定义 1.3** (奇异值分解)
设 $A$ 是 $m \times n$ 矩阵，存在正交矩阵 $U$、对角矩阵 $\Sigma$ 和正交矩阵 $V^T$ 使得：
$$A = U\Sigma V^T$$

**算法实现**:

```python
def power_iteration(A: np.ndarray, max_iter: int = 100, tol: float = 1e-10) -> Tuple[float, np.ndarray]:
    """
    幂迭代法计算最大特征值和特征向量
    """
    n = A.shape[0]
    x = np.random.randn(n)
    x = x / np.linalg.norm(x)
    
    for _ in range(max_iter):
        x_new = A @ x
        x_new = x_new / np.linalg.norm(x_new)
        
        if np.linalg.norm(x_new - x) < tol:
            break
        x = x_new
    
    eigenvalue = np.dot(x, A @ x)
    return eigenvalue, x

def svd_power_method(A: np.ndarray, k: int = None) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    使用幂迭代法的SVD分解（简化版）
    """
    if k is None:
        k = min(A.shape)
    
    m, n = A.shape
    U = np.zeros((m, k))
    S = np.zeros(k)
    Vt = np.zeros((k, n))
    
    # 计算A^T A的最大特征值和特征向量
    ATA = A.T @ A
    for i in range(k):
        eigenvalue, eigenvector = power_iteration(ATA)
        S[i] = np.sqrt(eigenvalue)
        Vt[i, :] = eigenvector
        U[:, i] = (A @ eigenvector) / S[i]
    
    return U, S, Vt

def svd_truncated(A: np.ndarray, k: int) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    截断SVD分解
    """
    U, s, Vt = np.linalg.svd(A, full_matrices=False)
    return U[:, :k], s[:k], Vt[:k, :]
```

## 2. 特征值计算

### 2.1 幂迭代法

**算法描述**:
对于矩阵 $A$，幂迭代法通过迭代 $x_{k+1} = \frac{Ax_k}{\|Ax_k\|}$ 来计算最大特征值。

```python
def inverse_power_iteration(A: np.ndarray, sigma: float = 0, max_iter: int = 100) -> Tuple[complex, np.ndarray]:
    """
    反幂迭代法计算最接近sigma的特征值和特征向量
    """
    n = A.shape[0]
    I = np.eye(n)
    B = A - sigma * I
    
    x = np.random.randn(n)
    x = x / np.linalg.norm(x)
    
    for _ in range(max_iter):
        # 解线性方程组 Bx_new = x
        x_new = np.linalg.solve(B, x)
        x_new = x_new / np.linalg.norm(x_new)
        
        if np.linalg.norm(x_new - x) < 1e-10:
            break
        x = x_new
    
    eigenvalue = sigma + 1 / np.dot(x, np.linalg.solve(B, x))
    return eigenvalue, x
```

### 2.2 QR算法

**QR算法**是计算所有特征值的标准方法：

```python
def qr_algorithm(A: np.ndarray, max_iter: int = 100, tol: float = 1e-10) -> Tuple[np.ndarray, np.ndarray]:
    """
    QR算法计算所有特征值
    """
    n = A.shape[0]
    A_copy = A.copy().astype(float)
    Q_total = np.eye(n)
    
    for iteration in range(max_iter):
        # QR分解
        Q, R = np.linalg.qr(A_copy)
        
        # 更新A
        A_copy = R @ Q
        Q_total = Q_total @ Q
        
        # 检查收敛性
        if np.max(np.abs(np.tril(A_copy, -1))) < tol:
            break
    
    eigenvalues = np.diag(A_copy)
    eigenvectors = Q_total
    
    return eigenvalues, eigenvectors
```

## 3. 线性方程组求解

### 3.1 直接方法

**高斯消去法**:

```python
def gaussian_elimination(A: np.ndarray, b: np.ndarray) -> np.ndarray:
    """
    高斯消去法求解线性方程组
    """
    n = A.shape[0]
    A_aug = np.column_stack([A, b])
    
    # 前向消元
    for k in range(n-1):
        for i in range(k+1, n):
            factor = A_aug[i, k] / A_aug[k, k]
            A_aug[i, k:] -= factor * A_aug[k, k:]
    
    # 后向代入
    x = np.zeros(n)
    for i in range(n-1, -1, -1):
        x[i] = (A_aug[i, -1] - np.dot(A_aug[i, i+1:n], x[i+1:])) / A_aug[i, i]
    
    return x
```

### 3.2 迭代方法

**雅可比迭代法**:

```python
def jacobi_iteration(A: np.ndarray, b: np.ndarray, x0: np.ndarray = None, 
                    max_iter: int = 1000, tol: float = 1e-10) -> np.ndarray:
    """
    雅可比迭代法求解线性方程组
    """
    n = A.shape[0]
    if x0 is None:
        x0 = np.zeros(n)
    
    x = x0.copy()
    
    for iteration in range(max_iter):
        x_new = np.zeros(n)
        
        for i in range(n):
            sum_ax = 0
            for j in range(n):
                if i != j:
                    sum_ax += A[i, j] * x[j]
            x_new[i] = (b[i] - sum_ax) / A[i, i]
        
        if np.linalg.norm(x_new - x) < tol:
            break
        x = x_new
    
    return x
```

**共轭梯度法**:

```python
def conjugate_gradient(A: np.ndarray, b: np.ndarray, x0: np.ndarray = None,
                      max_iter: int = 1000, tol: float = 1e-10) -> np.ndarray:
    """
    共轭梯度法求解线性方程组（适用于对称正定矩阵）
    """
    n = A.shape[0]
    if x0 is None:
        x0 = np.zeros(n)
    
    x = x0.copy()
    r = b - A @ x
    p = r.copy()
    
    for iteration in range(max_iter):
        Ap = A @ p
        alpha = np.dot(r, r) / np.dot(p, Ap)
        x = x + alpha * p
        r_new = r - alpha * Ap
        
        if np.linalg.norm(r_new) < tol:
            break
        
        beta = np.dot(r_new, r_new) / np.dot(r, r)
        p = r_new + beta * p
        r = r_new
    
    return x
```

## 4. 数值稳定性分析

### 4.1 条件数

**定义 4.1** (矩阵条件数)
矩阵 $A$ 的条件数定义为：
$$\kappa(A) = \|A\| \cdot \|A^{-1}\|$$

```python
def condition_number(A: np.ndarray, norm_type: str = "2") -> float:
    """
    计算矩阵条件数
    """
    if norm_type == "2":
        return np.linalg.cond(A, 2)
    elif norm_type == "1":
        return np.linalg.cond(A, 1)
    elif norm_type == "inf":
        return np.linalg.cond(A, np.inf)
    else:
        raise ValueError("不支持的范数类型")

def backward_error_analysis(A: np.ndarray, b: np.ndarray, x_computed: np.ndarray) -> float:
    """
    后向误差分析
    """
    residual = b - A @ x_computed
    backward_error = np.linalg.norm(residual) / np.linalg.norm(b)
    return backward_error
```

### 4.2 稳定性测试

```python
def stability_test():
    """
    数值稳定性测试
    """
    # 构造病态矩阵
    n = 10
    A = np.random.randn(n, n)
    A = A @ A.T  # 对称正定矩阵
    
    # 添加扰动使其病态
    A[0, 0] = 1e-12
    A[n-1, n-1] = 1e12
    
    b = np.random.randn(n)
    x_true = np.linalg.solve(A, b)
    
    # 使用不同方法求解
    methods = {
        "直接求解": lambda: np.linalg.solve(A, b),
        "LU分解": lambda: solve_lu(*lu_decomposition(A)[:2], b),
        "QR分解": lambda: np.linalg.solve(A, b),  # 简化
        "共轭梯度": lambda: conjugate_gradient(A, b)
    }
    
    print("数值稳定性测试结果:")
    print(f"条件数: {condition_number(A):.2e}")
    print()
    
    for method_name, method_func in methods.items():
        try:
            x_computed = method_func()
            error = np.linalg.norm(x_computed - x_true) / np.linalg.norm(x_true)
            backward_error = backward_error_analysis(A, b, x_computed)
            print(f"{method_name}:")
            print(f"  相对误差: {error:.2e}")
            print(f"  后向误差: {backward_error:.2e}")
        except Exception as e:
            print(f"{method_name}: 失败 - {e}")
        print()

if __name__ == "__main__":
    stability_test()
```

## 5. 现代应用

### 5.1 大规模稀疏矩阵

```python
from scipy import sparse

def sparse_matrix_operations():
    """
    稀疏矩阵操作示例
    """
    # 构造稀疏矩阵
    n = 1000
    A_sparse = sparse.random(n, n, density=0.01, format='csr')
    b = np.random.randn(n)
    
    # 稀疏矩阵求解
    x_sparse = sparse.linalg.spsolve(A_sparse, b)
    
    # 特征值计算
    eigenvalues = sparse.linalg.eigs(A_sparse, k=5, which='LM')[0]
    
    return x_sparse, eigenvalues
```

### 5.2 并行计算

```python
import multiprocessing as mp
from concurrent.futures import ProcessPoolExecutor

def parallel_matrix_multiply(A: np.ndarray, B: np.ndarray, n_jobs: int = -1) -> np.ndarray:
    """
    并行矩阵乘法
    """
    if n_jobs == -1:
        n_jobs = mp.cpu_count()
    
    m, n = A.shape
    n, p = B.shape
    
    def multiply_block(args):
        i_start, i_end = args
        return A[i_start:i_end, :] @ B
    
    # 分块
    block_size = m // n_jobs
    blocks = [(i * block_size, min((i + 1) * block_size, m)) for i in range(n_jobs)]
    
    with ProcessPoolExecutor(max_workers=n_jobs) as executor:
        results = list(executor.map(multiply_block, blocks))
    
    return np.vstack(results)
```

## 6. 性能优化

### 6.1 内存优化

```python
def memory_efficient_qr(A: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    """
    内存高效的QR分解
    """
    m, n = A.shape
    A_copy = A.copy()
    Q = np.eye(m)
    
    for k in range(min(m-1, n)):
        # 就地计算Householder变换
        x = A_copy[k:, k]
        norm_x = np.linalg.norm(x)
        
        if norm_x > 1e-12:
            if x[0] >= 0:
                x[0] += norm_x
            else:
                x[0] -= norm_x
            
            beta = 2.0 / np.dot(x, x)
            
            # 更新A
            for j in range(k, n):
                v_dot_a = np.dot(x, A_copy[k:, j])
                A_copy[k:, j] -= beta * v_dot_a * x
            
            # 更新Q
            for j in range(m):
                v_dot_q = np.dot(x, Q[k:, j])
                Q[k:, j] -= beta * v_dot_q * x
    
    R = np.triu(A_copy[:n, :])
    return Q.T, R
```

### 6.2 数值精度优化

```python
def high_precision_svd(A: np.ndarray, precision: str = "double") -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """
    高精度SVD分解
    """
    if precision == "double":
        dtype = np.float64
    elif precision == "longdouble":
        dtype = np.longdouble
    else:
        raise ValueError("不支持的精度类型")
    
    A_high = A.astype(dtype)
    U, s, Vt = np.linalg.svd(A_high, full_matrices=False)
    
    return U, s, Vt
```

## 参考文献

### 国际标准文献

1. Wikipedia contributors. (2024). *Numerical linear algebra*. Wikipedia.
2. Wikipedia contributors. (2024). *Matrix decomposition*. Wikipedia.
3. Wikipedia contributors. (2024). *Eigenvalue algorithm*. Wikipedia.

### 国际大学标准

1. MIT Mathematics Department. (2025). *Introduction to Numerical Methods*. MIT OpenCourseWare.
2. Stanford Mathematics Department. (2025). *Applied Matrix Theory*. Stanford University.
3. Cambridge Mathematics Department. (2025). *Numerical Analysis*. University of Cambridge.

### 经典教材

1. Golub, G. H., & Van Loan, C. F. (2013). *Matrix Computations*. Johns Hopkins University Press.
2. Trefethen, L. N., & Bau, D. (1997). *Numerical Linear Algebra*. SIAM.
3. Demmel, J. W. (1997). *Applied Numerical Linear Algebra*. SIAM.

### 前沿发展

1. Higham, N. J. (2002). *Accuracy and Stability of Numerical Algorithms*. SIAM.
2. Saad, Y. (2003). *Iterative Methods for Sparse Linear Systems*. SIAM.
3. Anderson, E., et al. (1999). *LAPACK Users' Guide*. SIAM.

---

**文档版本**: 1.0  
**最后更新**: 2025年1月  
**维护者**: FormalMath项目组  
**许可证**: MIT License
