# æä»£æ•°åº”ç”¨ï¼šè¡¨ç¤ºè®º / Lie Algebra Applications: Representation Theory

## æ¦‚è¿° / Overview

æä»£æ•°çš„è¡¨ç¤ºè®ºæ˜¯ç ”ç©¶æä»£æ•°å¦‚ä½•ä½œç”¨åœ¨å‘é‡ç©ºé—´ä¸Šçš„ç†è®ºã€‚é€šè¿‡è¡¨ç¤ºè®ºï¼Œæˆ‘ä»¬å¯ä»¥å°†æŠ½è±¡çš„ä»£æ•°ç»“æ„è½¬åŒ–ä¸ºå…·ä½“çš„çº¿æ€§å˜æ¢ï¼Œä»è€Œæ›´å¥½åœ°ç†è§£æä»£æ•°çš„ç»“æ„å’Œæ€§è´¨ã€‚

### æ ¸å¿ƒæ¦‚å¿µ

- **è¡¨ç¤º**ï¼šæä»£æ•°åˆ°çº¿æ€§å˜æ¢çš„ä»£æ•°çš„åŒæ€
- **ä¸å¯çº¦è¡¨ç¤º**ï¼šæ²¡æœ‰éå¹³å‡¡ä¸å˜å­ç©ºé—´çš„è¡¨ç¤º
- **æœ€é«˜æƒè¡¨ç¤º**ï¼šå…·æœ‰æœ€é«˜æƒå‘é‡çš„è¡¨ç¤º
- **ç‰¹å¾æ ‡**ï¼šè¡¨ç¤ºçš„å¯¹è§’çº¿å…ƒç´ çš„å’Œ

## 1. æä»£æ•°è¡¨ç¤ºçš„åŸºæœ¬æ¦‚å¿µ

### 1.1 è¡¨ç¤ºçš„å®šä¹‰

æä»£æ•°çš„è¡¨ç¤ºæ˜¯ä¸€ä¸ªçº¿æ€§æ˜ å°„ï¼Œä¿æŒææ‹¬å·ç»“æ„ï¼š

```python
class LieAlgebraRepresentation:
    """æä»£æ•°è¡¨ç¤º"""
    
    def __init__(self, lie_algebra, vector_space):
        self.lie_algebra = lie_algebra
        self.vector_space = vector_space
        self.dimension = vector_space.dimension
        
    def representation_map(self, X):
        """è¡¨ç¤ºæ˜ å°„ Ï(X)"""
        # å°†æä»£æ•°å…ƒç´ æ˜ å°„ä¸ºçº¿æ€§å˜æ¢
        pass
        
    def bracket_preservation(self, X, Y):
        """ä¿æŒææ‹¬å·ï¼šÏ([X, Y]) = [Ï(X), Ï(Y)]"""
        bracket_xy = self.lie_algebra.bracket(X, Y)
        rho_bracket = self.representation_map(bracket_xy)
        
        rho_x = self.representation_map(X)
        rho_y = self.representation_map(Y)
        bracket_rho = self.vector_space.commutator(rho_x, rho_y)
        
        return rho_bracket == bracket_rho
```

### 1.2 è¡¨ç¤ºçš„æ„é€ 

ä»æä»£æ•°æ„é€ è¡¨ç¤ºçš„æ–¹æ³•ï¼š

```python
class RepresentationConstruction:
    """è¡¨ç¤ºæ„é€ """
    
    def __init__(self, lie_algebra):
        self.lie_algebra = lie_algebra
        
    def adjoint_representation(self):
        """ä¼´éšè¡¨ç¤º"""
        # ad(X)(Y) = [X, Y]
        def ad(X):
            def ad_X(Y):
                return self.lie_algebra.bracket(X, Y)
            return ad_X
        return ad
        
    def trivial_representation(self, dimension):
        """å¹³å‡¡è¡¨ç¤º"""
        # æ‰€æœ‰å…ƒç´ æ˜ å°„ä¸ºé›¶çŸ©é˜µ
        def trivial_rep(X):
            return np.zeros((dimension, dimension))
        return trivial_rep
        
    def tensor_product_representation(self, rep1, rep2):
        """å¼ é‡ç§¯è¡¨ç¤º"""
        def tensor_rep(X):
            rho1_X = rep1(X)
            rho2_X = rep2(X)
            return np.kron(rho1_X, rho2_X)
        return tensor_rep
```

## 2. ä¸å¯çº¦è¡¨ç¤º

### 2.1 ä¸å¯çº¦è¡¨ç¤ºçš„å®šä¹‰

ä¸å¯çº¦è¡¨ç¤ºæ˜¯æ²¡æœ‰éå¹³å‡¡ä¸å˜å­ç©ºé—´çš„è¡¨ç¤ºï¼š

```python
class IrreducibleRepresentation:
    """ä¸å¯çº¦è¡¨ç¤º"""
    
    def __init__(self, representation):
        self.representation = representation
        
    def is_irreducible(self):
        """åˆ¤æ–­è¡¨ç¤ºæ˜¯å¦ä¸å¯çº¦"""
        # æ£€æŸ¥æ˜¯å¦æœ‰éå¹³å‡¡çš„ä¸å˜å­ç©ºé—´
        for subspace in self.find_invariant_subspaces():
            if subspace.dimension > 0 and subspace.dimension < self.representation.dimension:
                return False
        return True
        
    def find_invariant_subspaces(self):
        """å¯»æ‰¾ä¸å˜å­ç©ºé—´"""
        # é€šè¿‡è¡¨ç¤ºçŸ©é˜µçš„å…¬å…±ç‰¹å¾å‘é‡å¯»æ‰¾ä¸å˜å­ç©ºé—´
        invariant_subspaces = []
        
        # æ”¶é›†æ‰€æœ‰è¡¨ç¤ºçŸ©é˜µ
        matrices = []
        for basis_element in self.representation.lie_algebra.basis():
            matrix = self.representation.representation_map(basis_element)
            matrices.append(matrix)
            
        # å¯»æ‰¾å…¬å…±ç‰¹å¾å‘é‡
        common_eigenvectors = self.find_common_eigenvectors(matrices)
        
        # æ„é€ ä¸å˜å­ç©ºé—´
        for eigenvectors in common_eigenvectors:
            subspace = self.construct_subspace(eigenvectors)
            if self.is_invariant_subspace(subspace):
                invariant_subspaces.append(subspace)
                
        return invariant_subspaces
```

### 2.2 èˆ’å°”å¼•ç†

èˆ’å°”å¼•ç†æ˜¯è¡¨ç¤ºè®ºä¸­çš„åŸºæœ¬å®šç†ï¼š

```python
class SchurLemma:
    """èˆ’å°”å¼•ç†"""
    
    def __init__(self):
        pass
        
    def schur_lemma_complex(self, rep1, rep2, intertwiner):
        """å¤æ•°åŸŸä¸Šçš„èˆ’å°”å¼•ç†"""
        # å¦‚æœrep1å’Œrep2éƒ½æ˜¯ä¸å¯çº¦çš„ï¼Œä¸”Tæ˜¯å®ƒä»¬ä¹‹é—´çš„ intertwiner
        # é‚£ä¹ˆè¦ä¹ˆT = 0ï¼Œè¦ä¹ˆrep1å’Œrep2ç­‰ä»·ä¸”Tæ˜¯æ ‡é‡å€
        
        if not (rep1.is_irreducible() and rep2.is_irreducible()):
            return "è¡¨ç¤ºä¸æ˜¯ä¸å¯çº¦çš„"
            
        if rep1.dimension != rep2.dimension:
            return "è¡¨ç¤ºä¸ç­‰ä»·ï¼ŒT = 0"
            
        # æ£€æŸ¥Tæ˜¯å¦ä¸ºæ ‡é‡å€
        if self.is_scalar_multiple(intertwiner):
            return "Tæ˜¯æ ‡é‡å€"
        else:
            return "T = 0"
            
    def is_scalar_multiple(self, matrix):
        """åˆ¤æ–­çŸ©é˜µæ˜¯å¦ä¸ºæ ‡é‡å€"""
        # æ£€æŸ¥çŸ©é˜µæ˜¯å¦ä¸å•ä½çŸ©é˜µæˆæ¯”ä¾‹
        if np.allclose(matrix, 0):
            return True
            
        # è®¡ç®—ç‰¹å¾å€¼
        eigenvalues = np.linalg.eigvals(matrix)
        if len(set(eigenvalues)) == 1:  # æ‰€æœ‰ç‰¹å¾å€¼ç›¸ç­‰
            return True
        return False
```

## 3. æœ€é«˜æƒè¡¨ç¤º

### 3.1 æœ€é«˜æƒå‘é‡çš„å®šä¹‰

æœ€é«˜æƒè¡¨ç¤ºæ˜¯å…·æœ‰æœ€é«˜æƒå‘é‡çš„è¡¨ç¤ºï¼š

```python
class HighestWeightRepresentation:
    """æœ€é«˜æƒè¡¨ç¤º"""
    
    def __init__(self, lie_algebra, cartan_subalgebra):
        self.lie_algebra = lie_algebra
        self.cartan = cartan_subalgebra
        
    def find_highest_weight_vector(self, representation):
        """å¯»æ‰¾æœ€é«˜æƒå‘é‡"""
        # åœ¨è¡¨ç¤ºç©ºé—´ä¸­å¯»æ‰¾æœ€é«˜æƒå‘é‡
        weight_vectors = self.find_weight_vectors(representation)
        
        # æŒ‰æƒé‡æ’åºï¼Œæ‰¾åˆ°æœ€é«˜æƒé‡
        highest_weight = max(weight_vectors.keys())
        return weight_vectors[highest_weight]
        
    def find_weight_vectors(self, representation):
        """å¯»æ‰¾æƒå‘é‡"""
        weight_vectors = {}
        
        # å¯¹Cartanå­ä»£æ•°çš„æ¯ä¸ªåŸºå…ƒç´ 
        for H in self.cartan.basis():
            # å¯»æ‰¾Hçš„ç‰¹å¾å‘é‡
            rho_H = representation.representation_map(H)
            eigenvalues, eigenvectors = np.linalg.eig(rho_H)
            
            for eigenvalue, eigenvector in zip(eigenvalues, eigenvectors.T):
                weight = eigenvalue
                if weight not in weight_vectors:
                    weight_vectors[weight] = []
                weight_vectors[weight].append(eigenvector)
                
        return weight_vectors
```

### 3.2 æ ¹ç³»å’Œæƒé‡

æ ¹ç³»å’Œæƒé‡æ˜¯æœ€é«˜æƒè¡¨ç¤ºç†è®ºçš„æ ¸å¿ƒï¼š

```python
class RootSystem:
    """æ ¹ç³»"""
    
    def __init__(self, lie_algebra):
        self.lie_algebra = lie_algebra
        
    def find_roots(self):
        """å¯»æ‰¾æ ¹ç³»"""
        roots = []
        cartan = self.find_cartan_subalgebra()
        
        # å¯¹æ¯ä¸ªéCartanå…ƒç´ ï¼Œè®¡ç®—å…¶å…³äºCartanå­ä»£æ•°çš„æƒé‡
        for X in self.lie_algebra.basis():
            if X not in cartan.basis():
                weight = self.compute_weight(X, cartan)
                if weight not in roots:
                    roots.append(weight)
                    
        return roots
        
    def positive_roots(self):
        """æ­£æ ¹"""
        all_roots = self.find_roots()
        # æ ¹æ®æŸç§é¡ºåºç¡®å®šæ­£æ ¹
        positive_roots = []
        for root in all_roots:
            if self.is_positive_root(root):
                positive_roots.append(root)
        return positive_roots
        
    def simple_roots(self):
        """å•æ ¹"""
        positive_roots = self.positive_roots()
        simple_roots = []
        
        # å¯»æ‰¾ä¸å¯åˆ†è§£çš„æ­£æ ¹
        for root in positive_roots:
            if self.is_simple_root(root, positive_roots):
                simple_roots.append(root)
                
        return simple_roots
```

## 4. ç‰¹å¾æ ‡ç†è®º

### 4.1 ç‰¹å¾æ ‡çš„å®šä¹‰

ç‰¹å¾æ ‡æ˜¯è¡¨ç¤ºçš„å¯¹è§’çº¿å…ƒç´ çš„å’Œï¼š

```python
class Character:
    """ç‰¹å¾æ ‡"""
    
    def __init__(self, representation):
        self.representation = representation
        
    def character_function(self, g):
        """ç‰¹å¾æ ‡å‡½æ•° Ï‡(g) = tr(Ï(g))"""
        rho_g = self.representation.representation_map(g)
        return np.trace(rho_g)
        
    def character_table(self):
        """ç‰¹å¾æ ‡è¡¨"""
        character_table = {}
        
        # å¯¹æ¯ä¸ªå…±è½­ç±»
        for conjugacy_class in self.representation.lie_algebra.conjugacy_classes():
            # è®¡ç®—è¯¥å…±è½­ç±»çš„ç‰¹å¾æ ‡
            representative = conjugacy_class[0]
            character_value = self.character_function(representative)
            character_table[conjugacy_class] = character_value
            
        return character_table
```

### 4.2 ç‰¹å¾æ ‡çš„æ€§è´¨

ç‰¹å¾æ ‡å…·æœ‰é‡è¦çš„æ€§è´¨ï¼š

```python
class CharacterProperties:
    """ç‰¹å¾æ ‡æ€§è´¨"""
    
    def __init__(self):
        pass
        
    def character_of_direct_sum(self, rep1, rep2):
        """ç›´å’Œè¡¨ç¤ºçš„ç‰¹å¾æ ‡"""
        char1 = Character(rep1)
        char2 = Character(rep2)
        
        def direct_sum_character(g):
            return char1.character_function(g) + char2.character_function(g)
        return direct_sum_character
        
    def character_of_tensor_product(self, rep1, rep2):
        """å¼ é‡ç§¯è¡¨ç¤ºçš„ç‰¹å¾æ ‡"""
        char1 = Character(rep1)
        char2 = Character(rep2)
        
        def tensor_character(g):
            return char1.character_function(g) * char2.character_function(g)
        return tensor_character
```

## 5. æä»£æ•°è¡¨ç¤ºçš„åˆ†ç±»

### 5.1 åŠå•æä»£æ•°çš„è¡¨ç¤º

åŠå•æä»£æ•°çš„è¡¨ç¤ºç†è®ºï¼š

```python
class SemisimpleRepresentation:
    """åŠå•æä»£æ•°è¡¨ç¤º"""
    
    def __init__(self, semisimple_lie_algebra):
        self.lie_algebra = semisimple_lie_algebra
        
    def weyl_character_formula(self, highest_weight):
        """Weylç‰¹å¾æ ‡å…¬å¼"""
        # Ï‡(Î») = Î£_{wâˆˆW} Îµ(w) e^{w(Î»+Ï)-Ï} / Î _{Î±>0} (1-e^{-Î±})
        
        weyl_group = self.weyl_group()
        positive_roots = self.positive_roots()
        rho = self.rho()
        
        numerator = 0
        for w in weyl_group:
            sign = self.weyl_sign(w)
            weight = w(highest_weight + rho) - rho
            numerator += sign * self.exponential_weight(weight)
            
        denominator = 1
        for alpha in positive_roots:
            denominator *= (1 - self.exponential_weight(-alpha))
            
        return numerator / denominator
```

### 5.2 å¯è§£æä»£æ•°çš„è¡¨ç¤º

å¯è§£æä»£æ•°çš„è¡¨ç¤ºç†è®ºï¼š

```python
class SolvableRepresentation:
    """å¯è§£æä»£æ•°è¡¨ç¤º"""
    
    def __init__(self, solvable_lie_algebra):
        self.lie_algebra = solvable_lie_algebra
        
    def lie_theorem(self, representation):
        """Lieå®šç†"""
        # å¯è§£æä»£æ•°çš„ä»»ä½•æœ‰é™ç»´è¡¨ç¤ºéƒ½æœ‰å…±åŒçš„ç‰¹å¾å‘é‡
        
        # å¯»æ‰¾å…±åŒçš„ç‰¹å¾å‘é‡
        common_eigenvector = self.find_common_eigenvector(representation)
        
        if common_eigenvector is not None:
            return "å­˜åœ¨å…±åŒç‰¹å¾å‘é‡"
        else:
            return "ä¸å­˜åœ¨å…±åŒç‰¹å¾å‘é‡"
```

## 6. Pythonå®ç°

### 6.1 è¡¨ç¤ºè®ºè®¡ç®—åº“

```python
import numpy as np
from abc import ABC, abstractmethod
from typing import List, Tuple, Optional, Union, Dict
from dataclasses import dataclass

class LieAlgebraRepresentation(ABC):
    """æŠ½è±¡æä»£æ•°è¡¨ç¤ºç±»"""
    
    @abstractmethod
    def representation_map(self, X):
        """è¡¨ç¤ºæ˜ å°„"""
        pass
        
    @abstractmethod
    def dimension(self):
        """è¡¨ç¤ºç»´æ•°"""
        pass

class MatrixRepresentation(LieAlgebraRepresentation):
    """çŸ©é˜µè¡¨ç¤º"""
    
    def __init__(self, lie_algebra, dimension):
        self.lie_algebra = lie_algebra
        self.dimension = dimension
        self.matrix_map = {}
        
    def representation_map(self, X):
        """çŸ©é˜µè¡¨ç¤ºæ˜ å°„"""
        if X in self.matrix_map:
            return self.matrix_map[X]
        else:
            # è®¡ç®—Xçš„è¡¨ç¤ºçŸ©é˜µ
            matrix = self.compute_representation_matrix(X)
            self.matrix_map[X] = matrix
            return matrix
            
    def is_irreducible(self):
        """åˆ¤æ–­æ˜¯å¦ä¸å¯çº¦"""
        # æ£€æŸ¥æ˜¯å¦æœ‰éå¹³å‡¡çš„ä¸å˜å­ç©ºé—´
        invariant_subspaces = self.find_invariant_subspaces()
        return len(invariant_subspaces) <= 1

class AdjointRepresentation(MatrixRepresentation):
    """ä¼´éšè¡¨ç¤º"""
    
    def __init__(self, lie_algebra):
        super().__init__(lie_algebra, lie_algebra.dimension)
        
    def compute_representation_matrix(self, X):
        """è®¡ç®—ä¼´éšè¡¨ç¤ºçŸ©é˜µ"""
        # ad(X)(Y) = [X, Y]
        matrix = np.zeros((self.dimension, self.dimension))
        
        for i, basis_element in enumerate(self.lie_algebra.basis()):
            bracket = self.lie_algebra.bracket(X, basis_element)
            # å°†bracketå±•å¼€ä¸ºåŸºçš„çº¿æ€§ç»„åˆ
            coefficients = self.lie_algebra.expand_in_basis(bracket)
            matrix[:, i] = coefficients
            
        return matrix

class CharacterCalculator:
    """ç‰¹å¾æ ‡è®¡ç®—å™¨"""
    
    def __init__(self, representation):
        self.representation = representation
        
    def character(self, X):
        """è®¡ç®—ç‰¹å¾æ ‡"""
        matrix = self.representation.representation_map(X)
        return np.trace(matrix)
        
    def character_table(self):
        """è®¡ç®—ç‰¹å¾æ ‡è¡¨"""
        table = {}
        
        for X in self.representation.lie_algebra.basis():
            char_value = self.character(X)
            table[X] = char_value
            
        return table

class HighestWeightModule:
    """æœ€é«˜æƒæ¨¡"""
    
    def __init__(self, lie_algebra, highest_weight):
        self.lie_algebra = lie_algebra
        self.highest_weight = highest_weight
        self.module = self.construct_module()
        
    def construct_module(self):
        """æ„é€ æœ€é«˜æƒæ¨¡"""
        module = [self.highest_weight]
        current_level = [self.highest_weight]
        
        while current_level:
            next_level = []
            for vector in current_level:
                # é€šè¿‡è´Ÿæ ¹çš„ä½œç”¨ç”Ÿæˆä¸‹ä¸€å±‚
                for negative_root in self.negative_roots():
                    new_vector = self.lie_algebra.action(negative_root, vector)
                    if new_vector is not None and new_vector not in module:
                        module.append(new_vector)
                        next_level.append(new_vector)
            current_level = next_level
            
        return module

# åº”ç”¨ç¤ºä¾‹
def main():
    """ä¸»å‡½æ•°"""
    
    # åˆ›å»ºæä»£æ•°
    lie_algebra = so3Algebra()
    
    # ä¼´éšè¡¨ç¤º
    adjoint_rep = AdjointRepresentation(lie_algebra)
    print(f"ä¼´éšè¡¨ç¤ºç»´æ•°: {adjoint_rep.dimension}")
    
    # æ£€æŸ¥æ˜¯å¦ä¸å¯çº¦
    is_irr = adjoint_rep.is_irreducible()
    print(f"ä¼´éšè¡¨ç¤ºæ˜¯å¦ä¸å¯çº¦: {is_irr}")
    
    # ç‰¹å¾æ ‡è®¡ç®—
    char_calc = CharacterCalculator(adjoint_rep)
    char_table = char_calc.character_table()
    print("ç‰¹å¾æ ‡è¡¨:")
    for X, char_value in char_table.items():
        print(f"Ï‡({X}) = {char_value}")
    
    # æœ€é«˜æƒæ¨¡
    highest_weight = np.array([1, 0, 0])  # ç¤ºä¾‹æœ€é«˜æƒ
    hw_module = HighestWeightModule(lie_algebra, highest_weight)
    print(f"æœ€é«˜æƒæ¨¡çš„ç»´æ•°: {len(hw_module.module)}")

if __name__ == "__main__":
    main()
```

## 7. Lean4å½¢å¼åŒ–éªŒè¯

### 7.1 è¡¨ç¤ºè®ºçš„å½¢å¼åŒ–

```lean
-- æä»£æ•°è¡¨ç¤ºçš„å®šä¹‰
class LieAlgebraRepresentation (ğ”¤ : Type*) [LieAlgebra ğ”¤] (V : Type*) [VectorSpace V] where
  representation_map : ğ”¤ â†’ Endomorphism V
  
  -- è¡¨ç¤ºçš„å…¬ç†
  representation_linear : âˆ€ a b : ğ”¤, representation_map (a + b) = representation_map a + representation_map b
  representation_bracket : âˆ€ a b : ğ”¤, representation_map [a, b] = [representation_map a, representation_map b]

-- ä¸å¯çº¦è¡¨ç¤º
def IrreducibleRepresentation (ğ”¤ : Type*) [LieAlgebra ğ”¤] (V : Type*) [VectorSpace V] [LieAlgebraRepresentation ğ”¤ V] : Prop :=
  âˆ€ (W : Subspace V), InvariantSubspace W â†’ W = âŠ¥ âˆ¨ W = âŠ¤

-- ä¸å˜å­ç©ºé—´
def InvariantSubspace {ğ”¤ : Type*} [LieAlgebra ğ”¤] {V : Type*} [VectorSpace V] [LieAlgebraRepresentation ğ”¤ V] (W : Subspace V) : Prop :=
  âˆ€ (X : ğ”¤) (w : W), representation_map X w âˆˆ W

-- èˆ’å°”å¼•ç†
theorem schur_lemma {ğ”¤ : Type*} [LieAlgebra ğ”¤] {Vâ‚ Vâ‚‚ : Type*} [VectorSpace Vâ‚] [VectorSpace Vâ‚‚]
  [LieAlgebraRepresentation ğ”¤ Vâ‚] [LieAlgebraRepresentation ğ”¤ Vâ‚‚]
  (hâ‚ : IrreducibleRepresentation ğ”¤ Vâ‚) (hâ‚‚ : IrreducibleRepresentation ğ”¤ Vâ‚‚)
  (T : Vâ‚ â†’ Vâ‚‚) (hT : Intertwiner T) :
  T = 0 âˆ¨ (Vâ‚ â‰… Vâ‚‚ âˆ§ âˆƒ c : â„, T = c â€¢ id) := by
  -- èˆ’å°”å¼•ç†çš„è¯æ˜
  sorry

-- ç‰¹å¾æ ‡
def Character {ğ”¤ : Type*} [LieAlgebra ğ”¤] {V : Type*} [VectorSpace V] [LieAlgebraRepresentation ğ”¤ V] : ğ”¤ â†’ â„ :=
  Î» X => trace (representation_map X)

-- ç‰¹å¾æ ‡çš„æ€§è´¨
theorem character_additive {ğ”¤ : Type*} [LieAlgebra ğ”¤] {Vâ‚ Vâ‚‚ : Type*} [VectorSpace Vâ‚] [VectorSpace Vâ‚‚]
  [LieAlgebraRepresentation ğ”¤ Vâ‚] [LieAlgebraRepresentation ğ”¤ Vâ‚‚] :
  Character (Vâ‚ âŠ• Vâ‚‚) = Character Vâ‚ + Character Vâ‚‚ := by
  sorry

theorem character_multiplicative {ğ”¤ : Type*} [LieAlgebra ğ”¤] {Vâ‚ Vâ‚‚ : Type*} [VectorSpace Vâ‚] [VectorSpace Vâ‚‚]
  [LieAlgebraRepresentation ğ”¤ Vâ‚] [LieAlgebraRepresentation ğ”¤ Vâ‚‚] :
  Character (Vâ‚ âŠ— Vâ‚‚) = Character Vâ‚ * Character Vâ‚‚ := by
  sorry

-- æœ€é«˜æƒè¡¨ç¤º
def HighestWeightVector {ğ”¤ : Type*} [LieAlgebra ğ”¤] {V : Type*} [VectorSpace V] [LieAlgebraRepresentation ğ”¤ V]
  (ğ”¥ : Subalgebra ğ”¤) (v : V) : Prop :=
  âˆ€ H : ğ”¥, representation_map H v = weight H â€¢ v âˆ§
  âˆ€ X : ğ”¤, PositiveRoot X â†’ representation_map X v = 0

-- Weylç‰¹å¾æ ‡å…¬å¼
theorem weyl_character_formula {ğ”¤ : Type*} [SemisimpleLieAlgebra ğ”¤] {V : Type*} [VectorSpace V]
  [HighestWeightRepresentation ğ”¤ V] (Î» : Weight) :
  Character V = (âˆ‘ w : WeylGroup, sign w â€¢ exp (w â€¢ (Î» + Ï) - Ï)) / 
                (âˆ Î± : PositiveRoot, (1 - exp (-Î±))) := by
  -- Weylç‰¹å¾æ ‡å…¬å¼çš„è¯æ˜
  sorry

-- ç‰¹å¾æ ‡çš„æ­£äº¤å…³ç³»
theorem character_orthogonality {ğ”¤ : Type*} [LieAlgebra ğ”¤] {Vâ‚ Vâ‚‚ : Type*} [VectorSpace Vâ‚] [VectorSpace Vâ‚‚]
  [IrreducibleRepresentation ğ”¤ Vâ‚] [IrreducibleRepresentation ğ”¤ Vâ‚‚] :
  âˆ« Ï‡â‚(g) Ï‡â‚‚(gâ»Â¹) dg = if Vâ‚ â‰… Vâ‚‚ then 1 else 0 := by
  -- ç‰¹å¾æ ‡æ­£äº¤å…³ç³»çš„è¯æ˜
  sorry

-- è¡¨ç¤ºçš„åˆ†ç±»
theorem classification_finite_dimensional {ğ”¤ : Type*} [SemisimpleLieAlgebra ğ”¤] :
  âˆ€ V : FiniteDimensionalRepresentation ğ”¤, 
  âˆƒ Î» : DominantWeight, V â‰… HighestWeightModule Î» := by
  -- æœ‰é™ç»´è¡¨ç¤ºåˆ†ç±»å®šç†çš„è¯æ˜
  sorry

-- è¡¨ç¤ºçš„åˆ†è§£
theorem complete_reducibility {ğ”¤ : Type*} [SemisimpleLieAlgebra ğ”¤] {V : Type*} [VectorSpace V]
  [LieAlgebraRepresentation ğ”¤ V] :
  V â‰… âŠ•áµ¢ Váµ¢ where Váµ¢ are irreducible := by
  -- å®Œå…¨å¯çº¦æ€§å®šç†çš„è¯æ˜
  sorry
```

## 8. åº”ç”¨æ¡ˆä¾‹

### 8.1 SU(2)çš„è¡¨ç¤º

```python
def su2_representations():
    """SU(2)çš„è¡¨ç¤º"""
    
    # SU(2)çš„æä»£æ•°su(2)
    su2 = SU2Algebra()
    
    # è‡ªæ—‹1/2è¡¨ç¤ºï¼ˆåŸºæœ¬è¡¨ç¤ºï¼‰
    spin_half_rep = SpinHalfRepresentation(su2)
    print(f"è‡ªæ—‹1/2è¡¨ç¤ºç»´æ•°: {spin_half_rep.dimension}")
    
    # è‡ªæ—‹1è¡¨ç¤ºï¼ˆä¼´éšè¡¨ç¤ºï¼‰
    spin_one_rep = AdjointRepresentation(su2)
    print(f"è‡ªæ—‹1è¡¨ç¤ºç»´æ•°: {spin_one_rep.dimension}")
    
    # ç‰¹å¾æ ‡è®¡ç®—
    char_calc = CharacterCalculator(spin_one_rep)
    char_table = char_calc.character_table()
    
    print("SU(2)è‡ªæ—‹1è¡¨ç¤ºçš„ç‰¹å¾æ ‡:")
    for X, char_value in char_table.items():
        print(f"Ï‡({X}) = {char_value}")
    
    return spin_half_rep, spin_one_rep
```

### 8.2 SU(3)çš„è¡¨ç¤º

```python
def su3_representations():
    """SU(3)çš„è¡¨ç¤º"""
    
    # SU(3)çš„æä»£æ•°su(3)
    su3 = SU3Algebra()
    
    # åŸºæœ¬è¡¨ç¤ºï¼ˆ3ç»´ï¼‰
    fundamental_rep = FundamentalRepresentation(su3)
    print(f"åŸºæœ¬è¡¨ç¤ºç»´æ•°: {fundamental_rep.dimension}")
    
    # ä¼´éšè¡¨ç¤ºï¼ˆ8ç»´ï¼‰
    adjoint_rep = AdjointRepresentation(su3)
    print(f"ä¼´éšè¡¨ç¤ºç»´æ•°: {adjoint_rep.dimension}")
    
    # å¼ é‡ç§¯è¡¨ç¤º
    tensor_rep = TensorProductRepresentation(fundamental_rep, fundamental_rep)
    print(f"å¼ é‡ç§¯è¡¨ç¤ºç»´æ•°: {tensor_rep.dimension}")
    
    # åˆ†è§£ä¸ºä¸å¯çº¦è¡¨ç¤º
    irreducible_components = tensor_rep.decompose()
    print("å¼ é‡ç§¯çš„ä¸å¯çº¦åˆ†è§£:")
    for component in irreducible_components:
        print(f"  - {component.dimension}ç»´è¡¨ç¤º")
    
    return fundamental_rep, adjoint_rep, tensor_rep
```

### 8.3 æä»£æ•°è¡¨ç¤ºåœ¨ç‰©ç†ä¸­çš„åº”ç”¨

```python
def physics_applications():
    """ç‰©ç†ä¸­çš„åº”ç”¨"""
    
    # è§’åŠ¨é‡è¡¨ç¤º
    angular_momentum = AngularMomentumAlgebra(1)
    
    # ä¸åŒè‡ªæ—‹çš„è¡¨ç¤º
    spin_representations = {}
    for s in [0.5, 1, 1.5, 2]:
        rep = SpinRepresentation(angular_momentum, s)
        spin_representations[s] = rep
        print(f"è‡ªæ—‹{s}è¡¨ç¤ºç»´æ•°: {rep.dimension}")
    
    # è§’åŠ¨é‡è€¦åˆ
    spin1_rep = spin_representations[1]
    spin2_rep = spin_representations[1]
    coupled_rep = CoupledRepresentation(spin1_rep, spin2_rep)
    
    print(f"è‡ªæ—‹1âŠ—è‡ªæ—‹1è€¦åˆè¡¨ç¤ºç»´æ•°: {coupled_rep.dimension}")
    
    # Clebsch-Gordanç³»æ•°
    cg_coefficients = coupled_rep.clebsch_gordan_coefficients()
    print("Clebsch-Gordanç³»æ•°:")
    for (j1, m1, j2, m2, j, m), coefficient in cg_coefficients.items():
        print(f"  C({j1},{m1},{j2},{m2},{j},{m}) = {coefficient}")
    
    return spin_representations, coupled_rep
```

## 9. æ€»ç»“

æä»£æ•°è¡¨ç¤ºè®ºæ˜¯è¿æ¥ä»£æ•°å’Œå‡ ä½•çš„é‡è¦æ¡¥æ¢ï¼š

### æ ¸å¿ƒè´¡çŒ®

1. **ç»“æ„ç†è§£**ï¼šé€šè¿‡è¡¨ç¤ºè®ºæ·±å…¥ç†è§£æä»£æ•°çš„ç»“æ„
2. **åˆ†ç±»ç†è®º**ï¼šä¸ºæä»£æ•°è¡¨ç¤ºæä¾›å®Œæ•´çš„åˆ†ç±»
3. **è®¡ç®—å·¥å…·**ï¼šæä¾›è®¡ç®—è¡¨ç¤ºç‰¹å¾æ ‡å’Œæƒé‡çš„å·¥å…·
4. **ç‰©ç†åº”ç”¨**ï¼šåœ¨é‡å­åŠ›å­¦å’Œç²’å­ç‰©ç†ä¸­çš„å¹¿æ³›åº”ç”¨

### æŠ€æœ¯ç‰¹è‰²

1. **å½¢å¼åŒ–éªŒè¯**ï¼šé€šè¿‡Lean4ç¡®ä¿è¡¨ç¤ºè®ºç†è®ºçš„ä¸¥è°¨æ€§
2. **ç®—æ³•å®ç°**ï¼šPythonå®ç°æä¾›äº†è¡¨ç¤ºè®¡ç®—çš„å·¥å…·
3. **åº”ç”¨å¹¿æ³›**ï¼šä»çº¯æ•°å­¦åˆ°ç†è®ºç‰©ç†çš„å¹¿æ³›åº”ç”¨
4. **ç†è®ºæ·±åº¦**ï¼šè¿æ¥ä»£æ•°ã€å‡ ä½•å’Œåˆ†æçš„æ·±åˆ»ç†è®º

### æœªæ¥å±•æœ›

1. **æ— é™ç»´è¡¨ç¤º**ï¼šæ¢ç´¢æ— é™ç»´æä»£æ•°çš„è¡¨ç¤ºç†è®º
2. **é‡å­ç¾¤è¡¨ç¤º**ï¼šé‡å­ç¾¤è¡¨ç¤ºè®ºçš„å‘å±•
3. **å‡ ä½•è¡¨ç¤º**ï¼šè¡¨ç¤ºè®ºåœ¨å‡ ä½•ä¸­çš„åº”ç”¨
4. **è®¡ç®—è¡¨ç¤º**ï¼šè¡¨ç¤ºè®ºåœ¨è®¡ç®—æœºç§‘å­¦ä¸­çš„åº”ç”¨

æä»£æ•°è¡¨ç¤ºè®ºå°†ç»§ç»­ä¸ºç°ä»£æ•°å­¦å’Œç‰©ç†å­¦çš„å‘å±•æä¾›é‡è¦çš„ç†è®ºå·¥å…·å’Œè®¡ç®—æ¡†æ¶ã€‚
