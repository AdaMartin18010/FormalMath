# ç¯è®ºåº”ç”¨-ä»£æ•°ç¼–ç ç‰ˆ - å›½é™…æ ‡å‡†ç‰ˆ

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†é˜è¿°ç¯è®ºåœ¨ä»£æ•°ç¼–ç ç†è®ºä¸­çš„æ ¸å¿ƒåº”ç”¨ï¼ŒåŒ…æ‹¬çº¿æ€§ç ã€å¾ªç¯ç ã€BCHç ã€Reed-Solomonç ã€ä»£æ•°å‡ ä½•ç ç­‰ã€‚ç¯è®ºä¸ºç¼–ç ç†è®ºæä¾›äº†å¼ºå¤§çš„ä»£æ•°å·¥å…·ï¼Œä½¿å¾—æˆ‘ä»¬èƒ½å¤Ÿæ„é€ é«˜æ•ˆçš„çº é”™ç ã€‚

## 1. çº¿æ€§ç åŸºç¡€

### 1.1 çº¿æ€§ç çš„å®šä¹‰

**å®šä¹‰**: çº¿æ€§ç æ˜¯å‘é‡ç©ºé—´ğ”½_q^nçš„kç»´å­ç©ºé—´ï¼Œå…¶ä¸­ğ”½_qæ˜¯qå…ƒæœ‰é™åŸŸã€‚

```python
import numpy as np
from typing import List, Tuple, Optional
import random

class LinearCode:
    """çº¿æ€§ç ç±»"""
    
    def __init__(self, generator_matrix: List[List[int]], field_size: int):
        self.G = np.array(generator_matrix, dtype=int)
        self.q = field_size
        self.n = self.G.shape[1]  # ç é•¿
        self.k = self.G.shape[0]  # ä¿¡æ¯ä½é•¿åº¦
        self.d = self._compute_minimum_distance()
    
    def _compute_minimum_distance(self) -> int:
        """è®¡ç®—æœ€å°è·ç¦»"""
        # ç®€åŒ–å®ç°ï¼šè®¡ç®—æ‰€æœ‰éé›¶ç å­—çš„æœ€å°é‡é‡
        min_weight = float('inf')
        
        # æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„éé›¶ä¿¡æ¯å‘é‡
        for i in range(1, 2**self.k):
            info_vector = self._int_to_binary(i, self.k)
            codeword = self.encode(info_vector)
            weight = self._hamming_weight(codeword)
            if weight > 0:
                min_weight = min(min_weight, weight)
        
        return min_weight if min_weight != float('inf') else 0
    
    def _int_to_binary(self, num: int, length: int) -> List[int]:
        """å°†æ•´æ•°è½¬æ¢ä¸ºäºŒè¿›åˆ¶å‘é‡"""
        binary = []
        for _ in range(length):
            binary.append(num % 2)
            num //= 2
        return binary
    
    def _hamming_weight(self, vector: List[int]) -> int:
        """è®¡ç®—æ±‰æ˜é‡é‡"""
        return sum(1 for x in vector if x != 0)
    
    def encode(self, message: List[int]) -> List[int]:
        """ç¼–ç """
        if len(message) != self.k:
            raise ValueError(f"æ¶ˆæ¯é•¿åº¦å¿…é¡»ä¸º{self.k}")
        
        # è®¡ç®— c = mG
        codeword = (np.array(message) @ self.G) % self.q
        return codeword.tolist()
    
    def decode(self, received: List[int]) -> List[int]:
        """è§£ç ï¼ˆç®€åŒ–å®ç°ï¼‰"""
        # ä½¿ç”¨æœ€è¿‘é‚»è§£ç 
        min_distance = float('inf')
        best_message = None
        
        # å°è¯•æ‰€æœ‰å¯èƒ½çš„ç å­—
        for i in range(2**self.k):
            message = self._int_to_binary(i, self.k)
            codeword = self.encode(message)
            distance = self._hamming_distance(received, codeword)
            
            if distance < min_distance:
                min_distance = distance
                best_message = message
        
        return best_message
    
    def _hamming_distance(self, v1: List[int], v2: List[int]) -> int:
        """è®¡ç®—æ±‰æ˜è·ç¦»"""
        return sum(1 for x, y in zip(v1, v2) if x != y)
    
    def parity_check_matrix(self) -> np.ndarray:
        """è®¡ç®—æ ¡éªŒçŸ©é˜µ"""
        # ä½¿ç”¨æ ‡å‡†å½¢å¼ G = [I_k | A]ï¼Œåˆ™ H = [-A^T | I_{n-k}]
        if self.G.shape[0] == self.G.shape[1]:
            # å¦‚æœä¸æ˜¯æ ‡å‡†å½¢å¼ï¼Œéœ€è¦è½¬æ¢
            return np.eye(self.n - self.k)
        
        # å‡è®¾Gå·²ç»æ˜¯æ ‡å‡†å½¢å¼
        A = self.G[:, self.k:]
        H = np.hstack([-A.T % self.q, np.eye(self.n - self.k)])
        return H

def create_hamming_code(r: int) -> LinearCode:
    """åˆ›å»ºæ±‰æ˜ç """
    # æ±‰æ˜ç çš„å‚æ•°ï¼šn = 2^r - 1, k = 2^r - r - 1, d = 3
    n = 2**r - 1
    k = 2**r - r - 1
    
    # æ„é€ æ ¡éªŒçŸ©é˜µH
    H = []
    for i in range(1, n + 1):
        row = []
        for j in range(r):
            row.append((i >> j) & 1)
        H.append(row)
    H = np.array(H).T
    
    # æ„é€ ç”ŸæˆçŸ©é˜µG
    # ä½¿ç”¨ç³»ç»Ÿå½¢å¼ï¼šG = [I_k | A]
    I_k = np.eye(k)
    A = np.random.randint(0, 2, (k, n - k))  # ç®€åŒ–å®ç°
    
    G = np.hstack([I_k, A])
    
    return LinearCode(G.tolist(), 2)
```

### 1.2 å¾ªç¯ç 

**å®šä¹‰**: å¾ªç¯ç æ˜¯çº¿æ€§ç çš„å­ç±»ï¼Œå…·æœ‰å¾ªç¯ç§»ä½ä¸å˜æ€§ã€‚

```python
class CyclicCode:
    """å¾ªç¯ç ç±»"""
    
    def __init__(self, generator_polynomial: List[int], field_size: int):
        self.g = generator_polynomial
        self.q = field_size
        self.n = len(generator_polynomial) - 1  # ç é•¿
        self.k = self._compute_dimension()
    
    def _compute_dimension(self) -> int:
        """è®¡ç®—ç çš„ç»´æ•°"""
        # k = n - deg(g)
        return self.n - (len(self.g) - 1)
    
    def encode(self, message: List[int]) -> List[int]:
        """ç¼–ç """
        if len(message) != self.k:
            raise ValueError(f"æ¶ˆæ¯é•¿åº¦å¿…é¡»ä¸º{self.k}")
        
        # è®¡ç®— c(x) = m(x) * g(x)
        codeword = self._polynomial_multiplication(message, self.g)
        
        # å–æ¨¡x^n - 1
        codeword = codeword[:self.n]
        while len(codeword) < self.n:
            codeword.append(0)
        
        return codeword
    
    def decode(self, received: List[int]) -> List[int]:
        """è§£ç """
        # ä½¿ç”¨Berlekamp-Masseyç®—æ³•æˆ–æ¬§å‡ é‡Œå¾—ç®—æ³•
        # è¿™é‡Œä½¿ç”¨ç®€åŒ–å®ç°
        syndrome = self._compute_syndrome(received)
        
        if all(s == 0 for s in syndrome):
            # æ— é”™è¯¯
            return self._extract_message(received)
        else:
            # æœ‰é”™è¯¯ï¼Œéœ€è¦çº é”™
            return self._error_correction(received, syndrome)
    
    def _polynomial_multiplication(self, p1: List[int], p2: List[int]) -> List[int]:
        """å¤šé¡¹å¼ä¹˜æ³•"""
        result = [0] * (len(p1) + len(p2) - 1)
        
        for i, a in enumerate(p1):
            for j, b in enumerate(p2):
                result[i + j] = (result[i + j] + a * b) % self.q
        
        return result
    
    def _compute_syndrome(self, received: List[int]) -> List[int]:
        """è®¡ç®—ç—‡çŠ¶"""
        # è®¡ç®— r(x) mod g(x)
        syndrome = received.copy()
        
        for i in range(len(received) - len(self.g) + 1):
            if syndrome[i] != 0:
                for j, coeff in enumerate(self.g):
                    if coeff != 0:
                        syndrome[i + j] = (syndrome[i + j] - syndrome[i] * coeff) % self.q
        
        return syndrome[-len(self.g) + 1:]
    
    def _extract_message(self, codeword: List[int]) -> List[int]:
        """ä»ç å­—ä¸­æå–æ¶ˆæ¯"""
        # å‡è®¾ä½¿ç”¨ç³»ç»Ÿç¼–ç 
        return codeword[:self.k]
    
    def _error_correction(self, received: List[int], syndrome: List[int]) -> List[int]:
        """é”™è¯¯çº æ­£ï¼ˆç®€åŒ–å®ç°ï¼‰"""
        # å®é™…åº”ç”¨ä¸­éœ€è¦æ›´å¤æ‚çš„ç®—æ³•
        return received[:self.k]

def create_bch_code(n: int, t: int, field_size: int) -> CyclicCode:
    """åˆ›å»ºBCHç """
    # BCHç çš„å‚æ•°ï¼šçº é”™èƒ½åŠ›ä¸ºt
    # ç”Ÿæˆå¤šé¡¹å¼æ˜¯tä¸ªè¿ç»­æ ¹çš„æœ€å°å…¬å€å¼
    
    # ç®€åŒ–å®ç°ï¼šä½¿ç”¨å›ºå®šçš„ç”Ÿæˆå¤šé¡¹å¼
    if n == 7 and t == 1:
        # (7,4) BCHç 
        generator = [1, 1, 0, 1]  # x^3 + x^2 + 1
    elif n == 15 and t == 2:
        # (15,7) BCHç 
        generator = [1, 0, 0, 0, 1, 1, 1, 0, 1]  # x^8 + x^4 + x^3 + x^2 + 1
    else:
        # é»˜è®¤ç”Ÿæˆå¤šé¡¹å¼
        generator = [1] + [0] * (2 * t) + [1]
    
    return CyclicCode(generator, field_size)
```
