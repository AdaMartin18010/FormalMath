# 线性代数与矩阵理论 - 国际标准深度扩展版

## 概述

本文档基于国际Wiki标准和2025年国际著名大学数学课程，全面阐述线性代数与矩阵理论的核心概念、严格证明和现代应用。

## 1. 向量空间理论

### 1.1 向量空间的公理化定义

**定义 1.1** (向量空间)
设 $F$ 是一个域，$V$ 是一个集合，向量空间是一个有序四元组 $(V, F, +, \cdot)$，其中：

1. **加法群**: $(V, +)$ 构成阿贝尔群
2. **标量乘法**: $\cdot: F \times V \rightarrow V$
3. **分配律**: $\forall a \in F \forall v, w \in V(a \cdot (v + w) = a \cdot v + a \cdot w)$
4. **结合律**: $\forall a, b \in F \forall v \in V((a \cdot b) \cdot v = a \cdot (b \cdot v))$
5. **单位元**: $\forall v \in V(1 \cdot v = v)$

**定理 1.1** (向量空间的基本性质)
设 $V$ 是域 $F$ 上的向量空间，则：

1. $0 \cdot v = 0$ 对所有 $v \in V$ 成立
2. $a \cdot 0 = 0$ 对所有 $a \in F$ 成立
3. $(-a) \cdot v = -(a \cdot v)$ 对所有 $a \in F, v \in V$ 成立

### 1.2 线性无关与基

**定义 1.2** (线性无关)
向量组 $\{v_1, v_2, \ldots, v_n\}$ 称为线性无关，如果方程
$$\sum_{i=1}^n a_i v_i = 0$$
只有平凡解 $a_1 = a_2 = \cdots = a_n = 0$。

**定义 1.3** (基)
向量空间 $V$ 的基是 $V$ 的线性无关生成集。

**定理 1.2** (基的存在性与唯一性)
每个有限维向量空间都有基，且所有基的向量个数相同。

## 2. 矩阵理论

### 2.1 矩阵的基本概念

**定义 2.1** (矩阵)
设 $F$ 是一个域，$m, n \in \mathbb{N}$，$m \times n$ 矩阵是函数 $A: \{1,2,\ldots,m\} \times \{1,2,\ldots,n\} \rightarrow F$。

**矩阵运算**:

```python
import numpy as np
from typing import List, Tuple, Optional

class Matrix:
    """矩阵类 - 基于国际标准的实现"""
    
    def __init__(self, data: List[List[float]], field: str = "R"):
        self.data = np.array(data, dtype=float)
        self.rows, self.cols = self.data.shape
        self.field = field
        
    def __add__(self, other: 'Matrix') -> 'Matrix':
        """矩阵加法"""
        if self.rows != other.rows or self.cols != other.cols:
            raise ValueError("矩阵维度不匹配")
        return Matrix((self.data + other.data).tolist(), self.field)
    
    def __mul__(self, other: 'Matrix') -> 'Matrix':
        """矩阵乘法"""
        if self.cols != other.rows:
            raise ValueError("矩阵维度不匹配")
        return Matrix((self.data @ other.data).tolist(), self.field)
    
    def transpose(self) -> 'Matrix':
        """矩阵转置"""
        return Matrix(self.data.T.tolist(), self.field)
    
    def determinant(self) -> float:
        """行列式"""
        if self.rows != self.cols:
            raise ValueError("只有方阵才有行列式")
        return np.linalg.det(self.data)
    
    def rank(self) -> int:
        """矩阵秩"""
        return np.linalg.matrix_rank(self.data)
    
    def inverse(self) -> Optional['Matrix']:
        """矩阵逆"""
        if self.rows != self.cols:
            raise ValueError("只有方阵才有逆矩阵")
        try:
            inv_data = np.linalg.inv(self.data)
            return Matrix(inv_data.tolist(), self.field)
        except np.linalg.LinAlgError:
            return None  # 奇异矩阵
    
    def eigenvalues(self) -> np.ndarray:
        """特征值"""
        if self.rows != self.cols:
            raise ValueError("只有方阵才有特征值")
        return np.linalg.eigvals(self.data)
    
    def eigenvectors(self) -> Tuple[np.ndarray, np.ndarray]:
        """特征值和特征向量"""
        if self.rows != self.cols:
            raise ValueError("只有方阵才有特征向量")
        return np.linalg.eig(self.data)
```

### 2.2 矩阵分解理论

**LU分解**:

```python
def lu_decomposition(A: Matrix) -> Tuple[Matrix, Matrix]:
    """LU分解"""
    if A.rows != A.cols:
        raise ValueError("只有方阵才能进行LU分解")
    
    n = A.rows
    L = np.eye(n)
    U = A.data.copy()
    
    for k in range(n-1):
        for i in range(k+1, n):
            if U[k, k] == 0:
                raise ValueError("矩阵不可进行LU分解")
            L[i, k] = U[i, k] / U[k, k]
            U[i, k:] -= L[i, k] * U[k, k:]
    
    return Matrix(L.tolist()), Matrix(U.tolist())

def qr_decomposition(A: Matrix) -> Tuple[Matrix, Matrix]:
    """QR分解"""
    Q, R = np.linalg.qr(A.data)
    return Matrix(Q.tolist()), Matrix(R.tolist())

def svd_decomposition(A: Matrix) -> Tuple[Matrix, np.ndarray, Matrix]:
    """奇异值分解"""
    U, s, Vt = np.linalg.svd(A.data)
    return Matrix(U.tolist()), s, Matrix(Vt.tolist())
```

### 2.3 矩阵的数值性质

**定理 2.1** (矩阵范数)
设 $A$ 是 $m \times n$ 矩阵，则：

1. **Frobenius范数**: $\|A\|_F = \sqrt{\sum_{i=1}^m \sum_{j=1}^n |a_{ij}|^2}$
2. **算子范数**: $\|A\|_2 = \max_{\|x\|_2 = 1} \|Ax\|_2$
3. **1-范数**: $\|A\|_1 = \max_j \sum_{i=1}^m |a_{ij}|$
4. **∞-范数**: $\|A\|_\infty = \max_i \sum_{j=1}^n |a_{ij}|$

**条件数**:

```python
def condition_number(A: Matrix, norm_type: str = "2") -> float:
    """计算矩阵条件数"""
    if A.rows != A.cols:
        raise ValueError("只有方阵才有条件数")
    
    if norm_type == "2":
        return np.linalg.cond(A.data, 2)
    elif norm_type == "1":
        return np.linalg.cond(A.data, 1)
    elif norm_type == "inf":
        return np.linalg.cond(A.data, np.inf)
    else:
        raise ValueError("不支持的范数类型")
```

## 3. 线性变换理论

### 3.1 线性变换的定义与性质

**定义 3.1** (线性变换)
设 $V$ 和 $W$ 是域 $F$ 上的向量空间，线性变换是函数 $T: V \rightarrow W$ 满足：

1. **加法保持**: $\forall v, w \in V(T(v + w) = T(v) + T(w))$
2. **标量乘法保持**: $\forall a \in F \forall v \in V(T(a \cdot v) = a \cdot T(v))$

**定理 3.1** (线性变换的基本性质)
设 $T: V \rightarrow W$ 是线性变换，则：

1. $T(0) = 0$
2. $T(-v) = -T(v)$ 对所有 $v \in V$ 成立
3. $T(\sum_{i=1}^n a_i v_i) = \sum_{i=1}^n a_i T(v_i)$

### 3.2 核与像

**定义 3.2** (核与像)
设 $T: V \rightarrow W$ 是线性变换：

1. **核**: $\ker(T) = \{v \in V : T(v) = 0\}$
2. **像**: $\operatorname{im}(T) = \{T(v) : v \in V\}$

**定理 3.2** (秩-零化度定理)
设 $T: V \rightarrow W$ 是线性变换，则：
$$\dim(\ker(T)) + \dim(\operatorname{im}(T)) = \dim(V)$$

### 3.3 线性变换的矩阵表示

**定理 3.3** (矩阵表示定理)
设 $T: V \rightarrow W$ 是线性变换，$\mathcal{B}_V = \{v_1, v_2, \ldots, v_n\}$ 是 $V$ 的基，$\mathcal{B}_W = \{w_1, w_2, \ldots, w_m\}$ 是 $W$ 的基，则存在唯一的 $m \times n$ 矩阵 $A$ 使得：
$$[T(v)]_{\mathcal{B}_W} = A[v]_{\mathcal{B}_V}$$

## 4. 特征值与特征向量

### 4.1 特征值与特征向量的定义

**定义 4.1** (特征值与特征向量)
设 $T: V \rightarrow V$ 是线性变换，如果存在非零向量 $v \in V$ 和标量 $\lambda \in F$ 使得：
$$T(v) = \lambda v$$
则称 $\lambda$ 是 $T$ 的特征值，$v$ 是 $T$ 的对应于 $\lambda$ 的特征向量。

**特征多项式**:

```python
def characteristic_polynomial(A: Matrix) -> np.poly1d:
    """计算特征多项式"""
    if A.rows != A.cols:
        raise ValueError("只有方阵才有特征多项式")
    
    # p(λ) = det(A - λI)
    return np.poly1d(np.poly(A.data))

def algebraic_multiplicity(A: Matrix, eigenvalue: complex) -> int:
    """计算代数重数"""
    char_poly = characteristic_polynomial(A)
    roots = char_poly.roots
    
    # 计算特征值在根中的重数
    count = 0
    for root in roots:
        if abs(root - eigenvalue) < 1e-10:
            count += 1
    
    return count

def geometric_multiplicity(A: Matrix, eigenvalue: complex) -> int:
    """计算几何重数"""
    n = A.rows
    I = np.eye(n)
    
    # 计算 ker(A - λI) 的维数
    eigen_matrix = A.data - eigenvalue * I
    rank = np.linalg.matrix_rank(eigen_matrix)
    
    return n - rank
```

### 4.2 特征值的性质

**定理 4.1** (特征值的基本性质)
设 $A$ 是 $n \times n$ 矩阵，$\lambda_1, \lambda_2, \ldots, \lambda_n$ 是其特征值，则：

1. $\det(A) = \prod_{i=1}^n \lambda_i$
2. $\operatorname{tr}(A) = \sum_{i=1}^n \lambda_i$
3. $A$ 的特征值也是 $A^T$ 的特征值

**定理 4.2** (Cayley-Hamilton定理)
设 $A$ 是 $n \times n$ 矩阵，$p(\lambda)$ 是其特征多项式，则：
$$p(A) = 0$$

## 5. 内积空间与正交性

### 5.1 内积空间的定义

**定义 5.1** (内积空间)
设 $V$ 是域 $F$ 上的向量空间，内积是函数 $\langle \cdot, \cdot \rangle: V \times V \rightarrow F$ 满足：

1. **共轭对称性**: $\langle v, w \rangle = \overline{\langle w, v \rangle}$
2. **线性性**: $\langle av + bw, u \rangle = a\langle v, u \rangle + b\langle w, u \rangle$
3. **正定性**: $\langle v, v \rangle \geq 0$ 且 $\langle v, v \rangle = 0 \Leftrightarrow v = 0$

**范数**:

```python
def inner_product(v: np.ndarray, w: np.ndarray) -> complex:
    """计算内积"""
    return np.dot(v.conj(), w)

def norm(v: np.ndarray) -> float:
    """计算范数"""
    return np.sqrt(np.real(inner_product(v, v)))

def distance(v: np.ndarray, w: np.ndarray) -> float:
    """计算距离"""
    return norm(v - w)

def angle(v: np.ndarray, w: np.ndarray) -> float:
    """计算夹角"""
    cos_angle = np.real(inner_product(v, w)) / (norm(v) * norm(w))
    return np.arccos(np.clip(cos_angle, -1, 1))
```

### 5.2 正交性与Gram-Schmidt正交化

**定义 5.2** (正交性)
向量 $v$ 和 $w$ 称为正交，如果 $\langle v, w \rangle = 0$。

**Gram-Schmidt正交化**:

```python
def gram_schmidt_orthogonalization(vectors: List[np.ndarray]) -> List[np.ndarray]:
    """Gram-Schmidt正交化"""
    n = len(vectors)
    orthogonal_vectors = []
    
    for i in range(n):
        v = vectors[i].copy()
        
        # 减去前面所有正交向量的投影
        for j in range(i):
            proj = inner_product(v, orthogonal_vectors[j]) / inner_product(orthogonal_vectors[j], orthogonal_vectors[j])
            v = v - proj * orthogonal_vectors[j]
        
        # 归一化
        norm_v = norm(v)
        if norm_v > 1e-10:  # 避免零向量
            v = v / norm_v
            orthogonal_vectors.append(v)
    
    return orthogonal_vectors

def qr_decomposition_gram_schmidt(A: Matrix) -> Tuple[Matrix, Matrix]:
    """使用Gram-Schmidt的QR分解"""
    n = A.rows
    m = A.cols
    
    # 提取列向量
    columns = [A.data[:, j] for j in range(m)]
    
    # Gram-Schmidt正交化
    Q_columns = gram_schmidt_orthogonalization(columns)
    
    # 构造Q矩阵
    Q = np.column_stack(Q_columns)
    
    # 计算R矩阵
    R = np.zeros((m, m))
    for i in range(m):
        for j in range(i, m):
            R[i, j] = inner_product(Q[:, i], A.data[:, j])
    
    return Matrix(Q.tolist()), Matrix(R.tolist())
```

## 6. 对角化与Jordan标准形

### 6.1 对角化

**定义 6.1** (对角化)
矩阵 $A$ 称为可对角化，如果存在可逆矩阵 $P$ 使得：
$$P^{-1}AP = D$$
其中 $D$ 是对角矩阵。

**定理 6.1** (对角化条件)
$n \times n$ 矩阵 $A$ 可对角化当且仅当：

1. $A$ 有 $n$ 个线性无关的特征向量
2. 每个特征值的代数重数等于几何重数

```python
def is_diagonalizable(A: Matrix) -> bool:
    """判断矩阵是否可对角化"""
    eigenvalues = A.eigenvalues()
    
    for eigenvalue in eigenvalues:
        alg_mult = algebraic_multiplicity(A, eigenvalue)
        geom_mult = geometric_multiplicity(A, eigenvalue)
        
        if alg_mult != geom_mult:
            return False
    
    return True

def diagonalize(A: Matrix) -> Optional[Tuple[Matrix, Matrix]]:
    """对角化矩阵"""
    if not is_diagonalizable(A):
        return None
    
    eigenvalues, eigenvectors = A.eigenvectors()
    
    # P矩阵是特征向量矩阵
    P = Matrix(eigenvectors.tolist())
    
    # D矩阵是对角矩阵
    D_data = np.diag(eigenvalues)
    D = Matrix(D_data.tolist())
    
    return P, D
```

### 6.2 Jordan标准形

**定义 6.2** (Jordan块)
$k \times k$ Jordan块是形如：
$$J_k(\lambda) = \begin{pmatrix}
\lambda & 1 & 0 & \cdots & 0 \\
0 & \lambda & 1 & \cdots & 0 \\
\vdots & \vdots & \ddots & \ddots & \vdots \\
0 & 0 & 0 & \lambda & 1 \\
0 & 0 & 0 & 0 & \lambda
\end{pmatrix}$$
的矩阵。

**定理 6.2** (Jordan标准形定理)
每个复矩阵都相似于一个Jordan标准形矩阵。

```python
def jordan_canonical_form(A: Matrix) -> Tuple[Matrix, Matrix]:
    """计算Jordan标准形"""
    # 这是一个复杂的算法，需要计算广义特征向量
    eigenvalues, eigenvectors = A.eigenvectors()

    # 构造Jordan矩阵
    J_data = np.zeros_like(A.data, dtype=complex)

    # 这里需要实现完整的Jordan分解算法
    # 包括计算广义特征向量和Jordan链

    J = Matrix(J_data.tolist())
    P = Matrix(eigenvectors.tolist())

    return P, J
```

## 7. 应用与前沿发展

### 7.1 量子计算中的线性代数

**量子比特与量子门**:

```python
import numpy as np
from typing import List, Tuple

class QuantumGate:
    """量子门类"""

    def __init__(self, matrix: np.ndarray):
        self.matrix = matrix
        self.dim = matrix.shape[0]

        # 验证酉性
        if not self.is_unitary():
            raise ValueError("量子门必须是酉矩阵")

    def is_unitary(self) -> bool:
        """检查是否为酉矩阵"""
        U_dagger = self.matrix.conj().T
        product = self.matrix @ U_dagger
        return np.allclose(product, np.eye(self.dim))

    def apply(self, state: np.ndarray) -> np.ndarray:
        """应用量子门到量子态"""
        return self.matrix @ state

# 常用量子门
class PauliGates:
    """Pauli门"""

    @staticmethod
    def X() -> QuantumGate:
        """X门 (NOT门)"""
        return QuantumGate(np.array([[0, 1], [1, 0]]))

    @staticmethod
    def Y() -> QuantumGate:
        """Y门"""
        return QuantumGate(np.array([[0, -1j], [1j, 0]]))

    @staticmethod
    def Z() -> QuantumGate:
        """Z门"""
        return QuantumGate(np.array([[1, 0], [0, -1]]))

    @staticmethod
    def H() -> QuantumGate:
        """Hadamard门"""
        return QuantumGate(np.array([[1, 1], [1, -1]]) / np.sqrt(2))

class QuantumCircuit:
    """量子电路"""

    def __init__(self, num_qubits: int):
        self.num_qubits = num_qubits
        self.gates = []
        self.measurements = []

    def add_gate(self, gate: QuantumGate, qubit: int):
        """添加量子门"""
        self.gates.append((gate, qubit))

    def measure(self, qubit: int):
        """添加测量"""
        self.measurements.append(qubit)

    def execute(self, initial_state: np.ndarray) -> np.ndarray:
        """执行量子电路"""
        state = initial_state.copy()

        for gate, qubit in self.gates:
            # 这里需要实现多量子比特门的张量积
            # 简化版本：假设是单量子比特门
            if qubit == 0:
                state = gate.apply(state)

        return state
```

### 7.2 机器学习中的线性代数

**主成分分析 (PCA)**:

```python
def principal_component_analysis(data: np.ndarray, n_components: int) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
    """主成分分析"""
    # 中心化数据
    mean = np.mean(data, axis=0)
    centered_data = data - mean

    # 计算协方差矩阵
    cov_matrix = np.cov(centered_data.T)

    # 特征值分解
    eigenvalues, eigenvectors = np.linalg.eigh(cov_matrix)

    # 选择最大的n_components个特征值
    selected_eigenvalues = eigenvalues[indices]
    selected_eigenvectors = eigenvectors[:, indices]

    # 投影数据
    projected_data = centered_data @ selected_eigenvectors

    return projected_data, selected_eigenvalues, selected_eigenvectors

def singular_value_decomposition_analysis(A: Matrix, k: int) -> Tuple[Matrix, np.ndarray, Matrix]:
    """截断奇异值分解"""
    U, s, Vt = svd_decomposition(A)

    # 截断到k个奇异值
    U_k = U.data[:, :k]
    s_k = s[:k]
    Vt_k = Vt.data[:k, :]

    return Matrix(U_k.tolist()), s_k, Matrix(Vt_k.tolist())
```

### 7.3 数值线性代数前沿

**快速矩阵乘法算法**:

```python
def strassen_matrix_multiplication(A: Matrix, B: Matrix) -> Matrix:
    """Strassen矩阵乘法算法"""
    if A.rows != A.cols or B.rows != B.cols or A.rows != B.rows:
        raise ValueError("Strassen算法只适用于相同维度的方阵")

    n = A.rows

    # 基础情况
    if n <= 64:  # 阈值可调整
        return A * B

    # 分块
    mid = n // 2

    A11 = Matrix(A.data[:mid, :mid].tolist())
    A12 = Matrix(A.data[:mid, mid:].tolist())
    A21 = Matrix(A.data[mid:, :mid].tolist())
    A22 = Matrix(A.data[mid:, mid:].tolist())

    B11 = Matrix(B.data[:mid, :mid].tolist())
    B12 = Matrix(B.data[:mid, mid:].tolist())
    B21 = Matrix(B.data[mid:, :mid].tolist())
    B22 = Matrix(B.data[mid:, mid:].tolist())

    # Strassen的7个乘法
    P1 = strassen_matrix_multiplication(A11, B12 - B22)
    P2 = strassen_matrix_multiplication(A11 + A12, B22)
    P3 = strassen_matrix_multiplication(A21 + A22, B11)
    P4 = strassen_matrix_multiplication(A22, B21 - B11)
    P5 = strassen_matrix_multiplication(A11 + A22, B11 + B22)
    P6 = strassen_matrix_multiplication(A12 - A22, B21 + B22)
    P7 = strassen_matrix_multiplication(A11 - A21, B11 + B12)

    # 组合结果
    C11 = P5 + P4 - P2 + P6
    C12 = P1 + P2
    C21 = P3 + P4
    C22 = P5 + P1 - P3 - P7

    # 合并分块
    result_data = np.block([[C11.data, C12.data], [C21.data, C22.data]])

    return Matrix(result_data.tolist())
```

## 参考文献

### 国际标准文献
1. Wikipedia contributors. (2024). *Linear algebra*. Wikipedia.
2. Wikipedia contributors. (2024). *Matrix (mathematics)*. Wikipedia.
3. Wikipedia contributors. (2024). *Eigenvalues and eigenvectors*. Wikipedia.

### 国际大学标准
1. MIT Mathematics Department. (2025). *Linear Algebra*. MIT OpenCourseWare.
2. Stanford Mathematics Department. (2025). *Linear Algebra and Matrix Theory*. Stanford University.
3. Cambridge Mathematics Department. (2025). *Linear Algebra*. University of Cambridge.
4. Oxford Mathematics Department. (2025). *Linear Algebra*. University of Oxford.

### 经典教材
1. Axler, S. (2015). *Linear Algebra Done Right*. Springer.
2. Strang, G. (2016). *Introduction to Linear Algebra*. Wellesley-Cambridge Press.
3. Hoffman, K., & Kunze, R. (1971). *Linear Algebra*. Prentice-Hall.

### 前沿发展
1. Nielsen, M. A., & Chuang, I. L. (2010). *Quantum Computation and Quantum Information*. Cambridge University Press.
2. Bishop, C. M. (2006). *Pattern Recognition and Machine Learning*. Springer.
3. Golub, G. H., & Van Loan, C. F. (2013). *Matrix Computations*. Johns Hopkins University Press.

---

**文档版本**: 2.0  
**最后更新**: 2025年1月  
**维护者**: FormalMath项目组  
**许可证**: MIT License

## 附录：国际标准证明提纲与练习清单

### A. RREF 与秩-零化度定理（证明提纲）
- 目标：对 m×n 矩阵 A，经有限次初等行变换化为行最简形 R（RREF）。
- 关键点：
  1) 初等行变换保持解集等价与秩不变；
  2) RREF 的主元列构成列空间的基；
  3) 自由变量个数 = n − rank(A)；
  4) 由维数公式得 rank(A)+nullity(A)=n。
- 提示：用高斯消去构造主元列，再用线性无关与生成性验证基的性质。

### B. 四大基本子空间（性质要点）
- Col(A) 与 N(Aᵀ) 正交；Row(A)=Col(Aᵀ) 与 N(A) 正交。
- 维数关系：dim Col(A)=rank(A)=dim Row(A)；dim N(A)=n−rank(A)；dim N(Aᵀ)=m−rank(A)。
- 应用：最小二乘残差 r=b−Ax̂∈N(Aᵀ)，且与 Col(A) 正交。

### C. 谱定理与 Schur 分解（证明提纲）
- 谱定理（实对称/Hermitian）：
  1) 不同特征值的特征向量正交；
  2) 通过归一化与扩充得到正交（酉）基；
  3) 正交（酉）对角化成立。
- Schur 分解（复）：
  1) 单位酉相似可将 A 化为上三角 T（对角为特征值）；
  2) 由Householder/QR迭代构造数值算法；
  3) 实情形为准上三角（含2×2共轭块）。

### D. SVD 与伪逆（形式化接口草案）
```python
from typing import Tuple
import numpy as np

class SVD:
    @staticmethod
    def decompose(A: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """返回 U, s, Vt，满足 A = U @ diag(s) @ Vt"""
        return np.linalg.svd(A, full_matrices=False)

class PseudoInverse:
    @staticmethod
    def pinv(A: np.ndarray, tol: float = 1e-12) -> np.ndarray:
        U, s, Vt = np.linalg.svd(A, full_matrices=False)
        s_plus = np.diag([1/si if si > tol else 0.0 for si in s])
        return Vt.T @ s_plus @ U.T
```

### E. 示例与练习（建议）
- 示例1：用 RREF 判定 Ax=b 是否可解，给出通解参数表示。
- 示例2：最小二乘拟合直线，比较法方程与 SVD 方案的数值稳定性。
- 示例3：判断矩阵正定性（特征值/Cholesky/主子式），并给出等价条件证明。
- 练习1：证明 Col(A) 与 N(Aᵀ) 正交并给出反例说明正交补仅在适当内积空间下成立。
- 练习2：推导 rank-nullity 并应用于图拉普拉斯矩阵的零空间维数分析。
- 练习3：实现截断 SVD 的低秩逼近，并分析误差 ∥A−A_k∥₂=σ_{k+1}。

### F. 可运行示例：法方程 vs SVD 最小二乘
```python
# 比较法方程与SVD在病态情形下的稳健性
import numpy as np

# 构造病态矩阵（奇异值跨越多个数量级）
rng = np.random.default_rng(0)
U, _ = np.linalg.qr(rng.normal(size=(50, 10)))
Vt, _ = np.linalg.qr(rng.normal(size=(10, 10)))
s = np.geomspace(1, 1e-8, 10)  # 奇异值递减
A = U[:, :10] @ np.diag(s) @ Vt.T
x_true = rng.normal(size=(10,))
b = A @ x_true + 1e-6 * rng.normal(size=(50,))

# 法方程解（可能数值不稳）
ATA = A.T @ A
ATb = A.T @ b
x_ne = np.linalg.solve(ATA, ATb)

# SVD伪逆解（更稳健）
U_svd, s_svd, Vt_svd = np.linalg.svd(A, full_matrices=False)
s_plus = np.diag([1/si if si > 1e-12 else 0.0 for si in s_svd])
x_svd = Vt_svd.T @ s_plus @ U_svd.T @ b

err_ne = np.linalg.norm(x_ne - x_true)
err_svd = np.linalg.norm(x_svd - x_true)
cond2 = s_svd[0] / max(s_svd[-1], 1e-12)
print(f"2-条件数 κ₂(A) ≈ {cond2:.2e}")
print(f"法方程误差: {err_ne:.3e}  |  SVD误差: {err_svd:.3e}")
```

### G. 正定性等价条件与Cholesky验证
- 正定矩阵等价条件（实对称 A）：
  1) xᵀAx > 0(∀x≠0)；
  2) 所有特征值 > 0；
  3) 存在唯一下三角 L，使 A=LLᵀ（Cholesky 分解）；
  4) 所有顺序主子式为正。

```python
# 三种正定性检测：特征值、Cholesky、主子式（示意）
import numpy as np

A = np.array([[4.0, 2.0, 0.0],
              [2.0, 3.0, 1.0],
              [0.0, 1.0, 2.0]])

# (1) 特征值法
w = np.linalg.eigvalsh(A)  # 对称阵用eigvalsh更稳
is_pd_eig = np.all(w > 0)

# (2) Cholesky（最推荐的数值方式）
try:
    L = np.linalg.cholesky(A)
    is_pd_chol = True
except np.linalg.LinAlgError:
    is_pd_chol = False

# (3) 主子式（示意：仅检查前k×k主子式）
def is_pd_leading_principal_minors(A: np.ndarray) -> bool:
    for k in range(1, A.shape[0] + 1):
        if np.linalg.det(A[:k, :k]) <= 0:
            return False
    return True

is_pd_principal = is_pd_leading_principal_minors(A)
print({
    'eig_method': is_pd_eig,
    'cholesky': is_pd_chol,
    'principal_minors': is_pd_principal
})
```

---

**交互与补充资源 / Interactive & Supplementary Resources**:

- [交互式图表增强（线性变换/特征值可视化）](../交互式图表增强-2025年1月.md)
- [定理证明补充（秩-零化度定理、谱定理）](../定理证明补充-2025年1月.md)
- [反例与特殊情况补充（线性无关/基/矩阵反例）](../反例与特殊情况补充-2025年1月.md)
- [历史背景补充（线性代数与矩阵理论发展）](../历史背景补充-2025年1月.md)
