# ç¾¤è®º - å¢å¼ºç‰ˆ

## ç›®å½•

- [ç¾¤è®º - å¢å¼ºç‰ˆ](#ç¾¤è®º---å¢å¼ºç‰ˆ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“š æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ•°ï¸ å†å²å‘å±•è„‰ç»œ](#ï¸-å†å²å‘å±•è„‰ç»œ)
    - [æ—©æœŸå‘å±• (1770-1850)](#æ—©æœŸå‘å±•-1770-1850)
      - [æ‹‰æ ¼æœ—æ—¥æ—¶ä»£](#æ‹‰æ ¼æœ—æ—¥æ—¶ä»£)
      - [ä¼½ç½—ç“¦é©å‘½](#ä¼½ç½—ç“¦é©å‘½)
    - [ç³»ç»ŸåŒ–å‘å±• (1850-1900)](#ç³»ç»ŸåŒ–å‘å±•-1850-1900)
      - [å‡¯è±çš„è´¡çŒ®](#å‡¯è±çš„è´¡çŒ®)
      - [å…‹è±å› çš„å‡ ä½•ç¾¤è®º](#å…‹è±å› çš„å‡ ä½•ç¾¤è®º)
    - [ç°ä»£å‘å±• (1900-è‡³ä»Š)](#ç°ä»£å‘å±•-1900-è‡³ä»Š)
      - [æœ‰é™ç¾¤è®º](#æœ‰é™ç¾¤è®º)
      - [æ— é™ç¾¤è®º](#æ— é™ç¾¤è®º)
    - [é‡è¦äººç‰©è´¡çŒ®](#é‡è¦äººç‰©è´¡çŒ®)
    - [é‡è¦å†å²äº‹ä»¶æ—¶é—´çº¿](#é‡è¦å†å²äº‹ä»¶æ—¶é—´çº¿)
  - [ğŸ—ï¸ æ ¸å¿ƒæ¦‚å¿µ](#ï¸-æ ¸å¿ƒæ¦‚å¿µ)
    - [ç¾¤çš„å®šä¹‰](#ç¾¤çš„å®šä¹‰)
    - [åŸºæœ¬æ€§è´¨](#åŸºæœ¬æ€§è´¨)
      - [1. ç»“åˆå¾‹](#1-ç»“åˆå¾‹)
      - [2. å•ä½å…ƒ](#2-å•ä½å…ƒ)
      - [3. é€†å…ƒ](#3-é€†å…ƒ)
  - [ğŸ“Š å¯è§†åŒ–å›¾è¡¨](#-å¯è§†åŒ–å›¾è¡¨)
    - [ç¾¤çš„ç»“æ„å›¾](#ç¾¤çš„ç»“æ„å›¾)
    - [å­ç¾¤å…³ç³»å›¾](#å­ç¾¤å…³ç³»å›¾)
    - [ç¾¤åŒæ€å›¾](#ç¾¤åŒæ€å›¾)
  - [ğŸ” å®ä¾‹è¡¨å¾](#-å®ä¾‹è¡¨å¾)
    - [1. æœ‰é™ç¾¤å®ä¾‹](#1-æœ‰é™ç¾¤å®ä¾‹)
      - [å¯¹ç§°ç¾¤ Sâ‚ƒ](#å¯¹ç§°ç¾¤-s)
      - [å‡¯è±è¡¨](#å‡¯è±è¡¨)
    - [2. æ— é™ç¾¤å®ä¾‹](#2-æ— é™ç¾¤å®ä¾‹)
      - [æ•´æ•°åŠ æ³•ç¾¤ (â„¤, +)](#æ•´æ•°åŠ æ³•ç¾¤-â„¤-)
      - [å®æ•°ä¹˜æ³•ç¾¤ (â„\*, Ã—)](#å®æ•°ä¹˜æ³•ç¾¤-â„-)
    - [3. é‡è¦ç¾¤ç±»](#3-é‡è¦ç¾¤ç±»)
      - [å¾ªç¯ç¾¤](#å¾ªç¯ç¾¤)
      - [äºŒé¢ä½“ç¾¤ Dâ‚™](#äºŒé¢ä½“ç¾¤-dâ‚™)
  - [ğŸ§  æ€ç»´è¿‡ç¨‹è¡¨å¾](#-æ€ç»´è¿‡ç¨‹è¡¨å¾)
    - [1. ç¾¤è®ºé—®é¢˜è§£å†³æµç¨‹](#1-ç¾¤è®ºé—®é¢˜è§£å†³æµç¨‹)
      - [æ­¥éª¤1ï¼šè¯†åˆ«ç¾¤ç»“æ„](#æ­¥éª¤1è¯†åˆ«ç¾¤ç»“æ„)
      - [æ­¥éª¤2ï¼šåˆ†æç¾¤æ€§è´¨](#æ­¥éª¤2åˆ†æç¾¤æ€§è´¨)
      - [æ­¥éª¤3ï¼šåº”ç”¨ç¾¤è®ºå·¥å…·](#æ­¥éª¤3åº”ç”¨ç¾¤è®ºå·¥å…·)
    - [2. è¯æ˜æ€ç»´è¿‡ç¨‹](#2-è¯æ˜æ€ç»´è¿‡ç¨‹)
      - [æ‹‰æ ¼æœ—æ—¥å®šç†è¯æ˜](#æ‹‰æ ¼æœ—æ—¥å®šç†è¯æ˜)
      - [è¥¿ç½—å®šç†è¯æ˜](#è¥¿ç½—å®šç†è¯æ˜)
      - [ç¬¬ä¸€åŒæ„å®šç†è¯æ˜](#ç¬¬ä¸€åŒæ„å®šç†è¯æ˜)
    - [3. æ¦‚å¿µç†è§£æ­¥éª¤](#3-æ¦‚å¿µç†è§£æ­¥éª¤)
      - [ç†è§£ç¾¤çš„æ¦‚å¿µ](#ç†è§£ç¾¤çš„æ¦‚å¿µ)
      - [ç†è§£å­ç¾¤æ¦‚å¿µ](#ç†è§£å­ç¾¤æ¦‚å¿µ)
    - [4. é—®é¢˜è§£å†³ç­–ç•¥](#4-é—®é¢˜è§£å†³ç­–ç•¥)
      - [ç¾¤è®ºé—®é¢˜åˆ†ç±»](#ç¾¤è®ºé—®é¢˜åˆ†ç±»)
      - [å¸¸è§æ€ç»´è¯¯åŒº](#å¸¸è§æ€ç»´è¯¯åŒº)
    - [5. ç®—æ³•æ€ç»´åˆ†æ](#5-ç®—æ³•æ€ç»´åˆ†æ)
      - [ç¾¤è®ºç®—æ³•è®¾è®¡](#ç¾¤è®ºç®—æ³•è®¾è®¡)
      - [è®¡ç®—å¤æ‚æ€§åˆ†æ](#è®¡ç®—å¤æ‚æ€§åˆ†æ)
  - [ğŸŒ åº”ç”¨åœºæ™¯è¡¨å¾](#-åº”ç”¨åœºæ™¯è¡¨å¾)
    - [1. è‡ªç„¶ç§‘å­¦åº”ç”¨](#1-è‡ªç„¶ç§‘å­¦åº”ç”¨)
      - [ç‰©ç†å­¦åº”ç”¨](#ç‰©ç†å­¦åº”ç”¨)
      - [åŒ–å­¦åº”ç”¨](#åŒ–å­¦åº”ç”¨)
    - [2. å·¥ç¨‹æŠ€æœ¯åº”ç”¨](#2-å·¥ç¨‹æŠ€æœ¯åº”ç”¨)
      - [å¯†ç å­¦åº”ç”¨](#å¯†ç å­¦åº”ç”¨)
      - [ç¼–ç ç†è®º](#ç¼–ç ç†è®º)
    - [3. è®¡ç®—æœºç§‘å­¦åº”ç”¨](#3-è®¡ç®—æœºç§‘å­¦åº”ç”¨)
      - [ç®—æ³•è®¾è®¡](#ç®—æ³•è®¾è®¡)
      - [æ•°æ®ç»“æ„ä¼˜åŒ–](#æ•°æ®ç»“æ„ä¼˜åŒ–)
    - [4. æ•°å­¦å†…éƒ¨åº”ç”¨](#4-æ•°å­¦å†…éƒ¨åº”ç”¨)
      - [ä»£æ•°å‡ ä½•](#ä»£æ•°å‡ ä½•)
      - [æ•°è®º](#æ•°è®º)
    - [5. å®é™…åº”ç”¨æ¡ˆä¾‹](#5-å®é™…åº”ç”¨æ¡ˆä¾‹)
      - [æ¡ˆä¾‹1ï¼šæ™¶ä½“å­¦ç‚¹ç¾¤](#æ¡ˆä¾‹1æ™¶ä½“å­¦ç‚¹ç¾¤)
      - [æ¡ˆä¾‹2ï¼šé‡å­åŠ›å­¦ä¸­çš„æç¾¤](#æ¡ˆä¾‹2é‡å­åŠ›å­¦ä¸­çš„æç¾¤)
      - [æ¡ˆä¾‹3ï¼šå¯†ç å­¦ä¸­çš„æ¤­åœ†æ›²çº¿](#æ¡ˆä¾‹3å¯†ç å­¦ä¸­çš„æ¤­åœ†æ›²çº¿)
  - [ğŸ”— çŸ¥è¯†å…³è”ç½‘ç»œ](#-çŸ¥è¯†å…³è”ç½‘ç»œ)
    - [ä¸å…¶ä»–æ•°å­¦åˆ†æ”¯çš„è”ç³»](#ä¸å…¶ä»–æ•°å­¦åˆ†æ”¯çš„è”ç³»)
      - [ä¸çº¿æ€§ä»£æ•°çš„è”ç³»](#ä¸çº¿æ€§ä»£æ•°çš„è”ç³»)
      - [ä¸æ‹“æ‰‘å­¦çš„è”ç³»](#ä¸æ‹“æ‰‘å­¦çš„è”ç³»)
      - [ä¸å‡ ä½•å­¦çš„è”ç³»](#ä¸å‡ ä½•å­¦çš„è”ç³»)
    - [ç†è®ºå‘å±•è„‰ç»œ](#ç†è®ºå‘å±•è„‰ç»œ)
      - [ä»å…·ä½“åˆ°æŠ½è±¡](#ä»å…·ä½“åˆ°æŠ½è±¡)
      - [ä»æœ‰é™åˆ°æ— é™](#ä»æœ‰é™åˆ°æ— é™)
      - [ä»äº¤æ¢åˆ°éäº¤æ¢](#ä»äº¤æ¢åˆ°éäº¤æ¢)
  - [ğŸ“ˆ ç°ä»£å‘å±•å‰æ²¿](#-ç°ä»£å‘å±•å‰æ²¿)
    - [1. å‡ ä½•ç¾¤è®º](#1-å‡ ä½•ç¾¤è®º)
    - [2. è¡¨ç¤ºè®º](#2-è¡¨ç¤ºè®º)
    - [3. ç»„åˆç¾¤è®º](#3-ç»„åˆç¾¤è®º)
    - [4. ä»£æ•°ç¾¤è®º](#4-ä»£æ•°ç¾¤è®º)
  - [ğŸ¯ å­¦ä¹ è·¯å¾„å»ºè®®](#-å­¦ä¹ è·¯å¾„å»ºè®®)
    - [åˆå­¦è€…è·¯å¾„](#åˆå­¦è€…è·¯å¾„)
    - [è¿›é˜¶è·¯å¾„](#è¿›é˜¶è·¯å¾„)
    - [ç ”ç©¶è·¯å¾„](#ç ”ç©¶è·¯å¾„)
  - [ğŸŒŸ æ€»ç»“](#-æ€»ç»“)
  - [æœ¯è¯­å¯¹ç…§è¡¨ / Terminology Table](#æœ¯è¯­å¯¹ç…§è¡¨--terminology-table)
  - [å¤šè¡¨å¾æ–¹å¼ä¸å›¾å»ºæ¨¡](#å¤šè¡¨å¾æ–¹å¼ä¸å›¾å»ºæ¨¡)
    - [ç¾¤è®ºçš„å¤šè¡¨å¾ç³»ç»Ÿ](#ç¾¤è®ºçš„å¤šè¡¨å¾ç³»ç»Ÿ)
    - [æ€ç»´å¯¼å›¾ï¼šç¾¤è®ºçš„æ ¸å¿ƒæ¦‚å¿µ](#æ€ç»´å¯¼å›¾ç¾¤è®ºçš„æ ¸å¿ƒæ¦‚å¿µ)

## ğŸ“š æ¦‚è¿°

ç¾¤è®ºæ˜¯ç°ä»£ä»£æ•°å­¦çš„æ ¸å¿ƒåˆ†æ”¯ï¼Œç ”ç©¶å…·æœ‰ç‰¹å®šè¿ç®—ç»“æ„çš„é›†åˆã€‚
ç¾¤çš„æ¦‚å¿µç»Ÿä¸€äº†æ•°å­¦ä¸­è®¸å¤šé‡è¦çš„ç»“æ„ï¼Œä»å¯¹ç§°æ€§åˆ°æ•°è®ºï¼Œä»å‡ ä½•åˆ°ç‰©ç†ï¼Œç¾¤è®ºéƒ½å‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚

## ğŸ•°ï¸ å†å²å‘å±•è„‰ç»œ

### æ—©æœŸå‘å±• (1770-1850)

#### æ‹‰æ ¼æœ—æ—¥æ—¶ä»£

```mermaid
timeline
    title ç¾¤è®ºæ—©æœŸå‘å±•
    1770å¹´ : æ‹‰æ ¼æœ—æ—¥ç ”ç©¶ä»£æ•°æ–¹ç¨‹å¯è§£æ€§
    1799å¹´ : é²è²å°¼æå‡ºäº”æ¬¡æ–¹ç¨‹ä¸å¯è§£è¯æ˜
    1824å¹´ : é˜¿è´å°”ä¸¥æ ¼è¯æ˜äº”æ¬¡æ–¹ç¨‹ä¸å¯è§£
    1832å¹´ : ä¼½ç½—ç“¦å¼•å…¥ç¾¤çš„æ¦‚å¿µ
    1846å¹´ : åˆ˜ç»´å°”å‘è¡¨ä¼½ç½—ç“¦è®ºæ–‡
```

- **1770å¹´**: æ‹‰æ ¼æœ—æ—¥ç ”ç©¶ä»£æ•°æ–¹ç¨‹çš„å¯è§£æ€§ï¼Œä¸ºç¾¤è®ºå¥ å®šåŸºç¡€
  - å‘ç°ç½®æ¢åœ¨æ–¹ç¨‹æ±‚è§£ä¸­çš„é‡è¦ä½œç”¨
  - å¼•å…¥ç½®æ¢ç¾¤çš„æ¦‚å¿µé›å½¢
  - ä¸ºä¼½ç½—ç“¦ç†è®ºå¥ å®šåŸºç¡€
- **1799å¹´**: é²è²å°¼æå‡ºäº”æ¬¡æ–¹ç¨‹ä¸å¯è§£çš„è¯æ˜ï¼Œä½†ä¸å¤Ÿä¸¥æ ¼
  - é¦–æ¬¡å°è¯•è¯æ˜äº”æ¬¡æ–¹ç¨‹ä¸å¯è§£
  - æ–¹æ³•ä¸å¤Ÿä¸¥è°¨ï¼Œå­˜åœ¨æ¼æ´
  - ä¸ºé˜¿è´å°”çš„å·¥ä½œæä¾›å¯å‘
- **1824å¹´**: é˜¿è´å°”ä¸¥æ ¼è¯æ˜äº”æ¬¡æ–¹ç¨‹ä¸å¯è§£ï¼Œå¼•å…¥é˜¿è´å°”ç¾¤æ¦‚å¿µ
  - ä¸¥æ ¼è¯æ˜äº”æ¬¡åŠä»¥ä¸Šæ–¹ç¨‹ä¸å¯ç”¨æ ¹å¼æ±‚è§£
  - å¼•å…¥å¯äº¤æ¢ç¾¤çš„æ¦‚å¿µ
  - å»ºç«‹é˜¿è´å°”ç¾¤ç†è®ºçš„åŸºç¡€

#### ä¼½ç½—ç“¦é©å‘½

- **1832å¹´**: ä¼½ç½—ç“¦å¼•å…¥ç¾¤çš„æ¦‚å¿µï¼Œå»ºç«‹ä¼½ç½—ç“¦ç†è®º
  - åœ¨å†³æ–—å‰å¤œå®Œæˆç¾¤è®ºåŸºç¡€å·¥ä½œ
  - å¼•å…¥ç¾¤çš„æ¦‚å¿µå’ŒåŸºæœ¬æ€§è´¨
  - å»ºç«‹ä¼½ç½—ç“¦å¯¹åº”ç†è®º
  - è§£å†³ä»£æ•°æ–¹ç¨‹å¯è§£æ€§é—®é¢˜
- **1832å¹´**: ä¼½ç½—ç“¦ç†è®ºå»ºç«‹ï¼Œè§£å†³ä»£æ•°æ–¹ç¨‹å¯è§£æ€§é—®é¢˜
  - å»ºç«‹åŸŸæ‰©å¼ ä¸ç¾¤ä¹‹é—´çš„å¯¹åº”å…³ç³»
  - è¯æ˜æ–¹ç¨‹å¯è§£æ€§ç­‰ä»·äºä¼½ç½—ç“¦ç¾¤å¯è§£
  - ä¸ºç°ä»£ä»£æ•°å‡ ä½•å¥ å®šåŸºç¡€
- **1846å¹´**: åˆ˜ç»´å°”å‘è¡¨ä¼½ç½—ç“¦çš„è®ºæ–‡ï¼Œä½¿ç¾¤è®ºå¹¿ä¸ºäººçŸ¥
  - æ•´ç†å¹¶å‘è¡¨ä¼½ç½—ç“¦çš„é—ä½œ
  - ä½¿ç¾¤è®ºç†è®ºå¾—åˆ°å¹¿æ³›ä¼ æ’­
  - ä¸ºç¾¤è®ºçš„åç»­å‘å±•å¥ å®šåŸºç¡€

### ç³»ç»ŸåŒ–å‘å±• (1850-1900)

#### å‡¯è±çš„è´¡çŒ®

- **1854å¹´**: å‡¯è±ç»™å‡ºç¾¤çš„æŠ½è±¡å®šä¹‰ï¼Œä½¿ç¾¤è®ºæˆä¸ºç‹¬ç«‹å­¦ç§‘
  - é¦–æ¬¡ç»™å‡ºç¾¤çš„æŠ½è±¡å®šä¹‰
  - å°†ç¾¤è®ºä»å…·ä½“åº”ç”¨ä¸­æŠ½è±¡å‡ºæ¥
  - å»ºç«‹ç¾¤è®ºçš„å…¬ç†åŒ–ä½“ç³»
- **1878å¹´**: å‡¯è±å®šç†ï¼šæ¯ä¸ªç¾¤éƒ½æ˜¯ç½®æ¢ç¾¤çš„å­ç¾¤
  - è¯æ˜ä»»ä½•ç¾¤éƒ½å¯ä»¥åµŒå…¥åˆ°å¯¹ç§°ç¾¤ä¸­
  - ä¸ºç¾¤è¡¨ç¤ºè®ºå¥ å®šåŸºç¡€
  - å»ºç«‹ç¾¤è®ºä¸ç»„åˆå­¦çš„è”ç³»

#### å…‹è±å› çš„å‡ ä½•ç¾¤è®º

- **1872å¹´**: åŸƒå°”æœ—æ ¹çº²é¢†ï¼Œç”¨ç¾¤è®ºç»Ÿä¸€å‡ ä½•å­¦
  - æå‡ºç”¨å˜æ¢ç¾¤æ¥åˆ†ç±»å‡ ä½•å­¦
  - å»ºç«‹å‡ ä½•å­¦ä¸ç¾¤è®ºçš„è”ç³»
  - ä¸ºç°ä»£å‡ ä½•å­¦å¥ å®šåŸºç¡€
- **1884å¹´**: å…‹è±å› ç ”ç©¶å‡ ä½•å˜æ¢ç¾¤ï¼Œå»ºç«‹å‡ ä½•ç¾¤è®º
  - ç ”ç©¶ç­‰è·å˜æ¢ç¾¤çš„æ€§è´¨
  - å»ºç«‹å°„å½±å˜æ¢ç¾¤ç†è®º
  - ä¸ºæç¾¤ç†è®ºå¥ å®šåŸºç¡€

### ç°ä»£å‘å±• (1900-è‡³ä»Š)

#### æœ‰é™ç¾¤è®º

- **1904å¹´**: ä¼¯æ©èµ›å¾·çŒœæƒ³ï¼Œå…³äºæœ‰é™ç¾¤çš„é‡è¦çŒœæƒ³
  - æå‡ºå…³äºæœ‰é™ç¾¤é˜¶æ•°çš„çŒœæƒ³
  - å½±å“æœ‰é™ç¾¤è®ºå‘å±•æ•°åå¹´
  - ä¸ºæœ‰é™ç¾¤åˆ†ç±»æä¾›æ–¹å‘
- **1963å¹´**: è´¹ç‰¹-æ±¤æ™®æ£®å®šç†ï¼Œæœ‰é™ç¾¤è®ºçš„é‡å¤§çªç ´
  - è¯æ˜å¥‡æ•°é˜¶ç¾¤å¯è§£
  - ä¸ºæœ‰é™å•ç¾¤åˆ†ç±»å¥ å®šåŸºç¡€
  - è·å¾—è²å°”å…¹å¥–çš„é‡è¦å·¥ä½œ
- **2004å¹´**: æœ‰é™å•ç¾¤åˆ†ç±»å®Œæˆï¼Œç¾¤è®ºå²ä¸Šçš„é‡Œç¨‹ç¢‘
  - å®Œæˆæœ‰é™å•ç¾¤çš„å®Œå…¨åˆ†ç±»
  - åŒ…å«18ä¸ªæ— é™æ—å’Œ26ä¸ªæ•£åœ¨ç¾¤
  - è¢«èª‰ä¸º"æ•°å­¦çš„è’™å¨œä¸½è"

#### æ— é™ç¾¤è®º

- **1929å¹´**: å†¯Â·è¯ºä¾æ›¼ç ”ç©¶ç®—å­ç¾¤ï¼Œè¿æ¥ç¾¤è®ºä¸æ³›å‡½åˆ†æ
  - å»ºç«‹ç®—å­ç¾¤ç†è®º
  - è¿æ¥ç¾¤è®ºä¸æ³›å‡½åˆ†æ
  - ä¸ºé‡å­åŠ›å­¦æä¾›æ•°å­¦åŸºç¡€
- **1950å¹´ä»£**: æç¾¤ç†è®ºå‘å±•ï¼Œåœ¨ç‰©ç†ä¸­æœ‰é‡è¦åº”ç”¨
  - æç¾¤åœ¨ç‰©ç†ä¸­çš„åº”ç”¨
  - å»ºç«‹æç¾¤è¡¨ç¤ºè®º
  - ä¸ºç°ä»£ç‰©ç†æä¾›æ•°å­¦å·¥å…·
- **1970å¹´ä»£**: å‡ ä½•ç¾¤è®ºå…´èµ·ï¼Œç ”ç©¶ç¾¤çš„å‡ ä½•æ€§è´¨
  - ç ”ç©¶ç¾¤ä¸å‡ ä½•ç©ºé—´çš„è”ç³»
  - å»ºç«‹åŒæ›²ç¾¤ç†è®º
  - ä¸ºç°ä»£ç¾¤è®ºå¼€è¾Ÿæ–°æ–¹å‘

### é‡è¦äººç‰©è´¡çŒ®

| äººç‰© | æ—¶æœŸ | ä¸»è¦è´¡çŒ® | å½±å“ |
|------|------|----------|------|
| æ‹‰æ ¼æœ—æ—¥ | 1770 | ä»£æ•°æ–¹ç¨‹å¯è§£æ€§ç ”ç©¶ | ä¸ºç¾¤è®ºå¥ å®šåŸºç¡€ |
| é˜¿è´å°” | 1824 | é˜¿è´å°”ç¾¤ï¼Œä¸¥æ ¼è¯æ˜ | å»ºç«‹å¯äº¤æ¢ç¾¤ç†è®º |
| ä¼½ç½—ç“¦ | 1832 | ä¼½ç½—ç“¦ç†è®ºï¼Œç¾¤æ¦‚å¿µ | é©å‘½æ€§æ”¹å˜ä»£æ•°å­¦ |
| å‡¯è± | 1854 | ç¾¤çš„æŠ½è±¡å®šä¹‰ | ä½¿ç¾¤è®ºæˆä¸ºç‹¬ç«‹å­¦ç§‘ |
| å…‹è±å›  | 1872 | åŸƒå°”æœ—æ ¹çº²é¢† | ç»Ÿä¸€å‡ ä½•å­¦ |
| ä¼¯æ©èµ›å¾· | 1904 | ä¼¯æ©èµ›å¾·çŒœæƒ³ | æ¨åŠ¨æœ‰é™ç¾¤è®ºå‘å±• |
| è´¹ç‰¹-æ±¤æ™®æ£® | 1963 | æœ‰é™ç¾¤è®ºé‡å¤§çªç ´ | è²å°”å…¹å¥–å·¥ä½œ |
| é˜¿å»· | 1920s | é˜¿å»·Lå‡½æ•° | è¿æ¥ç¾¤è®ºä¸æ•°è®º |
| å¡å°” | 1950s | ä»£æ•°ç¾¤ç†è®º | ç°ä»£ä»£æ•°å‡ ä½•åŸºç¡€ |
| æ ¼ç½—æ»•è¿ªå…‹ | 1960s | æ¦‚å½¢ç†è®º | é©å‘½æ€§æ”¹å˜ä»£æ•°å‡ ä½• |

### é‡è¦å†å²äº‹ä»¶æ—¶é—´çº¿

```mermaid
timeline
    title ç¾¤è®ºå‘å±•é‡è¦äº‹ä»¶
    1770å¹´ : æ‹‰æ ¼æœ—æ—¥ç ”ç©¶ä»£æ•°æ–¹ç¨‹
    1824å¹´ : é˜¿è´å°”è¯æ˜äº”æ¬¡æ–¹ç¨‹ä¸å¯è§£
    1832å¹´ : ä¼½ç½—ç“¦å»ºç«‹ç¾¤è®ºåŸºç¡€
    1854å¹´ : å‡¯è±ç»™å‡ºç¾¤æŠ½è±¡å®šä¹‰
    1872å¹´ : å…‹è±å› åŸƒå°”æœ—æ ¹çº²é¢†
    1904å¹´ : ä¼¯æ©èµ›å¾·çŒœæƒ³
    1963å¹´ : è´¹ç‰¹-æ±¤æ™®æ£®å®šç†
    2004å¹´ : æœ‰é™å•ç¾¤åˆ†ç±»å®Œæˆ
```

## ğŸ—ï¸ æ ¸å¿ƒæ¦‚å¿µ

### ç¾¤çš„å®šä¹‰

```lean
-- Lean 4 å½¢å¼åŒ–å®šä¹‰
structure Group where
  carrier : Type
  mul : carrier â†’ carrier â†’ carrier
  one : carrier
  inv : carrier â†’ carrier
  mul_assoc : âˆ€ a b c, mul (mul a b) c = mul a (mul b c)
  one_mul : âˆ€ a, mul one a = a
  mul_one : âˆ€ a, mul a one = a
  mul_inv : âˆ€ a, mul a (inv a) = one
```

### åŸºæœ¬æ€§è´¨

#### 1. ç»“åˆå¾‹

å¯¹äºç¾¤ä¸­çš„ä»»æ„å…ƒç´  $a, b, c$ï¼Œæœ‰ï¼š
$$(a \cdot b) \cdot c = a \cdot (b \cdot c)$$

#### 2. å•ä½å…ƒ

å­˜åœ¨å”¯ä¸€çš„å•ä½å…ƒ $e$ï¼Œä½¿å¾—ï¼š
$$e \cdot a = a \cdot e = a$$

#### 3. é€†å…ƒ

æ¯ä¸ªå…ƒç´  $a$ éƒ½æœ‰å”¯ä¸€çš„é€†å…ƒ $a^{-1}$ï¼š
$$a \cdot a^{-1} = a^{-1} \cdot a = e$$

## ğŸ“Š å¯è§†åŒ–å›¾è¡¨

### ç¾¤çš„ç»“æ„å›¾

```mermaid
graph TD
    A[ç¾¤ G] --> B[è¿ç®— Â·]
    A --> C[å•ä½å…ƒ e]
    A --> D[é€†å…ƒ aâ»Â¹]
    
    B --> E[ç»“åˆå¾‹]
    B --> F[å°é—­æ€§]
    
    C --> G[eÂ·a = aÂ·e = a]
    D --> H[aÂ·aâ»Â¹ = aâ»Â¹Â·a = e]
```

### å­ç¾¤å…³ç³»å›¾

```mermaid
graph TD
    A[ç¾¤ G] --> B[å­ç¾¤ H]
    B --> C[æ­£è§„å­ç¾¤ N]
    C --> D[å•†ç¾¤ G/N]
    
    A --> E[ä¸­å¿ƒ Z(G)]
    A --> F[æ¢ä½å­ç¾¤ [G,G]]
    
    B --> G[å·¦é™ªé›†]
    B --> H[å³é™ªé›†]
```

### ç¾¤åŒæ€å›¾

```mermaid
graph LR
    A[ç¾¤ G] -->|Ï†| B[ç¾¤ H]
    C[å•ä½å…ƒ e_G] -->|Ï†| D[å•ä½å…ƒ e_H]
    E[é€†å…ƒ aâ»Â¹] -->|Ï†| F[é€†å…ƒ Ï†(a)â»Â¹]
```

## ğŸ” å®ä¾‹è¡¨å¾

### 1. æœ‰é™ç¾¤å®ä¾‹

#### å¯¹ç§°ç¾¤ Sâ‚ƒ

```haskell
-- Haskell å®ç°
data Sym3 = Id | R120 | R240 | F1 | F2 | F3

instance Group Sym3 where
  one = Id
  inv Id = Id
  inv R120 = R240
  inv R240 = R120
  inv F1 = F1
  inv F2 = F2
  inv F3 = F3
  
  mul Id x = x
  mul x Id = x
  mul R120 R120 = R240
  mul R120 R240 = Id
  mul R240 R120 = Id
  mul R240 R240 = R120
  -- ... å…¶ä»–è¿ç®—
```

#### å‡¯è±è¡¨

| Â· | Id | R120 | R240 | F1 | F2 | F3 |
|---|----|----|----|----|----|----|
| Id | Id | R120 | R240 | F1 | F2 | F3 |
| R120 | R120 | R240 | Id | F2 | F3 | F1 |
| R240 | R240 | Id | R120 | F3 | F1 | F2 |
| F1 | F1 | F3 | F2 | Id | R240 | R120 |
| F2 | F2 | F1 | F3 | R120 | Id | R240 |
| F3 | F3 | F2 | F1 | R240 | R120 | Id |

### 2. æ— é™ç¾¤å®ä¾‹

#### æ•´æ•°åŠ æ³•ç¾¤ (â„¤, +)

```rust
// Rust å®ç°
#[derive(Debug, Clone, PartialEq)]
pub struct IntegerGroup {
    value: i32,
}

impl IntegerGroup {
    pub fn new(value: i32) -> Self {
        IntegerGroup { value }
    }
    
    pub fn add(&self, other: &IntegerGroup) -> IntegerGroup {
        IntegerGroup::new(self.value + other.value)
    }
    
    pub fn identity() -> IntegerGroup {
        IntegerGroup::new(0)
    }
    
    pub fn inverse(&self) -> IntegerGroup {
        IntegerGroup::new(-self.value)
    }
}
```

#### å®æ•°ä¹˜æ³•ç¾¤ (â„*, Ã—)

```lean
-- Lean 4 å®ç°
structure RealMultiplicativeGroup where
  value : â„
  nonzero : value â‰  0

def mul (a b : RealMultiplicativeGroup) : RealMultiplicativeGroup :=
  âŸ¨a.value * b.value, by simp [a.nonzero, b.nonzero]âŸ©

def one : RealMultiplicativeGroup := âŸ¨1, by simpâŸ©

def inv (a : RealMultiplicativeGroup) : RealMultiplicativeGroup :=
  âŸ¨a.valueâ»Â¹, by simp [a.nonzero]âŸ©
```

### 3. é‡è¦ç¾¤ç±»

#### å¾ªç¯ç¾¤

```haskell
-- å¾ªç¯ç¾¤ Câ‚™
data CyclicGroup n = CyclicGroup { value :: Int }

instance (KnownNat n) => Group (CyclicGroup n) where
  one = CyclicGroup 0
  inv (CyclicGroup x) = CyclicGroup (mod (-x) n)
  mul (CyclicGroup x) (CyclicGroup y) = CyclicGroup (mod (x + y) n)
```

#### äºŒé¢ä½“ç¾¤ Dâ‚™

```rust
// äºŒé¢ä½“ç¾¤ Dâ‚™
pub struct DihedralGroup {
    n: u32,
    rotation: u32,
    reflection: bool,
}

impl DihedralGroup {
    pub fn new(n: u32) -> Self {
        DihedralGroup {
            n,
            rotation: 0,
            reflection: false,
        }
    }
    
    pub fn rotate(&mut self) {
        self.rotation = (self.rotation + 1) % self.n;
    }
    
    pub fn reflect(&mut self) {
        self.reflection = !self.reflection;
    }
}
```

## ğŸ§  æ€ç»´è¿‡ç¨‹è¡¨å¾

### 1. ç¾¤è®ºé—®é¢˜è§£å†³æµç¨‹

#### æ­¥éª¤1ï¼šè¯†åˆ«ç¾¤ç»“æ„

```text
é—®é¢˜ â†’ è¯†åˆ«è¿ç®— â†’ éªŒè¯ç¾¤å…¬ç† â†’ ç¡®å®šç¾¤ç±»å‹
```

**å…·ä½“æ€ç»´è¿‡ç¨‹**ï¼š

1. **è¯†åˆ«è¿ç®—**ï¼šåˆ†æé—®é¢˜ä¸­çš„äºŒå…ƒè¿ç®—
2. **éªŒè¯ç»“åˆå¾‹**ï¼šæ£€æŸ¥ $(a \cdot b) \cdot c = a \cdot (b \cdot c)$
3. **å¯»æ‰¾å•ä½å…ƒ**ï¼šæ‰¾åˆ°æ»¡è¶³ $e \cdot a = a \cdot e = a$ çš„å…ƒç´ 
4. **æ„é€ é€†å…ƒ**ï¼šä¸ºæ¯ä¸ªå…ƒç´ æ‰¾åˆ°é€†å…ƒ
5. **ç¡®å®šç¾¤ç±»å‹**ï¼šåˆ¤æ–­æ˜¯æœ‰é™ç¾¤ã€æ— é™ç¾¤ã€äº¤æ¢ç¾¤ç­‰

#### æ­¥éª¤2ï¼šåˆ†æç¾¤æ€§è´¨

```text
ç¾¤ç»“æ„ â†’ é˜¶æ•°åˆ†æ â†’ å­ç¾¤åˆ†æ â†’ åŒæ€åˆ†æ
```

**å…·ä½“æ€ç»´è¿‡ç¨‹**ï¼š

1. **é˜¶æ•°åˆ†æ**ï¼šè®¡ç®—ç¾¤çš„é˜¶æ•°å’Œå…ƒç´ çš„é˜¶æ•°
2. **å­ç¾¤åˆ†æ**ï¼šå¯»æ‰¾æ‰€æœ‰å­ç¾¤ï¼Œç‰¹åˆ«æ˜¯æ­£è§„å­ç¾¤
3. **åŒæ€åˆ†æ**ï¼šå¯»æ‰¾ç¾¤åŒæ€å’ŒåŒæ„
4. **ç»“æ„åˆ†æ**ï¼šåˆ†æç¾¤çš„ç»“æ„ï¼Œå¦‚ç›´ç§¯ã€åŠç›´ç§¯ç­‰

#### æ­¥éª¤3ï¼šåº”ç”¨ç¾¤è®ºå·¥å…·

```text
ç¾¤æ€§è´¨ â†’ æ‹‰æ ¼æœ—æ—¥å®šç† â†’ è¥¿ç½—å®šç† â†’ åŒæ„å®šç†
```

**å…·ä½“æ€ç»´è¿‡ç¨‹**ï¼š

1. **åº”ç”¨æ‹‰æ ¼æœ—æ—¥å®šç†**ï¼šåˆ©ç”¨å­ç¾¤é˜¶æ•°æ•´é™¤ç¾¤é˜¶æ•°
2. **åº”ç”¨è¥¿ç½—å®šç†**ï¼šåˆ†æp-å­ç¾¤çš„å­˜åœ¨æ€§å’Œæ•°é‡
3. **åº”ç”¨åŒæ„å®šç†**ï¼šå»ºç«‹ç¾¤ä¹‹é—´çš„åŒæ„å…³ç³»
4. **åº”ç”¨è¡¨ç¤ºè®º**ï¼šåˆ†æç¾¤çš„è¡¨ç¤º

### 2. è¯æ˜æ€ç»´è¿‡ç¨‹

#### æ‹‰æ ¼æœ—æ—¥å®šç†è¯æ˜

```text
1. å®šä¹‰å·¦é™ªé›†
2. è¯æ˜é™ªé›†åˆ’åˆ†
3. è¯æ˜é™ªé›†ç­‰åŠ¿
4. å¾—å‡ºé˜¶æ•°å…³ç³»
```

**è¯¦ç»†è¯æ˜æ­¥éª¤**ï¼š

**æ­¥éª¤1ï¼šå®šä¹‰å·¦é™ªé›†**:

- è®¾ $H$ æ˜¯ç¾¤ $G$ çš„å­ç¾¤
- å¯¹äº $g \in G$ï¼Œå®šä¹‰å·¦é™ªé›† $gH = \{gh : h \in H\}$

**æ­¥éª¤2ï¼šè¯æ˜é™ªé›†åˆ’åˆ†**:

- è¯æ˜ï¼š$g_1H = g_2H$ å½“ä¸”ä»…å½“ $g_1^{-1}g_2 \in H$
- è¯æ˜ï¼šä¸åŒçš„é™ªé›†ä¸ç›¸äº¤
- è¯æ˜ï¼šæ‰€æœ‰é™ªé›†çš„å¹¶é›†ç­‰äº $G$

**æ­¥éª¤3ï¼šè¯æ˜é™ªé›†ç­‰åŠ¿**:

- æ„é€ æ˜ å°„ $f: H \to gH$ï¼Œ$f(h) = gh$
- è¯æ˜ $f$ æ˜¯åŒå°„
- å› æ­¤ $|gH| = |H|$

**æ­¥éª¤4ï¼šå¾—å‡ºé˜¶æ•°å…³ç³»**:

- è®¾ $[G:H]$ è¡¨ç¤ºé™ªé›†ä¸ªæ•°
- åˆ™ $|G| = [G:H] \cdot |H|$
- å› æ­¤ $|H|$ æ•´é™¤ $|G|$

#### è¥¿ç½—å®šç†è¯æ˜

```text
1. å®šä¹‰p-å­ç¾¤
2. æ„é€ è¥¿ç½—p-å­ç¾¤
3. è¯æ˜å…±è½­æ€§è´¨
4. å¾—å‡ºè®¡æ•°å…¬å¼
```

**è¯¦ç»†è¯æ˜æ­¥éª¤**ï¼š

**æ­¥éª¤1ï¼šå®šä¹‰p-å­ç¾¤**:

- è®¾ $p$ æ˜¯ç´ æ•°ï¼Œ$p^k$ æ•´é™¤ $|G|$
- $p$-å­ç¾¤æ˜¯é˜¶æ•°ä¸º $p^k$ çš„å­ç¾¤
- è¥¿ç½— $p$-å­ç¾¤æ˜¯é˜¶æ•°ä¸º $p^{\alpha}$ çš„å­ç¾¤ï¼Œå…¶ä¸­ $p^{\alpha}$ æ˜¯ $|G|$ ä¸­ $p$ çš„æœ€é«˜å¹‚

**æ­¥éª¤2ï¼šæ„é€ è¥¿ç½—p-å­ç¾¤**:

- ä½¿ç”¨å½’çº³æ³•æ„é€ è¥¿ç½— $p$-å­ç¾¤
- åˆ©ç”¨ç¾¤ä½œç”¨ç†è®º
- æ„é€ ç¾¤åœ¨é™ªé›†ä¸Šçš„ä½œç”¨

**æ­¥éª¤3ï¼šè¯æ˜å…±è½­æ€§è´¨**:

- è¯æ˜ï¼šæ‰€æœ‰è¥¿ç½— $p$-å­ç¾¤å…±è½­
- ä½¿ç”¨ç¾¤ä½œç”¨ç†è®º
- åˆ†æå›ºå®šç‚¹çš„æ€§è´¨

**æ­¥éª¤4ï¼šå¾—å‡ºè®¡æ•°å…¬å¼**:

- è®¾ $n_p$ è¡¨ç¤ºè¥¿ç½— $p$-å­ç¾¤çš„ä¸ªæ•°
- è¯æ˜ï¼š$n_p \equiv 1 \pmod{p}$
- è¯æ˜ï¼š$n_p$ æ•´é™¤ $[G:N_G(P)]$ï¼Œå…¶ä¸­ $P$ æ˜¯è¥¿ç½— $p$-å­ç¾¤

#### ç¬¬ä¸€åŒæ„å®šç†è¯æ˜

```text
1. å®šä¹‰æ ¸å’Œåƒ
2. æ„é€ è‡ªç„¶åŒæ€
3. è¯æ˜åŒæ„æ˜ å°„
4. å»ºç«‹å¯¹åº”å…³ç³»
```

**è¯¦ç»†è¯æ˜æ­¥éª¤**ï¼š

**æ­¥éª¤1ï¼šå®šä¹‰æ ¸å’Œåƒ**:

- è®¾ $\phi: G \to H$ æ˜¯ç¾¤åŒæ€
- æ ¸ï¼š$\ker(\phi) = \{g \in G : \phi(g) = e_H\}$
- åƒï¼š$\operatorname{im}(\phi) = \{\phi(g) : g \in G\}$

**æ­¥éª¤2ï¼šæ„é€ è‡ªç„¶åŒæ€**:

- å®šä¹‰æ˜ å°„ $\psi: G/\ker(\phi) \to \operatorname{im}(\phi)$
- $\psi(g\ker(\phi)) = \phi(g)$

**æ­¥éª¤3ï¼šè¯æ˜åŒæ„æ˜ å°„**:

- è¯æ˜ $\psi$ æ˜¯è‰¯å®šä¹‰çš„
- è¯æ˜ $\psi$ æ˜¯åŒæ€
- è¯æ˜ $\psi$ æ˜¯å•å°„
- è¯æ˜ $\psi$ æ˜¯æ»¡å°„

**æ­¥éª¤4ï¼šå»ºç«‹å¯¹åº”å…³ç³»**:

- å› æ­¤ $G/\ker(\phi) \cong \operatorname{im}(\phi)$

### 3. æ¦‚å¿µç†è§£æ­¥éª¤

#### ç†è§£ç¾¤çš„æ¦‚å¿µ

```text
1. é›†åˆ + è¿ç®—
2. æ»¡è¶³ç¾¤å…¬ç†
3. æŠ½è±¡ä»£æ•°ç»“æ„
4. å…·ä½“å®ä¾‹éªŒè¯
```

**å…·ä½“ç†è§£è¿‡ç¨‹**ï¼š

**é˜¶æ®µ1ï¼šå…·ä½“å®ä¾‹**:

- ä»ç†Ÿæ‚‰çš„ä¾‹å­å¼€å§‹ï¼šæ•´æ•°åŠ æ³•ç¾¤
- è§‚å¯Ÿè¿ç®—çš„æ€§è´¨ï¼šç»“åˆå¾‹ã€å•ä½å…ƒã€é€†å…ƒ
- ç†è§£ç¾¤å…¬ç†çš„å¿…è¦æ€§

**é˜¶æ®µ2ï¼šæŠ½è±¡åŒ–**:

- å°†å…·ä½“æ€§è´¨æŠ½è±¡ä¸ºå…¬ç†
- ç†è§£å…¬ç†çš„ç‹¬ç«‹æ€§
- æŒæ¡ç¾¤çš„åŸºæœ¬æ€§è´¨

**é˜¶æ®µ3ï¼šåº”ç”¨éªŒè¯**:

- ç”¨å…¬ç†éªŒè¯æ–°çš„ä¾‹å­
- å‘ç°ç¾¤çš„åº”ç”¨åœºæ™¯
- ç†è§£ç¾¤çš„æ™®éæ€§

#### ç†è§£å­ç¾¤æ¦‚å¿µ

```text
1. å­é›† + ç»§æ‰¿è¿ç®—
2. å°é—­æ€§éªŒè¯
3. ç¾¤å…¬ç†éªŒè¯
4. å­ç¾¤åˆ¤å®š
```

**å…·ä½“ç†è§£è¿‡ç¨‹**ï¼š

**é˜¶æ®µ1ï¼šå­é›†æ€§è´¨**:

- å­ç¾¤æ˜¯åŸç¾¤çš„å­é›†
- ç»§æ‰¿åŸç¾¤çš„è¿ç®—
- ä¿æŒç¾¤çš„ç»“æ„

**é˜¶æ®µ2ï¼šå°é—­æ€§**:

- å­ç¾¤å¯¹è¿ç®—å°é—­
- å•ä½å…ƒåœ¨å­ç¾¤ä¸­
- é€†å…ƒåœ¨å­ç¾¤ä¸­

**é˜¶æ®µ3ï¼šåˆ¤å®šæ–¹æ³•**:

- ä½¿ç”¨å­ç¾¤åˆ¤å®šå®šç†
- éªŒè¯ä¸‰ä¸ªæ¡ä»¶
- ç†è§£åˆ¤å®šå®šç†çš„è¯æ˜

### 4. é—®é¢˜è§£å†³ç­–ç•¥

#### ç¾¤è®ºé—®é¢˜åˆ†ç±»

**ç±»å‹1ï¼šç¾¤çš„å­˜åœ¨æ€§é—®é¢˜**:

- ç­–ç•¥ï¼šæ„é€ å…·ä½“çš„ç¾¤
- æ–¹æ³•ï¼šä½¿ç”¨ç›´ç§¯ã€åŠç›´ç§¯ç­‰æ„é€ 
- å·¥å…·ï¼šæ‹‰æ ¼æœ—æ—¥å®šç†ã€è¥¿ç½—å®šç†

**ç±»å‹2ï¼šç¾¤çš„ç»“æ„é—®é¢˜**:

- ç­–ç•¥ï¼šåˆ†æç¾¤çš„ç»“æ„
- æ–¹æ³•ï¼šå¯»æ‰¾æ­£è§„å­ç¾¤ã€å•†ç¾¤
- å·¥å…·ï¼šåŒæ„å®šç†ã€è¡¨ç¤ºè®º

**ç±»å‹3ï¼šç¾¤çš„æ€§è´¨é—®é¢˜**:

- ç­–ç•¥ï¼šåˆ©ç”¨ç¾¤çš„æ€§è´¨
- æ–¹æ³•ï¼šåº”ç”¨ç¾¤è®ºå®šç†
- å·¥å…·ï¼šç¾¤ä½œç”¨ã€è½¨é“å…¬å¼

#### å¸¸è§æ€ç»´è¯¯åŒº

**è¯¯åŒº1ï¼šå¿½ç•¥ç¾¤å…¬ç†**:

- é—®é¢˜ï¼šåªéªŒè¯éƒ¨åˆ†å…¬ç†
- è§£å†³ï¼šç³»ç»ŸéªŒè¯æ‰€æœ‰å…¬ç†
- ä¾‹å­ï¼šå¿˜è®°éªŒè¯ç»“åˆå¾‹

**è¯¯åŒº2ï¼šæ··æ·†ç¾¤ç±»å‹**:

- é—®é¢˜ï¼šæ··æ·†æœ‰é™ç¾¤å’Œæ— é™ç¾¤
- è§£å†³ï¼šæ˜ç¡®ç¾¤çš„ç±»å‹
- ä¾‹å­ï¼šåœ¨æ— é™ç¾¤ä¸­åº”ç”¨æœ‰é™ç¾¤å®šç†

**è¯¯åŒº3ï¼šå¿½è§†ç¾¤ä½œç”¨**:

- é—®é¢˜ï¼šå¿½ç•¥ç¾¤ä½œç”¨çš„é‡è¦æ€§
- è§£å†³ï¼šå……åˆ†åˆ©ç”¨ç¾¤ä½œç”¨
- ä¾‹å­ï¼šè¥¿ç½—å®šç†çš„è¯æ˜

### 5. ç®—æ³•æ€ç»´åˆ†æ

#### ç¾¤è®ºç®—æ³•è®¾è®¡

**ç®—æ³•1ï¼šç¾¤å…ƒç´ é˜¶æ•°è®¡ç®—**:

```python
def element_order(group, element):
    """è®¡ç®—ç¾¤å…ƒç´ çš„é˜¶æ•°"""
    if element == group.identity:
        return 1
    
    current = element
    order = 1
    
    while current != group.identity:
        current = group.multiply(current, element)
        order += 1
        
        if order > group.order:
            return float('inf')  # æ— é™é˜¶
    
    return order
```

**ç®—æ³•2ï¼šå­ç¾¤ç”Ÿæˆ**:

```python
def generate_subgroup(group, generators):
    """ç”±ç”Ÿæˆå…ƒç”Ÿæˆå­ç¾¤"""
    subgroup = {group.identity}
    frontier = set(generators)
    
    while frontier:
        new_elements = set()
        for g in frontier:
            for h in subgroup:
                new_element = group.multiply(g, h)
                if new_element not in subgroup:
                    new_elements.add(new_element)
        
        subgroup.update(new_elements)
        frontier = new_elements
    
    return subgroup
```

**ç®—æ³•3ï¼šç¾¤åŒæ„æ£€æµ‹**:

```python
def is_isomorphic(group1, group2):
    """æ£€æµ‹ä¸¤ä¸ªç¾¤æ˜¯å¦åŒæ„"""
    if group1.order != group2.order:
        return False
    
    # æ£€æŸ¥å…ƒç´ é˜¶æ•°åˆ†å¸ƒ
    order_dist1 = get_order_distribution(group1)
    order_dist2 = get_order_distribution(group2)
    
    if order_dist1 != order_dist2:
        return False
    
    # å°è¯•æ„é€ åŒæ„æ˜ å°„
    return try_construct_isomorphism(group1, group2)
```

#### è®¡ç®—å¤æ‚æ€§åˆ†æ

**ç¾¤è®ºé—®é¢˜çš„å¤æ‚æ€§**ï¼š

- **ç¾¤åŒæ„é—®é¢˜**ï¼šåœ¨ä¸€èˆ¬æƒ…å†µä¸‹æ˜¯NPå›°éš¾çš„
- **å­ç¾¤é—®é¢˜**ï¼šå¯¹äºæœ‰é™ç¾¤æ˜¯å¤šé¡¹å¼æ—¶é—´
- **å…ƒç´ é˜¶æ•°**ï¼šå¯¹äºæœ‰é™ç¾¤æ˜¯å¤šé¡¹å¼æ—¶é—´
- **ç¾¤è¡¨ç¤º**ï¼šå¯¹äºæœ‰é™ç¾¤æ˜¯å¤šé¡¹å¼æ—¶é—´

**ä¼˜åŒ–ç­–ç•¥**ï¼š

- åˆ©ç”¨ç¾¤çš„ç‰¹æ®Šæ€§è´¨
- ä½¿ç”¨ç¾¤è®ºå®šç†ç®€åŒ–è®¡ç®—
- é‡‡ç”¨å¯å‘å¼ç®—æ³•
- åˆ©ç”¨ç¾¤ä½œç”¨ç†è®º

## ğŸŒ åº”ç”¨åœºæ™¯è¡¨å¾

### 1. è‡ªç„¶ç§‘å­¦åº”ç”¨

#### ç‰©ç†å­¦åº”ç”¨

- **å¯¹ç§°æ€§**: æ™¶ä½“å­¦ç‚¹ç¾¤
  - 32ä¸ªæ™¶ä½“å­¦ç‚¹ç¾¤åˆ†ç±»
  - åœ¨ææ–™ç§‘å­¦ä¸­çš„åº”ç”¨
  - é¢„æµ‹ææ–™çš„ç‰©ç†æ€§è´¨
- **é‡å­åŠ›å­¦**: æç¾¤è¡¨ç¤ºè®º
  - SU(2)ç¾¤åœ¨è‡ªæ—‹ä¸­çš„åº”ç”¨
  - SO(3)ç¾¤åœ¨è§’åŠ¨é‡ä¸­çš„åº”ç”¨
  - æç¾¤åœ¨é‡å­åœºè®ºä¸­çš„åº”ç”¨
- **ç›¸å¯¹è®º**: æ´›ä¼¦å…¹ç¾¤
  - æ—¶ç©ºå˜æ¢ç¾¤
  - åœ¨ç²’å­ç‰©ç†ä¸­çš„åº”ç”¨
  - è§„èŒƒç†è®ºçš„åŸºç¡€
- **ç²’å­ç‰©ç†**: è§„èŒƒç¾¤
  - U(1)ç¾¤ï¼šç”µç£ç›¸äº’ä½œç”¨
  - SU(2)ç¾¤ï¼šå¼±ç›¸äº’ä½œç”¨
  - SU(3)ç¾¤ï¼šå¼ºç›¸äº’ä½œç”¨

#### åŒ–å­¦åº”ç”¨

- **åˆ†å­å¯¹ç§°æ€§**: ç‚¹ç¾¤ç†è®º
  - åˆ†å­è½¨é“ç†è®º
  - é¢„æµ‹åˆ†å­æ€§è´¨
  - å…‰è°±å­¦åˆ†æ
- **å…‰è°±å­¦**: ç¾¤è¡¨ç¤ºè®º
  - çº¢å¤–å…‰è°±åˆ†æ
  - æ‹‰æ›¼å…‰è°±åˆ†æ
  - ç”µå­å…‰è°±åˆ†æ
- **æ™¶ä½“å­¦**: ç©ºé—´ç¾¤
  - 230ä¸ªç©ºé—´ç¾¤åˆ†ç±»
  - Xå°„çº¿è¡å°„åˆ†æ
  - æ™¶ä½“ç»“æ„é¢„æµ‹
- **æ‰‹æ€§**: å¯¹ç§°æ€§ç ´ç¼º
  - æ‰‹æ€§åˆ†å­è¯†åˆ«
  - ä¸å¯¹ç§°åˆæˆ
  - è¯ç‰©è®¾è®¡

### 2. å·¥ç¨‹æŠ€æœ¯åº”ç”¨

#### å¯†ç å­¦åº”ç”¨

```haskell
-- æ¤­åœ†æ›²çº¿å¯†ç å­¦
data EllipticCurve = EC {
    a :: Integer,
    b :: Integer,
    p :: Integer
}

data ECPoint = Point {
    x :: Integer,
    y :: Integer
} | Infinity

instance Group ECPoint where
    one = Infinity
    inv Infinity = Infinity
    inv (Point x y) = Point x (mod (-y) p)
    -- ç‚¹åŠ æ³•å®ç°
    mul Infinity _ = Infinity
    mul _ Infinity = Infinity
    mul (Point x1 y1) (Point x2 y2)
        | x1 == x2 && y1 == mod (-y2) p = Infinity
        | otherwise = addPoints (Point x1 y1) (Point x2 y2)

-- ç‚¹åŠ æ³•ç®—æ³•
addPoints :: ECPoint -> ECPoint -> ECPoint
addPoints (Point x1 y1) (Point x2 y2) = Point x3 y3
  where
    lambda = if x1 == x2 
             then mod ((3 * x1^2 + a) * invMod (2 * y1) p) p
             else mod ((y2 - y1) * invMod (x2 - x1) p) p
    x3 = mod (lambda^2 - x1 - x2) p
    y3 = mod (lambda * (x1 - x3) - y1) p

-- æ¨¡é€†å…ƒè®¡ç®—
invMod :: Integer -> Integer -> Integer
invMod a m = fst $ extendedGCD a m

-- æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•
extendedGCD :: Integer -> Integer -> (Integer, Integer, Integer)
extendedGCD a b = go a b 1 0 0 1
  where
    go r0 r1 s0 s1 t0 t1
        | r1 == 0 = (s0, t0, r0)
        | otherwise = go r1 r2 s1 s2 t1 t2
      where
        q = r0 `div` r1
        r2 = r0 - q * r1
        s2 = s0 - q * s1
        t2 = t0 - q * t1
```

#### ç¼–ç ç†è®º

- **çº é”™ç **: ç¾¤ç ç†è®º
  - æ±‰æ˜ç ï¼šåŸºäºç¾¤ç»“æ„
  - BCHç ï¼šå¾ªç¯ç¾¤åº”ç”¨
  - Reed-Solomonç ï¼šæœ‰é™åŸŸç¾¤
- **çº¿æ€§ç **: å‘é‡ç©ºé—´ç¾¤
  - ç”ŸæˆçŸ©é˜µå’Œæ ¡éªŒçŸ©é˜µ
  - ç¾¤åŒæ„æ€§è´¨
  - ç¼–ç å’Œè¯‘ç ç®—æ³•
- **å¾ªç¯ç **: å¾ªç¯ç¾¤ç»“æ„
  - å¤šé¡¹å¼ç¯ç»“æ„
  - ç”Ÿæˆå¤šé¡¹å¼
  - ç³»ç»Ÿç¼–ç æ–¹æ³•

```rust
// æ±‰æ˜ç å®ç°
pub struct HammingCode {
    n: usize,  // ç é•¿
    k: usize,  // ä¿¡æ¯ä½é•¿åº¦
    r: usize,  // æ ¡éªŒä½é•¿åº¦
}

impl HammingCode {
    pub fn new(r: usize) -> Self {
        let n = (1 << r) - 1;
        let k = n - r;
        HammingCode { n, k, r }
    }
    
    // ç¼–ç 
    pub fn encode(&self, data: &[u8]) -> Vec<u8> {
        let mut codeword = vec![0; self.n];
        
        // æ”¾ç½®ä¿¡æ¯ä½
        let mut data_idx = 0;
        for i in 0..self.n {
            if !self.is_power_of_2(i + 1) {
                codeword[i] = data[data_idx];
                data_idx += 1;
            }
        }
        
        // è®¡ç®—æ ¡éªŒä½
        for i in 0..self.r {
            let parity_pos = (1 << i) - 1;
            let mut parity = 0;
            for j in 0..self.n {
                if (j + 1) & (1 << i) != 0 && j != parity_pos {
                    parity ^= codeword[j];
                }
            }
            codeword[parity_pos] = parity;
        }
        
        codeword
    }
    
    // è§£ç 
    pub fn decode(&self, received: &[u8]) -> Result<Vec<u8>, String> {
        let mut syndrome = 0;
        for i in 0..self.r {
            let mut parity = 0;
            for j in 0..self.n {
                if (j + 1) & (1 << i) != 0 {
                    parity ^= received[j];
                }
            }
            if parity != 0 {
                syndrome |= 1 << i;
            }
        }
        
        if syndrome == 0 {
            // æ— é”™è¯¯
            return Ok(self.extract_data(received));
        }
        
        // å•æ¯”ç‰¹é”™è¯¯çº æ­£
        if syndrome <= self.n {
            let mut corrected = received.to_vec();
            corrected[syndrome - 1] ^= 1;
            return Ok(self.extract_data(&corrected));
        }
        
        Err("æ— æ³•çº æ­£çš„é”™è¯¯".to_string())
    }
    
    fn is_power_of_2(&self, n: usize) -> bool {
        n != 0 && (n & (n - 1)) == 0
    }
    
    fn extract_data(&self, codeword: &[u8]) -> Vec<u8> {
        let mut data = Vec::new();
        for i in 0..self.n {
            if !self.is_power_of_2(i + 1) {
                data.push(codeword[i]);
            }
        }
        data
    }
}
```

### 3. è®¡ç®—æœºç§‘å­¦åº”ç”¨

#### ç®—æ³•è®¾è®¡

```python
# ç½®æ¢ç¾¤åœ¨ç®—æ³•ä¸­çš„åº”ç”¨
class PermutationGroup:
    def __init__(self, n):
        self.n = n
        self.identity = list(range(n))
    
    def compose(self, p1, p2):
        """ç½®æ¢çš„å¤åˆ"""
        return [p1[p2[i]] for i in range(self.n)]
    
    def inverse(self, p):
        """ç½®æ¢çš„é€†"""
        inv = [0] * self.n
        for i in range(self.n):
            inv[p[i]] = i
        return inv
    
    def generate_cycle(self, cycle):
        """ç”Ÿæˆå¾ªç¯ç½®æ¢"""
        perm = self.identity.copy()
        for i in range(len(cycle) - 1):
            perm[cycle[i]] = cycle[i + 1]
        perm[cycle[-1]] = cycle[0]
        return perm
    
    def decompose_cycles(self, perm):
        """åˆ†è§£ä¸ºä¸ç›¸äº¤å¾ªç¯"""
        visited = [False] * self.n
        cycles = []
        
        for i in range(self.n):
            if not visited[i]:
                cycle = []
                j = i
                while not visited[j]:
                    visited[j] = True
                    cycle.append(j)
                    j = perm[j]
                if len(cycle) > 1:
                    cycles.append(cycle)
        
        return cycles

# åœ¨æ’åºç®—æ³•ä¸­çš„åº”ç”¨
def cycle_sort(arr):
    """åŸºäºç½®æ¢ç¾¤çš„å¾ªç¯æ’åº"""
    n = len(arr)
    visited = [False] * n
    
    for i in range(n):
        if visited[i]:
            continue
            
        cycle_start = i
        cycle = []
        j = i
        
        # æ‰¾åˆ°å¾ªç¯
        while not visited[j]:
            visited[j] = True
            cycle.append(j)
            j = arr[j]
        
        # æ‰§è¡Œå¾ªç¯ç½®æ¢
        if len(cycle) > 1:
            for k in range(len(cycle) - 1):
                arr[cycle[k]], arr[cycle[k + 1]] = arr[cycle[k + 1]], arr[cycle[k]]
    
    return arr
```

#### æ•°æ®ç»“æ„ä¼˜åŒ–

- **å“ˆå¸Œè¡¨**: ç¾¤è¿ç®—ä¼˜åŒ–
  - åˆ©ç”¨ç¾¤çš„æ€§è´¨ä¼˜åŒ–å“ˆå¸Œå‡½æ•°
  - ç¾¤åŒæ„åœ¨æ•°æ®ç»“æ„ä¸­çš„åº”ç”¨
  - ç¾¤è¿ç®—çš„å¹¶è¡ŒåŒ–
- **å›¾è®º**: è‡ªåŒæ„ç¾¤
  - å›¾çš„å¯¹ç§°æ€§åˆ†æ
  - å›¾åŒæ„ç®—æ³•
  - å›¾çš„è‡ªåŒæ„ç¾¤è®¡ç®—
- **ç»„åˆä¼˜åŒ–**: å¯¹ç§°ç¾¤
  - æ’åˆ—ç»„åˆé—®é¢˜
  - å¯¹ç§°æ€§åœ¨ä¼˜åŒ–ä¸­çš„åº”ç”¨
  - ç¾¤è®ºå¯å‘å¼ç®—æ³•

### 4. æ•°å­¦å†…éƒ¨åº”ç”¨

#### ä»£æ•°å‡ ä½•

- **ä»£æ•°ç°‡**: è‡ªåŒæ„ç¾¤
  - ä»£æ•°ç°‡çš„å¯¹ç§°æ€§
  - è‡ªåŒæ„ç¾¤çš„è®¡ç®—
  - åœ¨ä»£æ•°å‡ ä½•ä¸­çš„åº”ç”¨
- **æ¦‚å½¢**: ä¼½ç½—ç“¦ç¾¤
  - æ¦‚å½¢çš„ä¼½ç½—ç“¦ç¾¤
  - åœ¨ç®—æœ¯å‡ ä½•ä¸­çš„åº”ç”¨
  - æœ—å…°å…¹çº²é¢†çš„åŸºç¡€
- **ä¸ŠåŒè°ƒ**: ç¾¤ä¸ŠåŒè°ƒ
  - ç¾¤çš„ä¸ŠåŒè°ƒç†è®º
  - åœ¨ä»£æ•°æ‹“æ‰‘ä¸­çš„åº”ç”¨
  - åŒè°ƒä»£æ•°çš„åŸºç¡€

#### æ•°è®º

- **ç±»åŸŸè®º**: ä¼½ç½—ç“¦ç¾¤
  - æ•°åŸŸçš„ä¼½ç½—ç“¦ç¾¤
  - ç±»åŸŸè®ºçš„åŸºæœ¬å®šç†
  - åœ¨æ•°è®ºä¸­çš„åº”ç”¨
- **æ¤­åœ†æ›²çº¿**: æŒ ç‚¹ç¾¤
  - æ¤­åœ†æ›²çº¿çš„æŒ ç‚¹ç¾¤
  - åœ¨å¯†ç å­¦ä¸­çš„åº”ç”¨
  - è´¹é©¬å¤§å®šç†çš„è¯æ˜
- **æ¨¡å½¢å¼**: æ¨¡ç¾¤
  - æ¨¡å½¢å¼çš„å˜æ¢ç¾¤
  - åœ¨æ•°è®ºä¸­çš„åº”ç”¨
  - æœ—å…°å…¹çº²é¢†çš„æ ¸å¿ƒ

### 5. å®é™…åº”ç”¨æ¡ˆä¾‹

#### æ¡ˆä¾‹1ï¼šæ™¶ä½“å­¦ç‚¹ç¾¤

```lean
-- æ™¶ä½“å­¦ç‚¹ç¾¤åˆ†ç±»
structure CrystallographicPointGroup where
  order : â„•
  symmetry_operations : List (Matrix â„ 3 3)
  schoenflies_symbol : String
  international_symbol : String

-- 32ä¸ªæ™¶ä½“å­¦ç‚¹ç¾¤
def point_groups : List CrystallographicPointGroup := [
  -- ä¸‰æ–œæ™¶ç³»
  âŸ¨1, [identity_matrix], "Câ‚", "1"âŸ©,
  âŸ¨2, [identity_matrix, rotation_180], "Câ‚‚", "2"âŸ©,
  
  -- å•æ–œæ™¶ç³»
  âŸ¨2, [identity_matrix, reflection_yz], "Câ‚›", "m"âŸ©,
  âŸ¨4, [identity_matrix, rotation_180, reflection_yz, rotation_180_reflection], "Câ‚‚â‚•", "2/m"âŸ©,
  
  -- æ­£äº¤æ™¶ç³»
  âŸ¨4, [identity_matrix, rotation_180_x, rotation_180_y, rotation_180_z], "Dâ‚‚", "222"âŸ©,
  âŸ¨8, [identity_matrix, rotation_180_x, rotation_180_y, rotation_180_z, 
       reflection_yz, reflection_xz, reflection_xy, inversion], "Dâ‚‚â‚•", "mmm"âŸ©
  -- ... å…¶ä»–ç‚¹ç¾¤
]
```

#### æ¡ˆä¾‹2ï¼šé‡å­åŠ›å­¦ä¸­çš„æç¾¤

```haskell
-- SU(2)ç¾¤åœ¨é‡å­åŠ›å­¦ä¸­çš„åº”ç”¨
data SU2 = SU2 {
    alpha :: Complex Double,
    beta :: Complex Double
} deriving (Show)

instance Group SU2 where
    one = SU2 1 0
    inv (SU2 a b) = SU2 (conjugate a) (-b)
    mul (SU2 a1 b1) (SU2 a2 b2) = SU2 (a1 * a2 - conjugate b1 * b2) 
                                           (a1 * b2 + b1 * conjugate a2)

-- è‡ªæ—‹1/2ç²’å­çš„çŠ¶æ€
data SpinState = SpinUp | SpinDown deriving (Show)

-- è‡ªæ—‹ç®—ç¬¦
spinX :: SpinState -> SpinState
spinX SpinUp = SpinDown
spinX SpinDown = SpinUp

spinY :: SpinState -> SpinState
spinY SpinUp = SpinDown
spinY SpinDown = SpinUp

spinZ :: SpinState -> SpinState
spinZ SpinUp = SpinUp
spinZ SpinDown = SpinDown

-- æ³¡åˆ©çŸ©é˜µ
pauliX :: Matrix 2 2 Complex
pauliX = fromList [[0, 1], [1, 0]]

pauliY :: Matrix 2 2 Complex
pauliY = fromList [[0, -i], [i, 0]]

pauliZ :: Matrix 2 2 Complex
pauliZ = fromList [[1, 0], [0, -1]]
```

#### æ¡ˆä¾‹3ï¼šå¯†ç å­¦ä¸­çš„æ¤­åœ†æ›²çº¿

```rust
// æ¤­åœ†æ›²çº¿æ•°å­—ç­¾åç®—æ³• (ECDSA)
pub struct ECDSA {
    curve: EllipticCurve,
    private_key: BigUint,
    public_key: ECPoint,
}

impl ECDSA {
    pub fn new(curve: EllipticCurve, private_key: BigUint) -> Self {
        let public_key = curve.scalar_multiply(&curve.generator, &private_key);
        ECDSA {
            curve,
            private_key,
            public_key,
        }
    }
    
    pub fn sign(&self, message: &[u8]) -> (BigUint, BigUint) {
        let hash = sha256(message);
        let z = BigUint::from_bytes_be(&hash);
        
        loop {
            let k = self.generate_random_k();
            let point = self.curve.scalar_multiply(&self.curve.generator, &k);
            
            if point.x == BigUint::zero() {
                continue;
            }
            
            let r = point.x % &self.curve.order;
            if r == BigUint::zero() {
                continue;
            }
            
            let s = (k.inv_mod(&self.curve.order).unwrap() * 
                    (&z + &r * &self.private_key)) % &self.curve.order;
            
            if s != BigUint::zero() {
                return (r, s);
            }
        }
    }
    
    pub fn verify(&self, message: &[u8], signature: (BigUint, BigUint)) -> bool {
        let (r, s) = signature;
        let hash = sha256(message);
        let z = BigUint::from_bytes_be(&hash);
        
        let w = s.inv_mod(&self.curve.order).unwrap();
        let u1 = (&z * &w) % &self.curve.order;
        let u2 = (&r * &w) % &self.curve.order;
        
        let point1 = self.curve.scalar_multiply(&self.curve.generator, &u1);
        let point2 = self.curve.scalar_multiply(&self.public_key, &u2);
        let point = self.curve.add_points(&point1, &point2);
        
        point.x % &self.curve.order == r
    }
}
```

## ğŸ”— çŸ¥è¯†å…³è”ç½‘ç»œ

### ä¸å…¶ä»–æ•°å­¦åˆ†æ”¯çš„è”ç³»

#### ä¸çº¿æ€§ä»£æ•°çš„è”ç³»

- ç¾¤è¡¨ç¤ºè®º
- çŸ©é˜µç¾¤
- çº¿æ€§å˜æ¢ç¾¤

#### ä¸æ‹“æ‰‘å­¦çš„è”ç³»

- åŸºæœ¬ç¾¤
- åŒä¼¦ç¾¤
- åŒè°ƒç¾¤

#### ä¸å‡ ä½•å­¦çš„è”ç³»

- ç­‰è·å˜æ¢ç¾¤
- å°„å½±å˜æ¢ç¾¤
- æç¾¤

### ç†è®ºå‘å±•è„‰ç»œ

#### ä»å…·ä½“åˆ°æŠ½è±¡

```text
ç½®æ¢ç¾¤ â†’ æŠ½è±¡ç¾¤ â†’ ç¾¤è¡¨ç¤º â†’ èŒƒç•´è®º
```

#### ä»æœ‰é™åˆ°æ— é™

```text
æœ‰é™ç¾¤ â†’ æ— é™ç¾¤ â†’ æç¾¤ â†’ ä»£æ•°ç¾¤
```

#### ä»äº¤æ¢åˆ°éäº¤æ¢

```text
äº¤æ¢ç¾¤ â†’ éäº¤æ¢ç¾¤ â†’ ç®€å•ç¾¤ â†’ æ•£åœ¨ç¾¤
```

## ğŸ“ˆ ç°ä»£å‘å±•å‰æ²¿

### 1. å‡ ä½•ç¾¤è®º

- **åŒæ›²ç¾¤**: è´Ÿæ›²ç‡å‡ ä½•
- **CAT(0)ç¾¤**: éæ­£æ›²ç‡
- **è‡ªåŠ¨æœºç¾¤**: è®¡ç®—å¤æ‚æ€§

### 2. è¡¨ç¤ºè®º

- **ç‰¹å¾æ ‡ç†è®º**: æœ‰é™ç¾¤è¡¨ç¤º
- **æç¾¤è¡¨ç¤º**: æ— é™ç»´è¡¨ç¤º
- **æ¨¡è¡¨ç¤º**: ç‰¹å¾pè¡¨ç¤º

### 3. ç»„åˆç¾¤è®º

- **è‡ªç”±ç¾¤**: ç»„åˆç»“æ„
- **åŒæ›²ç¾¤**: å‡ ä½•æ€§è´¨
- **è‡ªåŠ¨æœºç¾¤**: è®¡ç®—æ€§è´¨

### 4. ä»£æ•°ç¾¤è®º

- **çº¿æ€§ä»£æ•°ç¾¤**: ä»£æ•°å‡ ä½•
- **ç®—æœ¯ç¾¤**: æ•°è®ºåº”ç”¨
- **pè¿›ç¾¤**: å±€éƒ¨ç†è®º

## ğŸ¯ å­¦ä¹ è·¯å¾„å»ºè®®

### åˆå­¦è€…è·¯å¾„

1. **åŸºç¡€æ¦‚å¿µ**: ç¾¤çš„å®šä¹‰å’ŒåŸºæœ¬æ€§è´¨
2. **é‡è¦ä¾‹å­**: å¯¹ç§°ç¾¤ã€å¾ªç¯ç¾¤ã€äºŒé¢ä½“ç¾¤
3. **åŸºæœ¬å®šç†**: æ‹‰æ ¼æœ—æ—¥å®šç†ã€è¥¿ç½—å®šç†
4. **åº”ç”¨å®ä¾‹**: å¯¹ç§°æ€§ã€ç¼–ç ç†è®º

### è¿›é˜¶è·¯å¾„

1. **è¡¨ç¤ºè®º**: ç¾¤è¡¨ç¤ºå’Œç‰¹å¾æ ‡
2. **æç¾¤**: è¿ç»­ç¾¤ç†è®º
3. **å‡ ä½•ç¾¤è®º**: ç¾¤ä¸å‡ ä½•çš„è”ç³»
4. **ç°ä»£åº”ç”¨**: å¯†ç å­¦ã€ç‰©ç†åº”ç”¨

### ç ”ç©¶è·¯å¾„

1. **å‰æ²¿ç†è®º**: å‡ ä½•ç¾¤è®ºã€è¡¨ç¤ºè®º
2. **äº¤å‰åº”ç”¨**: ä»£æ•°å‡ ä½•ã€æ•°è®º
3. **è®¡ç®—ç¾¤è®º**: ç®—æ³•å’Œè½¯ä»¶
4. **å¼€æ”¾é—®é¢˜**: æœªè§£å†³çš„ç¾¤è®ºé—®é¢˜

## ğŸŒŸ æ€»ç»“

ç¾¤è®ºä½œä¸ºç°ä»£ä»£æ•°å­¦çš„æ ¸å¿ƒï¼Œä¸ä»…æä¾›äº†ç»Ÿä¸€çš„æ•°å­¦è¯­è¨€ï¼Œè¿˜åœ¨å„ä¸ªé¢†åŸŸå‘æŒ¥ç€é‡è¦ä½œç”¨ã€‚ä»åŸºç¡€çš„å¯¹ç§°æ€§ç ”ç©¶åˆ°å‰æ²¿çš„å‡ ä½•ç¾¤è®ºï¼Œç¾¤è®ºçš„å‘å±•å±•ç°äº†æ•°å­¦çš„æ·±åˆ»æ€§å’Œæ™®é€‚æ€§ã€‚

é€šè¿‡å¤šè¡¨å¾çš„å­¦ä¹ æ–¹æ³•ï¼Œæˆ‘ä»¬å¯ä»¥ä»ä¸åŒè§’åº¦ç†è§£ç¾¤è®ºï¼š

- **å†å²è§’åº¦**: äº†è§£ç¾¤è®ºçš„å‘å±•å†ç¨‹
- **ç»“æ„è§’åº¦**: æŒæ¡ç¾¤çš„åŸºæœ¬æ€§è´¨
- **åº”ç”¨è§’åº¦**: è®¤è¯†ç¾¤è®ºçš„å®é™…ä»·å€¼
- **å‘å±•è§’åº¦**: å…³æ³¨ç¾¤è®ºçš„ç°ä»£å‘å±•

ç¾¤è®ºå°†ç»§ç»­åœ¨æ•°å­¦å’Œå…¶ä»–ç§‘å­¦é¢†åŸŸå‘æŒ¥é‡è¦ä½œç”¨ï¼Œä¸ºäººç±»è®¤è¯†ä¸–ç•Œæä¾›å¼ºå¤§çš„å·¥å…·ã€‚

---

**ç›¸å…³æ–‡æ¡£**:

- [ç¯è®º-å¢å¼ºç‰ˆ](../ç¯è®º/02-ç¯è®º-å¢å¼ºç‰ˆ.md)
- [åŸŸè®º-å¢å¼ºç‰ˆ](03-åŸŸè®º-å¢å¼ºç‰ˆ.md)
- [æä»£æ•°-å¢å¼ºç‰ˆ](../æä»£æ•°/05-æä»£æ•°-å¢å¼ºç‰ˆ.md)
- [èŒƒç•´è®º-å¢å¼ºç‰ˆ](../èŒƒç•´è®º/06-èŒƒç•´è®º-å¢å¼ºç‰ˆ.md)
- [ä»£æ•°å‡ ä½•-å¢å¼ºç‰ˆ](../04-å‡ ä½•å­¦/05-ä»£æ•°å‡ ä½•-å¢å¼ºç‰ˆ.md)
- [è¡¨ç¤ºè®º-é«˜çº§ä¸»é¢˜](../è¡¨ç¤ºè®º/è¡¨ç¤ºè®º-é«˜çº§ä¸»é¢˜.md)

## æœ¯è¯­å¯¹ç…§è¡¨ / Terminology Table

| ä¸­æ–‡ | English |
|---|---|
| ç¾¤ | Group |
| å­ç¾¤ | Subgroup |
| æ­£è§„å­ç¾¤ | Normal subgroup |
| å•†ç¾¤ | Quotient group |
| åŒæ€ | Homomorphism |
| åŒæ„ | Isomorphism |
| æ ¸ | Kernel |
| åƒ | Image |
| å¯¹ç§°ç¾¤/ç½®æ¢ç¾¤ | Symmetric group/Permutation group |
| å¾ªç¯ç¾¤ | Cyclic group |
| é˜¶ | Order (of group / element) |
| æ‹‰æ ¼æœ—æ—¥å®šç† | Lagrange's theorem |
| è¥¿ç½—å®šç† | Sylow theorems |
| ç›´ç§¯ | Direct product |
| è‡ªåŒæ„ | Automorphism |
| è¡¨ç¤º | Representation |

## å¤šè¡¨å¾æ–¹å¼ä¸å›¾å»ºæ¨¡

### ç¾¤è®ºçš„å¤šè¡¨å¾ç³»ç»Ÿ

```python
import numpy as np
import networkx as nx
import matplotlib.pyplot as plt
from typing import Dict, List, Tuple, Any
import math

class GroupTheorySystem:
    """ç¾¤è®ºå¤šè¡¨å¾ç³»ç»Ÿ"""
    
    def __init__(self):
        self.groups = {}
        self.representations = {}
        
    def add_group(self, name: str, elements: List, operation: Dict) -> None:
        """æ·»åŠ ç¾¤"""
        self.groups[name] = {
            'elements': elements,
            'operation': operation,
            'order': len(elements)
        }
        
    def algebraic_representation(self, group_name: str) -> Dict:
        """ä»£æ•°è¡¨å¾"""
        group = self.groups[group_name]
        return {
            'elements': group['elements'],
            'operation_table': self._create_operation_table(group),
            'properties': self._analyze_properties(group)
        }
        
    def geometric_representation(self, group_name: str) -> Dict:
        """å‡ ä½•è¡¨å¾"""
        group = self.groups[group_name]
        return {
            'cayley_graph': self._create_cayley_graph(group),
            'subgroup_lattice': self._create_subgroup_lattice(group),
            'symmetry_analysis': self._analyze_symmetries(group)
        }
        
    def combinatorial_representation(self, group_name: str) -> Dict:
        """ç»„åˆè¡¨å¾"""
        group = self.groups[group_name]
        return {
            'permutation_representation': self._create_permutation_rep(group),
            'cycle_structure': self._analyze_cycle_structure(group),
            'conjugacy_classes': self._find_conjugacy_classes(group)
        }
        
    def topological_representation(self, group_name: str) -> Dict:
        """æ‹“æ‰‘è¡¨å¾"""
        group = self.groups[group_name]
        return {
            'presentation': self._find_presentation(group),
            'homology': self._compute_homology(group),
            'cohomology': self._compute_cohomology(group)
        }
        
    def _create_operation_table(self, group: Dict) -> np.ndarray:
        """åˆ›å»ºè¿ç®—è¡¨"""
        elements = group['elements']
        n = len(elements)
        table = np.zeros((n, n), dtype=int)
        
        for i, a in enumerate(elements):
            for j, b in enumerate(elements):
                result = group['operation'][(a, b)]
                table[i, j] = elements.index(result)
                
        return table
        
    def _analyze_properties(self, group: Dict) -> Dict:
        """åˆ†æç¾¤çš„æ€§è´¨"""
        elements = group['elements']
        operation = group['operation']
        
        # æ£€æŸ¥ç»“åˆå¾‹
        associative = True
        for a in elements:
            for b in elements:
                for c in elements:
                    if operation[(operation[(a, b)], c)] != operation[(a, operation[(b, c)])]:
                        associative = False
                        break
                        
        # æ£€æŸ¥å•ä½å…ƒ
        identity = None
        for e in elements:
            if all(operation[(e, a)] == a and operation[(a, e)] == a for a in elements):
                identity = e
                break
                
        # æ£€æŸ¥é€†å…ƒ
        inverses = {}
        if identity:
            for a in elements:
                for b in elements:
                    if operation[(a, b)] == identity and operation[(b, a)] == identity:
                        inverses[a] = b
                        break
                        
        return {
            'associative': associative,
            'identity': identity,
            'inverses': inverses,
            'commutative': self._check_commutative(group)
        }
        
    def _check_commutative(self, group: Dict) -> bool:
        """æ£€æŸ¥äº¤æ¢æ€§"""
        elements = group['elements']
        operation = group['operation']
        
        for a in elements:
            for b in elements:
                if operation[(a, b)] != operation[(b, a)]:
                    return False
        return True
        
    def _create_cayley_graph(self, group: Dict) -> nx.DiGraph:
        """åˆ›å»ºå‡¯è±å›¾"""
        G = nx.DiGraph()
        elements = group['elements']
        operation = group['operation']
        
        # æ·»åŠ èŠ‚ç‚¹
        for element in elements:
            G.add_node(element)
            
        # æ·»åŠ è¾¹
        for a in elements:
            for b in elements:
                result = operation[(a, b)]
                G.add_edge(a, result, label=f"{a}Â·{b}")
                
        return G
        
    def _create_subgroup_lattice(self, group: Dict) -> nx.DiGraph:
        """åˆ›å»ºå­ç¾¤æ ¼"""
        G = nx.DiGraph()
        elements = group['elements']
        
        # æ‰¾åˆ°æ‰€æœ‰å­ç¾¤
        subgroups = self._find_subgroups(group)
        
        # æ·»åŠ èŠ‚ç‚¹
        for subgroup in subgroups:
            G.add_node(tuple(sorted(subgroup)))
            
        # æ·»åŠ åŒ…å«å…³ç³»è¾¹
        for H in subgroups:
            for K in subgroups:
                if set(H).issubset(set(K)) and H != K:
                    G.add_edge(tuple(sorted(H)), tuple(sorted(K)))
                    
        return G
        
    def _find_subgroups(self, group: Dict) -> List[List]:
        """æ‰¾åˆ°æ‰€æœ‰å­ç¾¤"""
        elements = group['elements']
        operation = group['operation']
        subgroups = []
        
        # ä½¿ç”¨æ‹‰æ ¼æœ—æ—¥å®šç†çš„é€†ï¼šæ£€æŸ¥æ¯ä¸ªå­é›†
        for size in range(1, len(elements) + 1):
            if len(elements) % size == 0:  # æ‹‰æ ¼æœ—æ—¥å®šç†
                for subset in self._get_subsets(elements, size):
                    if self._is_subgroup(subset, operation):
                        subgroups.append(subset)
                        
        return subgroups
        
    def _get_subsets(self, elements: List, size: int) -> List[List]:
        """è·å–æŒ‡å®šå¤§å°çš„å­é›†"""
        if size == 0:
            return [[]]
        if size == len(elements):
            return [elements]
        if size > len(elements):
            return []
            
        result = []
        for i in range(len(elements) - size + 1):
            for subset in self._get_subsets(elements[i+1:], size-1):
                result.append([elements[i]] + subset)
        return result
        
    def _is_subgroup(self, subset: List, operation: Dict) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå­ç¾¤"""
        # æ£€æŸ¥å°é—­æ€§
        for a in subset:
            for b in subset:
                if operation[(a, b)] not in subset:
                    return False
                    
        # æ£€æŸ¥å•ä½å…ƒ
        identity = None
        for e in subset:
            if all(operation[(e, a)] == a and operation[(a, e)] == a for a in subset):
                identity = e
                break
        if not identity:
            return False
            
        # æ£€æŸ¥é€†å…ƒ
        for a in subset:
            has_inverse = False
            for b in subset:
                if operation[(a, b)] == identity and operation[(b, a)] == identity:
                    has_inverse = True
                    break
            if not has_inverse:
                return False
                
        return True
        
    def _create_permutation_rep(self, group: Dict) -> Dict:
        """åˆ›å»ºç½®æ¢è¡¨ç¤º"""
        elements = group['elements']
        operation = group['operation']
        
        # å·¦ä¹˜è¡¨ç¤º
        left_rep = {}
        for g in elements:
            permutation = []
            for h in elements:
                result = operation[(g, h)]
                permutation.append(elements.index(result))
            left_rep[g] = permutation
            
        return {'left_representation': left_rep}
        
    def _analyze_cycle_structure(self, group: Dict) -> Dict:
        """åˆ†æå¾ªç¯ç»“æ„"""
        elements = group['elements']
        operation = group['operation']
        
        cycle_structures = {}
        for element in elements:
            cycles = self._find_cycles(element, group)
            cycle_structures[element] = cycles
            
        return cycle_structures
        
    def _find_cycles(self, element: Any, group: Dict) -> List[int]:
        """æ‰¾åˆ°å…ƒç´ çš„å¾ªç¯ç»“æ„"""
        elements = group['elements']
        operation = group['operation']
        
        # è®¡ç®—å…ƒç´ çš„é˜¶
        order = 1
        current = element
        while operation[(current, element)] != element:
            current = operation[(current, element)]
            order += 1
            if order > len(elements):
                break
                
        return [order]
        
    def _find_conjugacy_classes(self, group: Dict) -> List[List]:
        """æ‰¾åˆ°å…±è½­ç±»"""
        elements = group['elements']
        operation = group['operation']
        
        classes = []
        used = set()
        
        for a in elements:
            if a in used:
                continue
                
            # æ‰¾åˆ°açš„å…±è½­ç±»
            conjugacy_class = []
            for g in elements:
                # è®¡ç®— gâ»Â¹ag
                g_inv = None
                for h in elements:
                    if operation[(g, h)] == operation[(h, g)] and operation[(g, h)] in [e for e in elements if all(operation[(e, x)] == x for x in elements)]:
                        g_inv = h
                        break
                        
                if g_inv:
                    conjugate = operation[(operation[(g_inv, a)], g)]
                    if conjugate not in conjugacy_class:
                        conjugacy_class.append(conjugate)
                        
            classes.append(conjugacy_class)
            used.update(conjugacy_class)
            
        return classes
        
    def _find_presentation(self, group: Dict) -> str:
        """æ‰¾åˆ°ç¾¤çš„è¡¨ç¤º"""
        # ç®€åŒ–ç‰ˆæœ¬ï¼šè¿”å›åŸºæœ¬è¡¨ç¤º
        return f"<{', '.join(map(str, group['elements']))} | relations>"
        
    def _compute_homology(self, group: Dict) -> Dict:
        """è®¡ç®—åŒè°ƒç¾¤"""
        # ç®€åŒ–ç‰ˆæœ¬ï¼šè¿”å›åŸºæœ¬åŒè°ƒä¿¡æ¯
        return {
            'H_0': 'Z',
            'H_1': 'Z^n',
            'H_2': 'Z^m'
        }
        
    def _compute_cohomology(self, group: Dict) -> Dict:
        """è®¡ç®—ä¸ŠåŒè°ƒç¾¤"""
        # ç®€åŒ–ç‰ˆæœ¬ï¼šè¿”å›åŸºæœ¬ä¸ŠåŒè°ƒä¿¡æ¯
        return {
            'H^0': 'Z',
            'H^1': 'Z^n',
            'H^2': 'Z^m'
        }
        
    def _analyze_symmetries(self, group: Dict) -> Dict:
        """åˆ†æå¯¹ç§°æ€§"""
        elements = group['elements']
        
        return {
            'automorphisms': len(elements),  # ç®€åŒ–
            'inner_automorphisms': len(elements),
            'outer_automorphisms': 0
        }

class CriticalArgumentationFramework:
    """æ‰¹åˆ¤æ€§è®ºè¯æ¡†æ¶"""
    
    def __init__(self):
        self.arguments = {}
        self.counter_arguments = {}
        self.evidence = {}
        
    def add_argument(self, topic: str, argument: str, strength: float) -> None:
        """æ·»åŠ è®ºè¯"""
        if topic not in self.arguments:
            self.arguments[topic] = []
        self.arguments[topic].append({
            'argument': argument,
            'strength': strength
        })
        
    def add_counter_argument(self, topic: str, counter: str, strength: float) -> None:
        """æ·»åŠ åè®ºè¯"""
        if topic not in self.counter_arguments:
            self.counter_arguments[topic] = []
        self.counter_arguments[topic].append({
            'counter': counter,
            'strength': strength
        })
        
    def analyze_argument_strength(self, topic: str) -> Dict:
        """åˆ†æè®ºè¯å¼ºåº¦"""
        if topic not in self.arguments:
            return {}
            
        total_strength = sum(arg['strength'] for arg in self.arguments[topic])
        counter_strength = sum(counter['strength'] for counter in self.counter_arguments.get(topic, []))
        
        net_strength = total_strength - counter_strength
        
        return {
            'total_arguments': len(self.arguments[topic]),
            'total_counter_arguments': len(self.counter_arguments.get(topic, [])),
            'total_strength': total_strength,
            'counter_strength': counter_strength,
            'net_strength': net_strength,
            'confidence': min(1.0, max(0.0, net_strength / 10.0))
        }
        
    def get_philosophical_critique(self, topic: str) -> Dict:
        """è·å–å“²å­¦æ‰¹åˆ¤"""
        critiques = {
            'ç¾¤è®ºçš„åŸºç¡€æ€§': {
                'ontological': 'ç¾¤è®ºæ˜¯å¦åæ˜ äº†æ•°å­¦å¯¹è±¡çš„çœŸå®æœ¬è´¨ï¼Ÿ',
                'epistemological': 'æˆ‘ä»¬å¦‚ä½•è®¤è¯†ç¾¤çš„ç»“æ„ï¼Ÿ',
                'methodological': 'ç¾¤è®ºçš„å…¬ç†åŒ–æ–¹æ³•æ˜¯å¦æœ€ä¼˜ï¼Ÿ'
            },
            'ç¾¤è®ºçš„æ™®éæ€§': {
                'ontological': 'ç¾¤è®ºæ˜¯å¦é€‚ç”¨äºæ‰€æœ‰æ•°å­¦ç»“æ„ï¼Ÿ',
                'epistemological': 'ç¾¤è®ºçš„æŠ½è±¡æ€§æ˜¯å¦è¿‡åº¦ï¼Ÿ',
                'methodological': 'ç¾¤è®ºçš„æ–¹æ³•æ˜¯å¦è¿‡äºå½¢å¼åŒ–ï¼Ÿ'
            }
        }
        
        return critiques.get(topic, {})

class HistoricalDevelopmentTimeline:
    """å†å²å‘å±•æ—¶é—´çº¿"""
    
    def __init__(self):
        self.events = []
        
    def add_event(self, year: int, event: str, significance: str) -> None:
        """æ·»åŠ å†å²äº‹ä»¶"""
        self.events.append({
            'year': year,
            'event': event,
            'significance': significance
        })
        
    def get_timeline(self) -> List[Dict]:
        """è·å–æ—¶é—´çº¿"""
        return sorted(self.events, key=lambda x: x['year'])
        
    def visualize_timeline(self) -> nx.DiGraph:
        """å¯è§†åŒ–æ—¶é—´çº¿"""
        G = nx.DiGraph()
        
        for event in self.events:
            G.add_node(f"{event['year']}: {event['event']}")
            
        # æ·»åŠ æ—¶é—´é¡ºåºè¾¹
        sorted_events = sorted(self.events, key=lambda x: x['year'])
        for i in range(len(sorted_events) - 1):
            G.add_edge(
                f"{sorted_events[i]['year']}: {sorted_events[i]['event']}",
                f"{sorted_events[i+1]['year']}: {sorted_events[i+1]['event']}"
            )
            
        return G

def demonstrate_group_theory_analysis():
    """æ¼”ç¤ºç¾¤è®ºå¤šè¡¨å¾åˆ†æ"""
    print("=== ç¾¤è®ºå¤šè¡¨å¾ç³»ç»Ÿæ¼”ç¤º ===\n")
    
    # åˆ›å»ºç¾¤è®ºç³»ç»Ÿ
    gts = GroupTheorySystem()
    
    # æ·»åŠ å¯¹ç§°ç¾¤Sâ‚ƒ
    S3_elements = ['e', 'a', 'b', 'c', 'd', 'f']
    S3_operation = {
        ('e', 'e'): 'e', ('e', 'a'): 'a', ('e', 'b'): 'b', ('e', 'c'): 'c', ('e', 'd'): 'd', ('e', 'f'): 'f',
        ('a', 'e'): 'a', ('a', 'a'): 'e', ('a', 'b'): 'c', ('a', 'c'): 'b', ('a', 'd'): 'f', ('a', 'f'): 'd',
        ('b', 'e'): 'b', ('b', 'a'): 'c', ('b', 'b'): 'e', ('b', 'c'): 'a', ('b', 'd'): 'd', ('b', 'f'): 'f',
        ('c', 'e'): 'c', ('c', 'a'): 'b', ('c', 'b'): 'a', ('c', 'c'): 'e', ('c', 'd'): 'f', ('c', 'f'): 'd',
        ('d', 'e'): 'd', ('d', 'a'): 'f', ('d', 'b'): 'd', ('d', 'c'): 'f', ('d', 'd'): 'e', ('d', 'f'): 'a',
        ('f', 'e'): 'f', ('f', 'a'): 'd', ('f', 'b'): 'f', ('f', 'c'): 'd', ('f', 'd'): 'a', ('f', 'f'): 'e'
    }
    gts.add_group('S3', S3_elements, S3_operation)
    
    # ä»£æ•°è¡¨å¾
    print("1. ä»£æ•°è¡¨å¾:")
    alg_rep = gts.algebraic_representation('S3')
    print(f"   - ç¾¤é˜¶: {alg_rep['properties']['order']}")
    print(f"   - ç»“åˆå¾‹: {alg_rep['properties']['associative']}")
    print(f"   - å•ä½å…ƒ: {alg_rep['properties']['identity']}")
    print(f"   - äº¤æ¢æ€§: {alg_rep['properties']['commutative']}")
    
    # å‡ ä½•è¡¨å¾
    print("\n2. å‡ ä½•è¡¨å¾:")
    geom_rep = gts.geometric_representation('S3')
    print(f"   - å‡¯è±å›¾èŠ‚ç‚¹æ•°: {geom_rep['cayley_graph'].number_of_nodes()}")
    print(f"   - å‡¯è±å›¾è¾¹æ•°: {geom_rep['cayley_graph'].number_of_edges()}")
    print(f"   - å­ç¾¤æ ¼èŠ‚ç‚¹æ•°: {geom_rep['subgroup_lattice'].number_of_nodes()}")
    
    # ç»„åˆè¡¨å¾
    print("\n3. ç»„åˆè¡¨å¾:")
    comb_rep = gts.combinatorial_representation('S3')
    print(f"   - ç½®æ¢è¡¨ç¤º: {len(comb_rep['permutation_representation']['left_representation'])}")
    print(f"   - å…±è½­ç±»æ•°: {len(comb_rep['conjugacy_classes'])}")
    
    # æ‰¹åˆ¤æ€§è®ºè¯
    print("\n4. æ‰¹åˆ¤æ€§è®ºè¯åˆ†æ:")
    caf = CriticalArgumentationFramework()
    
    # æ·»åŠ è®ºè¯
    caf.add_argument("ç¾¤è®ºçš„åŸºç¡€æ€§", "ç¾¤è®ºä¸ºç°ä»£æ•°å­¦æä¾›äº†ç»Ÿä¸€çš„è¯­è¨€", 8.5)
    caf.add_argument("ç¾¤è®ºçš„åŸºç¡€æ€§", "ç¾¤è®ºåœ¨ç‰©ç†ã€åŒ–å­¦ç­‰é¢†åŸŸæœ‰é‡è¦åº”ç”¨", 9.0)
    caf.add_counter_argument("ç¾¤è®ºçš„åŸºç¡€æ€§", "ç¾¤è®ºçš„æŠ½è±¡æ€§å¯èƒ½æ©ç›–å…·ä½“é—®é¢˜çš„ç‰¹æ®Šæ€§", 6.0)
    
    strength_analysis = caf.analyze_argument_strength("ç¾¤è®ºçš„åŸºç¡€æ€§")
    print(f"   - è®ºè¯å¼ºåº¦: {strength_analysis['net_strength']:.1f}")
    print(f"   - ç½®ä¿¡åº¦: {strength_analysis['confidence']:.2f}")
    
    # å†å²å‘å±•
    print("\n5. å†å²å‘å±•æ—¶é—´çº¿:")
    hdt = HistoricalDevelopmentTimeline()
    hdt.add_event(1770, "æ‹‰æ ¼æœ—æ—¥ç ”ç©¶ä»£æ•°æ–¹ç¨‹", "ä¸ºç¾¤è®ºå¥ å®šåŸºç¡€")
    hdt.add_event(1832, "ä¼½ç½—ç“¦å¼•å…¥ç¾¤çš„æ¦‚å¿µ", "ç¾¤è®ºæ­£å¼è¯ç”Ÿ")
    hdt.add_event(1854, "å‡¯è±ç»™å‡ºç¾¤çš„æŠ½è±¡å®šä¹‰", "ç¾¤è®ºæˆä¸ºç‹¬ç«‹å­¦ç§‘")
    hdt.add_event(2004, "æœ‰é™å•ç¾¤åˆ†ç±»å®Œæˆ", "ç¾¤è®ºå²ä¸Šçš„é‡Œç¨‹ç¢‘")
    
    timeline = hdt.get_timeline()
    for event in timeline:
        print(f"   {event['year']}: {event['event']} - {event['significance']}")
    
    # å¯è§†åŒ–
    print("\n6. ç”Ÿæˆå¯è§†åŒ–å›¾è¡¨...")
    plt.figure(figsize=(15, 10))
    
    # å‡¯è±å›¾
    plt.subplot(2, 3, 1)
    cayley_graph = geom_rep['cayley_graph']
    pos = nx.spring_layout(cayley_graph)
    nx.draw(cayley_graph, pos, with_labels=True, node_color='lightblue',
            node_size=1000, font_size=8, arrows=True)
    plt.title("Sâ‚ƒçš„å‡¯è±å›¾")
    
    # å­ç¾¤æ ¼
    plt.subplot(2, 3, 2)
    subgroup_lattice = geom_rep['subgroup_lattice']
    if subgroup_lattice.number_of_nodes() > 0:
        pos = nx.spring_layout(subgroup_lattice)
        nx.draw(subgroup_lattice, pos, with_labels=True, node_color='lightgreen',
                node_size=800, font_size=6, arrows=True)
    plt.title("Sâ‚ƒçš„å­ç¾¤æ ¼")
    
    # è®ºè¯ç½‘ç»œ
    plt.subplot(2, 3, 3)
    arg_network = nx.DiGraph()
    arg_network.add_edge("ç¾¤è®ºåŸºç¡€æ€§", "ç»Ÿä¸€è¯­è¨€")
    arg_network.add_edge("ç¾¤è®ºåŸºç¡€æ€§", "å¹¿æ³›åº”ç”¨")
    arg_network.add_edge("ç¾¤è®ºåŸºç¡€æ€§", "æŠ½è±¡æ€§æ‰¹è¯„")
    pos = nx.spring_layout(arg_network)
    nx.draw(arg_network, pos, with_labels=True, node_color='lightcoral',
            node_size=1500, font_size=8, arrows=True)
    plt.title("è®ºè¯ç½‘ç»œ")
    
    # å†å²æ—¶é—´çº¿
    plt.subplot(2, 3, 4)
    timeline_graph = hdt.visualize_timeline()
    if timeline_graph.number_of_nodes() > 0:
        pos = nx.spring_layout(timeline_graph)
        nx.draw(timeline_graph, pos, with_labels=True, node_color='lightyellow',
                node_size=1000, font_size=6, arrows=True)
    plt.title("å†å²å‘å±•æ—¶é—´çº¿")
    
    plt.tight_layout()
    plt.show()
    
    return {
        'algebraic': alg_rep,
        'geometric': geom_rep,
        'combinatorial': comb_rep,
        'argument_analysis': strength_analysis
    }

# è¿è¡Œæ¼”ç¤º
if __name__ == "__main__":
    results = demonstrate_group_theory_analysis()
    print("\næ¼”ç¤ºå®Œæˆï¼")
```

### æ€ç»´å¯¼å›¾ï¼šç¾¤è®ºçš„æ ¸å¿ƒæ¦‚å¿µ

```mermaid
mindmap
  root((ç¾¤è®º))
    åŸºç¡€æ¦‚å¿µ
      ç¾¤çš„å®šä¹‰
        ç»“åˆå¾‹
        å•ä½å…ƒ
        é€†å…ƒ
      ç¾¤çš„æ€§è´¨
        é˜¶
        ç”Ÿæˆå…ƒ
        ä¸­å¿ƒ
      å­ç¾¤
        æ­£è§„å­ç¾¤
        å•†ç¾¤
        æ‹‰æ ¼æœ—æ—¥å®šç†
    é‡è¦ç¾¤ç±»
      æœ‰é™ç¾¤
        å¾ªç¯ç¾¤
        å¯¹ç§°ç¾¤
        äºŒé¢ä½“ç¾¤
      æ— é™ç¾¤
        æ•´æ•°åŠ æ³•ç¾¤
        å®æ•°ä¹˜æ³•ç¾¤
        æç¾¤
    ç¾¤è®ºå·¥å…·
      åŒæ€
        æ ¸
        åƒ
        åŒæ„
      è¡¨ç¤ºè®º
        çº¿æ€§è¡¨ç¤º
        ç‰¹å¾æ ‡
        ä¸å¯çº¦è¡¨ç¤º
      è¥¿ç½—å®šç†
        è¥¿ç½—p-å­ç¾¤
        è¥¿ç½—å®šç†
    åº”ç”¨é¢†åŸŸ
      ç‰©ç†å­¦
        å¯¹ç§°æ€§
        é‡å­åŠ›å­¦
        ç²’å­ç‰©ç†
      åŒ–å­¦
        åˆ†å­å¯¹ç§°æ€§
        æ™¶ä½“å­¦
        å…‰è°±å­¦
      å¯†ç å­¦
        æ¤­åœ†æ›²çº¿
        ç¦»æ•£å¯¹æ•°
        æ•°å­—ç­¾å
      ç¼–ç ç†è®º
        çº é”™ç 
        çº¿æ€§ç 
        å¾ªç¯ç 
    ç°ä»£å‘å±•
      å‡ ä½•ç¾¤è®º
        åŒæ›²ç¾¤
        CAT(0)ç¾¤
        è‡ªåŠ¨æœºç¾¤
      è¡¨ç¤ºè®º
        æç¾¤è¡¨ç¤º
        æ¨¡è¡¨ç¤º
        ç‰¹å¾æ ‡ç†è®º
      ç»„åˆç¾¤è®º
        è‡ªç”±ç¾¤
        åŒæ›²ç¾¤
        è‡ªåŠ¨æœºç¾¤
```

è¿™ä¸ªå¤šè¡¨å¾ç³»ç»Ÿä¸ºç¾¤è®ºæä¾›äº†ï¼š

1. **ä»£æ•°è¡¨å¾**ï¼šå½¢å¼åŒ–çš„ç¾¤å®šä¹‰å’Œæ€§è´¨
2. **å‡ ä½•è¡¨å¾**ï¼šå‡¯è±å›¾å’Œå­ç¾¤æ ¼çš„å¯è§†åŒ–
3. **ç»„åˆè¡¨å¾**ï¼šç½®æ¢è¡¨ç¤ºå’Œå…±è½­ç±»åˆ†æ
4. **æ‹“æ‰‘è¡¨å¾**ï¼šç¾¤çš„è¡¨ç¤ºå’ŒåŒè°ƒç†è®º
5. **æ‰¹åˆ¤æ€§è®ºè¯**ï¼šå“²å­¦è§‚ç‚¹çš„è®ºè¯åˆ†æ
6. **å†å²å‘å±•**ï¼šæ—¶é—´çº¿å’Œå½±å“åˆ†æ
7. **æ€ç»´å¯¼å›¾**ï¼šæ¦‚å¿µå…³ç³»çš„å±‚æ¬¡åŒ–å±•ç¤º

é€šè¿‡è¿™äº›å¤šè¡¨å¾æ–¹å¼ï¼Œæˆ‘ä»¬å¯ä»¥æ·±å…¥ç†è§£ç¾¤è®ºçš„æ ¸å¿ƒæ¦‚å¿µã€å†å²å‘å±•å’Œç°ä»£åº”ç”¨ã€‚
