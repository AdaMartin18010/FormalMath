# 4.1 基础群论密码学

## 4.1.1 离散对数问题

### 离散对数基础

```python
import numpy as np
from math import ceil, sqrt

class DiscreteLogarithm:
    """离散对数问题"""
    
    def __init__(self, group):
        self.group = group
    
    def baby_step_giant_step(self, g, h, n):
        """Baby-step Giant-step算法"""
        # 计算m = ceil(sqrt(n))
        m = ceil(sqrt(n))
        
        # Baby steps
        baby_steps = {}
        current = self.group.identity
        for j in range(m):
            baby_steps[current] = j
            current = self.group.multiply(current, g)
        
        # Giant steps
        factor = self.group.power(g, m)
        current = h
        for i in range(m):
            if current in baby_steps:
                j = baby_steps[current]
                return i * m + j
            current = self.group.multiply(current, self.group.inverse(factor))
        
        return None
    
    def pollard_rho(self, g, h, n):
        """Pollard's Rho算法"""
        def f(x, a, b):
            """伪随机函数"""
            if x % 3 == 0:
                return (self.group.multiply(x, x), (2 * a) % n, (2 * b) % n)
            elif x % 3 == 1:
                return (self.group.multiply(x, g), (a + 1) % n, b)
            else:
                return (self.group.multiply(x, h), a, (b + 1) % n)
        
        # Floyd's cycle finding
        x, a, b = self.group.identity, 0, 0
        X, A, B = x, a, b
        
        while True:
            x, a, b = f(x, a, b)
            X, A, B = f(f(X, A, B)[0], f(X, A, B)[1], f(X, A, B)[2])
            
            if x == X:
                if b == B:
                    return None
                else:
                    return ((A - a) * pow(b - B, -1, n)) % n

# 循环群示例
class CyclicGroup:
    """循环群实现"""
    
    def __init__(self, p, g):
        self.p = p
        self.g = g
        self.identity = 1
    
    def multiply(self, a, b):
        """群乘法"""
        return (a * b) % self.p
    
    def power(self, a, n):
        """幂运算"""
        return pow(a, n, self.p)
    
    def inverse(self, a):
        """逆元"""
        return pow(a, -1, self.p)

# 离散对数应用
p = 23
g = 5
cyclic_group = CyclicGroup(p, g)
dl_problem = DiscreteLogarithm(cyclic_group)

# 测试离散对数
h = 8
result = dl_problem.baby_step_giant_step(g, h, p-1)
print(f"离散对数 log_{g}({h}) = {result}")
```

### 4.1.2 Diffie-Hellman密钥交换

#### DH密钥交换

```python
class DiffieHellman:
    """Diffie-Hellman密钥交换"""
    
    def __init__(self, group):
        self.group = group
    
    def generate_private_key(self):
        """生成私钥"""
        return np.random.randint(2, self.group.p - 1)
    
    def generate_public_key(self, private_key):
        """生成公钥"""
        return self.group.power(self.group.g, private_key)
    
    def compute_shared_secret(self, private_key, other_public_key):
        """计算共享密钥"""
        return self.group.power(other_public_key, private_key)
    
    def key_exchange(self):
        """执行密钥交换"""
        # Alice生成密钥对
        alice_private = self.generate_private_key()
        alice_public = self.generate_public_key(alice_private)
        
        # Bob生成密钥对
        bob_private = self.generate_private_key()
        bob_public = self.generate_public_key(bob_private)
        
        # 计算共享密钥
        alice_shared = self.compute_shared_secret(alice_private, bob_public)
        bob_shared = self.compute_shared_secret(bob_private, alice_public)
        
        return {
            'alice_private': alice_private,
            'alice_public': alice_public,
            'bob_private': bob_private,
            'bob_public': bob_public,
            'alice_shared': alice_shared,
            'bob_shared': bob_shared,
            'success': alice_shared == bob_shared
        }

# DH密钥交换应用
dh = DiffieHellman(cyclic_group)
exchange_result = dh.key_exchange()
print(f"DH密钥交换成功: {exchange_result['success']}")
print(f"共享密钥: {exchange_result['alice_shared']}")
```

### 4.1.3 ElGamal加密系统

#### ElGamal加密

```python
class ElGamal:
    """ElGamal加密系统"""
    
    def __init__(self, group):
        self.group = group
    
    def generate_key_pair(self):
        """生成密钥对"""
        private_key = np.random.randint(2, self.group.p - 1)
        public_key = self.group.power(self.group.g, private_key)
        return private_key, public_key
    
    def encrypt(self, message, public_key):
        """加密"""
        k = np.random.randint(2, self.group.p - 1)
        c1 = self.group.power(self.group.g, k)
        c2 = (message * self.group.power(public_key, k)) % self.group.p
        return c1, c2
    
    def decrypt(self, ciphertext, private_key):
        """解密"""
        c1, c2 = ciphertext
        s = self.group.power(c1, private_key)
        s_inv = self.group.inverse(s)
        message = (c2 * s_inv) % self.group.p
        return message
    
    def encrypt_message(self, message, public_key):
        """加密消息"""
        # 将消息转换为数字
        message_num = sum(ord(c) * (256 ** i) for i, c in enumerate(message))
        message_num = message_num % self.group.p
        
        return self.encrypt(message_num, public_key)
    
    def decrypt_message(self, ciphertext, private_key):
        """解密消息"""
        message_num = self.decrypt(ciphertext, private_key)
        
        # 将数字转换回消息
        message = ""
        while message_num > 0:
            message = chr(message_num % 256) + message
            message_num //= 256
        
        return message

# ElGamal加密应用
elgamal = ElGamal(cyclic_group)
private_key, public_key = elgamal.generate_key_pair()

message = "Hello"
ciphertext = elgamal.encrypt_message(message, public_key)
decrypted = elgamal.decrypt_message(ciphertext, private_key)

print(f"原始消息: {message}")
print(f"解密消息: {decrypted}")
print(f"加密成功: {message == decrypted}")
```
