# ç±»å‹è®ºä¸è¯æ˜ - æ·±åŒ–ç‰ˆ

**ä¸»é¢˜ç¼–å·**: B.09.04
**åˆ›å»ºæ—¥æœŸ**: 2025å¹´11æœˆ21æ—¥
**æœ€åæ›´æ–°**: 2025å¹´11æœˆ21æ—¥

---

## ğŸ“š æ¦‚è¿°

ç±»å‹è®ºæ˜¯ç°ä»£é€»è¾‘å­¦å’Œè®¡ç®—æœºç§‘å­¦çš„é‡è¦åŸºç¡€ï¼Œå®ƒå°†ç±»å‹ç³»ç»Ÿä¸é€»è¾‘ç³»ç»Ÿé€šè¿‡Curry-Howardå¯¹åº”è”ç³»èµ·æ¥ï¼Œä¸ºå½¢å¼åŒ–è¯æ˜æä¾›äº†å¼ºå¤§çš„ç†è®ºåŸºç¡€ã€‚
æœ¬æ·±åŒ–ç‰ˆå°†æ·±å…¥æ¢è®¨ç±»å‹è®ºçš„åŸºæœ¬æ¦‚å¿µã€è¯æ˜ç³»ç»Ÿã€ä¾èµ–ç±»å‹ç†è®ºåŠå…¶åº”ç”¨ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

1. **æŒæ¡ç±»å‹è®ºåŸºç¡€**ï¼šç†è§£ç®€å•ç±»å‹è®ºã€å¤šæ€ç±»å‹è®ºã€ä¾èµ–ç±»å‹è®ºç­‰æ ¸å¿ƒæ¦‚å¿µ
2. **æŒæ¡Curry-Howardå¯¹åº”**ï¼šç†è§£ç±»å‹ä¸å‘½é¢˜ã€ç¨‹åºä¸è¯æ˜çš„å¯¹åº”å…³ç³»
3. **æŒæ¡è¯æ˜ç³»ç»Ÿ**ï¼šç†è§£è‡ªç„¶æ¼”ç»ã€åºåˆ—æ¼”ç®—ã€ç±»å‹è®ºè¯æ˜ç³»ç»Ÿ
4. **æŒæ¡åº”ç”¨é¢†åŸŸ**ï¼šç†è§£åœ¨ç¨‹åºéªŒè¯ã€å®šç†è¯æ˜ã€å½¢å¼åŒ–æ•°å­¦ä¸­çš„åº”ç”¨

## ğŸ“– ç›®å½•

- [ç±»å‹è®ºä¸è¯æ˜ - æ·±åŒ–ç‰ˆ](#ç±»å‹è®ºä¸è¯æ˜---æ·±åŒ–ç‰ˆ)
  - [ğŸ“š æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“– ç›®å½•](#-ç›®å½•)
  - [1. ç±»å‹è®ºåŸºç¡€ (ç¼–å·: B.09.04.01)](#1-ç±»å‹è®ºåŸºç¡€-ç¼–å·-b090401)
    - [1.1 ç®€å•ç±»å‹è®º](#11-ç®€å•ç±»å‹è®º)
    - [1.2 å¤šæ€ç±»å‹è®º](#12-å¤šæ€ç±»å‹è®º)
    - [1.3 ä¾èµ–ç±»å‹è®º](#13-ä¾èµ–ç±»å‹è®º)
  - [2. Curry-Howardå¯¹åº” (ç¼–å·: B.09.04.02)](#2-curry-howardå¯¹åº”-ç¼–å·-b090402)
    - [2.1 ç±»å‹ä¸å‘½é¢˜](#21-ç±»å‹ä¸å‘½é¢˜)
    - [2.2 ç¨‹åºä¸è¯æ˜](#22-ç¨‹åºä¸è¯æ˜)
    - [2.3 è®¡ç®—ä¸è§„çº¦](#23-è®¡ç®—ä¸è§„çº¦)
  - [3. è¯æ˜ç³»ç»Ÿ (ç¼–å·: B.09.04.03)](#3-è¯æ˜ç³»ç»Ÿ-ç¼–å·-b090403)
    - [3.1 è‡ªç„¶æ¼”ç»](#31-è‡ªç„¶æ¼”ç»)
    - [3.2 åºåˆ—æ¼”ç®—](#32-åºåˆ—æ¼”ç®—)
    - [3.3 ç±»å‹è®ºè¯æ˜](#33-ç±»å‹è®ºè¯æ˜)
  - [4. åº”ç”¨é¢†åŸŸ (ç¼–å·: B.09.04.04)](#4-åº”ç”¨é¢†åŸŸ-ç¼–å·-b090404)
    - [4.1 ç¨‹åºéªŒè¯](#41-ç¨‹åºéªŒè¯)
    - [4.2 å®šç†è¯æ˜](#42-å®šç†è¯æ˜)
    - [4.3 å½¢å¼åŒ–æ•°å­¦](#43-å½¢å¼åŒ–æ•°å­¦)
  - [5. æŠ€æœ¯å®ç° (ç¼–å·: B.09.04.05)](#5-æŠ€æœ¯å®ç°-ç¼–å·-b090405)
    - [5.1 Lean 4å®ç°](#51-lean-4å®ç°)
    - [5.2 Haskellå®ç°](#52-haskellå®ç°)
    - [5.3 Coqå®ç°](#53-coqå®ç°)
  - [6. å‰æ²¿å‘å±• (ç¼–å·: B.09.04.06)](#6-å‰æ²¿å‘å±•-ç¼–å·-b090406)
    - [6.1 åŒä¼¦ç±»å‹è®º](#61-åŒä¼¦ç±»å‹è®º)
    - [6.2 é«˜é˜¶ç±»å‹è®º](#62-é«˜é˜¶ç±»å‹è®º)
    - [6.3 é‡å­ç±»å‹è®º](#63-é‡å­ç±»å‹è®º)
    - [6.4 æœºå™¨å­¦ä¹ ç±»å‹è®º](#64-æœºå™¨å­¦ä¹ ç±»å‹è®º)
    - [6.5 åˆ†å¸ƒå¼ç±»å‹è®º](#65-åˆ†å¸ƒå¼ç±»å‹è®º)
  - [7. æ€»ç»“ä¸å±•æœ› (ç¼–å·: B.09.04.07)](#7-æ€»ç»“ä¸å±•æœ›-ç¼–å·-b090407)
    - [7.1 æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#71-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)
    - [7.2 å‘å±•è¶‹åŠ¿](#72-å‘å±•è¶‹åŠ¿)
    - [7.3 æŒ‘æˆ˜ä¸æœºé‡](#73-æŒ‘æˆ˜ä¸æœºé‡)

## 1. ç±»å‹è®ºåŸºç¡€ (ç¼–å·: B.09.04.01)

### 1.1 ç®€å•ç±»å‹è®º

**ç®€å•ç±»å‹è®º**æ˜¯ç±»å‹è®ºçš„åŸºç¡€ï¼Œå®ƒå¼•å…¥äº†ç±»å‹ä½œä¸ºç¨‹åºçš„åŸºæœ¬åˆ†ç±»ã€‚

**è¯­æ³•å®šä¹‰**ï¼š

$$\tau ::= \text{bool} \mid \text{nat} \mid \tau_1 \to \tau_2 \mid \tau_1 \times \tau_2$$

**ç±»å‹è§„åˆ™**ï¼š

$$\frac{\Gamma \vdash e_1 : \tau_1 \to \tau_2 \quad \Gamma \vdash e_2 : \tau_1}{\Gamma \vdash e_1 e_2 : \tau_2}$$

**ç¤ºä¾‹**ï¼š

```haskell
-- Haskellç®€å•ç±»å‹è®ºç¤ºä¾‹
id :: a -> a
id x = x

const :: a -> b -> a
const x y = x

compose :: (b -> c) -> (a -> b) -> a -> c
compose f g x = f (g x)
```

### 1.2 å¤šæ€ç±»å‹è®º

**å¤šæ€ç±»å‹è®º**å¼•å…¥äº†ç±»å‹å˜é‡ï¼Œä½¿ç±»å‹ç³»ç»Ÿæ›´åŠ çµæ´»ã€‚

**è¯­æ³•å®šä¹‰**ï¼š

$$\tau ::= \alpha \mid \text{bool} \mid \text{nat} \mid \tau_1 \to \tau_2 \mid \forall \alpha. \tau$$

**ç±»å‹è§„åˆ™**ï¼š

$$\frac{\Gamma \vdash e : \tau \quad \alpha \notin \text{FV}(\Gamma)}{\Gamma \vdash e : \forall \alpha. \tau}$$

**ç¤ºä¾‹**ï¼š

```haskell
-- Haskellå¤šæ€ç±»å‹è®ºç¤ºä¾‹
map :: (a -> b) -> [a] -> [b]
map f [] = []
map f (x:xs) = f x : map f xs

filter :: (a -> Bool) -> [a] -> [a]
filter p [] = []
filter p (x:xs) = if p x then x : filter p xs else filter p xs
```

### 1.3 ä¾èµ–ç±»å‹è®º

**ä¾èµ–ç±»å‹è®º**å…è®¸ç±»å‹ä¾èµ–äºå€¼ï¼Œæä¾›äº†æ›´å¼ºçš„è¡¨è¾¾èƒ½åŠ›ã€‚

**è¯­æ³•å®šä¹‰**ï¼š

$$\tau ::= \text{Set} \mid \Pi x : \tau_1. \tau_2 \mid \Sigma x : \tau_1. \tau_2 \mid \text{Id}_A(a, b)$$

**ç±»å‹è§„åˆ™**ï¼š

$$\frac{\Gamma \vdash A : \text{Set} \quad \Gamma, x : A \vdash B : \text{Set}}{\Gamma \vdash \Pi x : A. B : \text{Set}}$$

**ç¤ºä¾‹**ï¼š

```lean
-- Lean 4ä¾èµ–ç±»å‹è®ºç¤ºä¾‹
def Vector (Î± : Type) (n : Nat) : Type :=
  { l : List Î± // l.length = n }

def head {Î± : Type} {n : Nat} (v : Vector Î± (n + 1)) : Î± :=
  v.val.head

def tail {Î± : Type} {n : Nat} (v : Vector Î± (n + 1)) : Vector Î± n :=
  âŸ¨v.val.tail, by simpâŸ©
```

## 2. Curry-Howardå¯¹åº” (ç¼–å·: B.09.04.02)

### 2.1 ç±»å‹ä¸å‘½é¢˜

**Curry-Howardå¯¹åº”**å»ºç«‹äº†ç±»å‹ä¸å‘½é¢˜ä¹‹é—´çš„å¯¹åº”å…³ç³»ã€‚

**å¯¹åº”å…³ç³»**ï¼š

| ç±»å‹ | å‘½é¢˜ | é€»è¾‘è§£é‡Š |
|------|------|----------|
| $A \to B$ | $A \implies B$ | è•´æ¶µ |
| $A \times B$ | $A \land B$ | åˆå– |
| $A + B$ | $A \lor B$ | æå– |
| $\forall \alpha. A$ | $\forall x. A$ | å…¨ç§°é‡åŒ– |
| $\exists \alpha. A$ | $\exists x. A$ | å­˜åœ¨é‡åŒ– |

**ç¤ºä¾‹**ï¼š

```haskell
-- ç±»å‹ä½œä¸ºå‘½é¢˜çš„ç¤ºä¾‹
-- A -> B å¯¹åº” A => B
implies :: a -> b -> a -> b
implies _ b _ = b

-- A -> (B -> A) å¯¹åº” A => (B => A)
weakening :: a -> b -> a
weakening a _ = a
```

### 2.2 ç¨‹åºä¸è¯æ˜

**ç¨‹åºå³è¯æ˜**ï¼šæ¯ä¸ªç±»å‹è‰¯å¥½çš„ç¨‹åºéƒ½æ˜¯å¯¹åº”å‘½é¢˜çš„è¯æ˜ã€‚

**è¯æ˜æ„é€ **ï¼š

```haskell
-- è¯æ˜ A => (B => A)
proof1 :: a -> b -> a
proof1 a _ = a

-- è¯æ˜ (A => B) => ((B => C) => (A => C))
proof2 :: (a -> b) -> (b -> c) -> a -> c
proof2 f g a = g (f a)

-- è¯æ˜ A => (A => B) => B
proof3 :: a -> (a -> b) -> b
proof3 a f = f a
```

### 2.3 è®¡ç®—ä¸è§„çº¦

**Î²è§„çº¦**ï¼šå‡½æ•°åº”ç”¨çš„è§„çº¦è§„åˆ™ã€‚

**è§„çº¦è§„åˆ™**ï¼š

$$(\lambda x. e_1) e_2 \to e_1[e_2/x]$$

**ç¤ºä¾‹**ï¼š

```haskell
-- Î²è§„çº¦ç¤ºä¾‹
-- (Î»x. x + 1) 2
-- => 2 + 1
-- => 3

-- åœ¨Haskellä¸­
(\x -> x + 1) 2
-- è§„çº¦ä¸º 3
```

## 3. è¯æ˜ç³»ç»Ÿ (ç¼–å·: B.09.04.03)

### 3.1 è‡ªç„¶æ¼”ç»

**è‡ªç„¶æ¼”ç»**æ˜¯ç›´è§‰ä¸»ä¹‰é€»è¾‘çš„è¯æ˜ç³»ç»Ÿã€‚

**æ¨ç†è§„åˆ™**ï¼š

1. **å¼•å…¥è§„åˆ™**ï¼š
   - $\to$-å¼•å…¥ï¼š$\frac{[A] \quad B}{A \to B}$
   - $\land$-å¼•å…¥ï¼š$\frac{A \quad B}{A \land B}$
   - $\lor$-å¼•å…¥ï¼š$\frac{A}{A \lor B}$

2. **æ¶ˆé™¤è§„åˆ™**ï¼š
   - $\to$-æ¶ˆé™¤ï¼š$\frac{A \to B \quad A}{B}$
   - $\land$-æ¶ˆé™¤ï¼š$\frac{A \land B}{A}$
   - $\lor$-æ¶ˆé™¤ï¼š$\frac{A \lor B \quad [A] \quad C \quad [B] \quad C}{C}$

**ç¤ºä¾‹è¯æ˜**ï¼š

```haskell
-- è¯æ˜ A => (B => A)
proof :: a -> b -> a
proof a _ = a

-- å¯¹åº”è‡ªç„¶æ¼”ç»è¯æ˜ï¼š
-- 1. å‡è®¾ A
-- 2. å‡è®¾ B
-- 3. ä»1å¾—åˆ° A
-- 4. ä»2-3å¾—åˆ° B => A
-- 5. ä»1-4å¾—åˆ° A => (B => A)
```

### 3.2 åºåˆ—æ¼”ç®—

**åºåˆ—æ¼”ç®—**æ˜¯Gentzenå‘æ˜çš„è¯æ˜ç³»ç»Ÿã€‚

**åºåˆ—å½¢å¼**ï¼š$\Gamma \vdash \Delta$

**æ¨ç†è§„åˆ™**ï¼š

1. **å·¦è§„åˆ™**ï¼š
   - $\land$-å·¦ï¼š$\frac{\Gamma, A, B \vdash \Delta}{\Gamma, A \land B \vdash \Delta}$
   - $\lor$-å·¦ï¼š$\frac{\Gamma, A \vdash \Delta \quad \Gamma, B \vdash \Delta}{\Gamma, A \lor B \vdash \Delta}$

2. **å³è§„åˆ™**ï¼š
   - $\land$-å³ï¼š$\frac{\Gamma \vdash A, \Delta \quad \Gamma \vdash B, \Delta}{\Gamma \vdash A \land B, \Delta}$
   - $\lor$-å³ï¼š$\frac{\Gamma \vdash A, B, \Delta}{\Gamma \vdash A \lor B, \Delta}$

### 3.3 ç±»å‹è®ºè¯æ˜

**ç±»å‹è®ºè¯æ˜**å°†è¯æ˜ç³»ç»Ÿä¸ç±»å‹ç³»ç»Ÿç»“åˆã€‚

**è¯æ˜é¡¹**ï¼š

```lean
-- Lean 4ç±»å‹è®ºè¯æ˜ç¤ºä¾‹
theorem and_comm (a b : Prop) : a âˆ§ b â†’ b âˆ§ a :=
  fun h : a âˆ§ b =>
  have ha : a := h.left
  have hb : b := h.right
  âŸ¨hb, haâŸ©

theorem or_comm (a b : Prop) : a âˆ¨ b â†’ b âˆ¨ a :=
  fun h : a âˆ¨ b =>
  h.elim
    (fun ha : a => Or.inr ha)
    (fun hb : b => Or.inl hb)
```

## 4. åº”ç”¨é¢†åŸŸ (ç¼–å·: B.09.04.04)

### 4.1 ç¨‹åºéªŒè¯

**ç¨‹åºéªŒè¯**ä½¿ç”¨ç±»å‹è®ºéªŒè¯ç¨‹åºçš„æ­£ç¡®æ€§ã€‚

**éªŒè¯æ–¹æ³•**ï¼š

```haskell
-- ä½¿ç”¨ç±»å‹ç³»ç»ŸéªŒè¯ç¨‹åº
-- ç¡®ä¿åˆ—è¡¨åè½¬çš„æ­£ç¡®æ€§
reverse :: [a] -> [a]
reverse [] = []
reverse (x:xs) = reverse xs ++ [x]

-- ç±»å‹ä¿è¯ï¼šè¾“å…¥ç±»å‹ä¸º[a]ï¼Œè¾“å‡ºç±»å‹ä¸º[a]
-- é€šè¿‡ç±»å‹æ£€æŸ¥éªŒè¯åŸºæœ¬æ­£ç¡®æ€§
```

### 4.2 å®šç†è¯æ˜

**å®šç†è¯æ˜**ä½¿ç”¨ç±»å‹è®ºè¿›è¡Œæ•°å­¦å®šç†çš„è¯æ˜ã€‚

**è¯æ˜ç¤ºä¾‹**ï¼š

```lean
-- Lean 4å®šç†è¯æ˜ç¤ºä¾‹
theorem add_zero (n : Nat) : n + 0 = n :=
  Nat.rec
    (show 0 + 0 = 0 from rfl)
    (fun n ih => show (n + 1) + 0 = n + 1 from congr_arg Nat.succ ih)
    n

theorem add_comm (m n : Nat) : m + n = n + m :=
  Nat.rec
    (show 0 + n = n + 0 from (add_zero n).symm)
    (fun m ih => show (m + 1) + n = n + (m + 1) from
      calc
        (m + 1) + n = (m + n) + 1 := rfl
        _ = (n + m) + 1 := congr_arg Nat.succ ih
        _ = n + (m + 1) := (add_assoc n m 1).symm)
    m
```

### 4.3 å½¢å¼åŒ–æ•°å­¦

**å½¢å¼åŒ–æ•°å­¦**ä½¿ç”¨ç±»å‹è®ºå½¢å¼åŒ–æ•°å­¦ç†è®ºã€‚

**æ•°å­¦ç†è®ºå½¢å¼åŒ–**ï¼š

```lean
-- ç¾¤è®ºçš„å½¢å¼åŒ–
class Group (G : Type) where
  mul : G â†’ G â†’ G
  one : G
  inv : G â†’ G
  mul_assoc : âˆ€ a b c, mul (mul a b) c = mul a (mul b c)
  mul_one : âˆ€ a, mul a one = a
  one_mul : âˆ€ a, mul one a = a
  mul_inv : âˆ€ a, mul a (inv a) = one
  inv_mul : âˆ€ a, mul (inv a) a = one

-- å­ç¾¤çš„å®šä¹‰
def Subgroup (G : Type) [Group G] (H : Set G) : Prop :=
  one âˆˆ H âˆ§
  (âˆ€ a b, a âˆˆ H â†’ b âˆˆ H â†’ mul a b âˆˆ H) âˆ§
  (âˆ€ a, a âˆˆ H â†’ inv a âˆˆ H)
```

## 5. æŠ€æœ¯å®ç° (ç¼–å·: B.09.04.05)

### 5.1 Lean 4å®ç°

```lean
-- Lean 4ç±»å‹è®ºå®ç°
inductive Type where
  | Bool : Type
  | Nat : Type
  | Arrow : Type â†’ Type â†’ Type
  | Product : Type â†’ Type â†’ Type
  | Sum : Type â†’ Type â†’ Type

inductive Term where
  | Var : String â†’ Term
  | App : Term â†’ Term â†’ Term
  | Lam : String â†’ Type â†’ Term â†’ Term
  | Pair : Term â†’ Term â†’ Term
  | Fst : Term â†’ Term
  | Snd : Term â†’ Term
  | Inl : Term â†’ Term
  | Inr : Term â†’ Term
  | Case : Term â†’ Term â†’ Term â†’ Term

def typeCheck (ctx : List (String Ã— Type)) (term : Term) : Option Type :=
  match term with
  | Term.Var x => ctx.lookup x
  | Term.App t1 t2 => do
      let ty1 â† typeCheck ctx t1
      let ty2 â† typeCheck ctx t2
      match ty1 with
      | Type.Arrow dom cod => if ty2 = dom then some cod else none
      | _ => none
  | Term.Lam x ty body => do
      let newCtx := (x, ty) :: ctx
      let bodyTy â† typeCheck newCtx body
      some (Type.Arrow ty bodyTy)
  | _ => none
```

### 5.2 Haskellå®ç°

```haskell
-- Haskellç±»å‹è®ºå®ç°
data Type = TBool | TNat | TArrow Type Type | TProduct Type Type | TSum Type Type
  deriving (Eq, Show)

data Term = Var String
          | App Term Term
          | Lam String Type Term
          | Pair Term Term
          | Fst Term
          | Snd Term
          | Inl Term
          | Inr Term
          | Case Term Term Term
          deriving (Show)

type Context = [(String, Type)]

typeCheck :: Context -> Term -> Maybe Type
typeCheck ctx (Var x) = lookup x ctx
typeCheck ctx (App t1 t2) = do
  ty1 <- typeCheck ctx t1
  ty2 <- typeCheck ctx t2
  case ty1 of
    TArrow dom cod -> if ty2 == dom then Just cod else Nothing
    _ -> Nothing
typeCheck ctx (Lam x ty body) = do
  let newCtx = (x, ty) : ctx
  bodyTy <- typeCheck newCtx body
  return (TArrow ty bodyTy)
typeCheck ctx (Pair t1 t2) = do
  ty1 <- typeCheck ctx t1
  ty2 <- typeCheck ctx t2
  return (TProduct ty1 ty2)
typeCheck _ _ = Nothing
```

### 5.3 Coqå®ç°

```coq
(* Coqç±»å‹è®ºå®ç° *)
Inductive type : Set :=
  | TBool : type
  | TNat : type
  | TArrow : type -> type -> type
  | TProduct : type -> type -> type
  | TSum : type -> type -> type.

Inductive term : Set :=
  | Var : string -> term
  | App : term -> term -> term
  | Lam : string -> type -> term -> term
  | Pair : term -> term -> term
  | Fst : term -> term
  | Snd : term -> term
  | Inl : term -> term
  | Inr : term -> term
  | Case : term -> term -> term -> term.

Definition context := list (string * type).

Fixpoint typeCheck (ctx : context) (t : term) : option type :=
  match t with
  | Var x => lookup x ctx
  | App t1 t2 =>
      match typeCheck ctx t1 with
      | Some (TArrow dom cod) =>
          match typeCheck ctx t2 with
          | Some ty2 => if eqb_type ty2 dom then Some cod else None
          | None => None
          end
      | _ => None
      end
  | Lam x ty body =>
      let newCtx := (x, ty) :: ctx in
      match typeCheck newCtx body with
      | Some bodyTy => Some (TArrow ty bodyTy)
      | None => None
      end
  | _ => None
  end.
```

## 6. å‰æ²¿å‘å±• (ç¼–å·: B.09.04.06)

### 6.1 åŒä¼¦ç±»å‹è®º

**åŒä¼¦ç±»å‹è®º**å°†ç±»å‹è®ºä¸åŒä¼¦è®ºç»“åˆï¼Œä¸ºæ•°å­¦åŸºç¡€æä¾›æ–°çš„è§†è§’ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**ï¼š

1. **ç±»å‹ä½œä¸ºç©ºé—´**ï¼šç±»å‹è¢«è§†ä¸ºæ‹“æ‰‘ç©ºé—´
2. **è·¯å¾„ç±»å‹**ï¼šè¡¨ç¤ºç±»å‹ä¸­å…ƒç´ é—´çš„è·¯å¾„
3. **åŒä¼¦ç­‰ä»·**ï¼šç±»å‹é—´çš„ç­‰ä»·å…³ç³»

**åº”ç”¨å‰æ™¯**ï¼š

- ä¸ºæ•°å­¦åŸºç¡€æä¾›æ–°çš„å½¢å¼åŒ–æ–¹æ³•
- ç»Ÿä¸€ä»£æ•°å‡ ä½•å’Œæ‹“æ‰‘å­¦
- æ¨åŠ¨å½¢å¼åŒ–æ•°å­¦çš„å‘å±•

### 6.2 é«˜é˜¶ç±»å‹è®º

**é«˜é˜¶ç±»å‹è®º**å¼•å…¥æ›´é«˜é˜¶çš„ç±»å‹æ„é€ ã€‚

**é«˜é˜¶æ„é€ **ï¼š

1. **ç±»å‹æ„é€ å‡½æ•°**ï¼šä»ç±»å‹æ„é€ æ–°ç±»å‹
2. **ç±»å‹æ—**ï¼šå‚æ•°åŒ–çš„ç±»å‹é›†åˆ
3. **é«˜é˜¶æŠ½è±¡**ï¼šç±»å‹çº§åˆ«çš„æŠ½è±¡

### 6.3 é‡å­ç±»å‹è®º

**é‡å­ç±»å‹è®º**å°†ç±»å‹è®ºæ‰©å±•åˆ°é‡å­è®¡ç®—é¢†åŸŸï¼Œä¸ºé‡å­ç¨‹åºæä¾›ç±»å‹å®‰å…¨ä¿è¯ã€‚

**é‡å­æ‰©å±•**ï¼š

1. **é‡å­ç±»å‹**ï¼šè¡¨ç¤ºé‡å­æ€çš„ç±»å‹
2. **é‡å­æ“ä½œ**ï¼šç±»å‹çº§åˆ«çš„é‡å­æ“ä½œ
3. **é‡å­è¯æ˜**ï¼šé‡å­è®¡ç®—ä¸­çš„è¯æ˜ç³»ç»Ÿ

**æ•°å­¦åŸºç¡€**ï¼š

**é‡å­ç±»å‹ç³»ç»Ÿ**ï¼š

$$\tau ::= \text{Qubit} \mid \text{QState} \mid \text{QOp} \mid \tau_1 \otimes \tau_2 \mid \tau_1 \to \tau_2$$

**é‡å­ç±»å‹è§„åˆ™**ï¼š

$$\frac{\Gamma \vdash e : \text{Qubit}}{\Gamma \vdash \text{measure } e : \text{bool}}$$

$$\frac{\Gamma \vdash e_1 : \text{Qubit} \quad \Gamma \vdash e_2 : \text{Qubit}}{\Gamma \vdash e_1 \otimes e_2 : \text{Qubit} \otimes \text{Qubit}}$$

**å½¢å¼åŒ–å®ç°**ï¼š

```python
# Python é‡å­ç±»å‹è®ºå®ç°
from typing import TypeVar, Generic, Union
from dataclasses import dataclass
import numpy as np

# é‡å­ç±»å‹
Qubit = TypeVar('Qubit')
QState = TypeVar('QState')
QOp = TypeVar('QOp')

@dataclass
class QuantumState:
    """é‡å­æ€ç±»å‹"""
    state: np.ndarray

@dataclass
class QuantumOperation:
    """é‡å­æ“ä½œç±»å‹"""
    operation: np.ndarray

class QuantumCircuit:
    """é‡å­ç”µè·¯ç±»å‹"""
    def __init__(self):
        self.qubits = []
        self.operations = []

    def add_qubit(self) -> Qubit:
        """æ·»åŠ é‡å­æ¯”ç‰¹"""
        qubit = len(self.qubits)
        self.qubits.append(qubit)
        return qubit

    def apply_operation(self, op: QuantumOperation, qubits: list[Qubit]):
        """åº”ç”¨é‡å­æ“ä½œ"""
        self.operations.append((op, qubits))

    def measure(self, qubit: Qubit) -> bool:
        """æµ‹é‡é‡å­æ¯”ç‰¹"""
        # é‡å­æµ‹é‡å®ç°
        return np.random.choice([True, False])

# é‡å­é—¨æ“ä½œ
class HadamardGate(QuantumOperation):
    """Hadamardé—¨"""
    def __init__(self):
        self.operation = np.array([[1, 1], [1, -1]]) / np.sqrt(2)

class CNOTGate(QuantumOperation):
    """CNOTé—¨"""
    def __init__(self):
        self.operation = np.array([[1, 0, 0, 0],
                                   [0, 1, 0, 0],
                                   [0, 0, 0, 1],
                                   [0, 0, 1, 0]])
```

**é‡å­è¯æ˜ç³»ç»Ÿ**ï¼š

**é‡å­è¯æ˜è§„åˆ™**ï¼š

1. **é‡å­æ€åˆå§‹åŒ–**ï¼š$\vdash |0\rangle : \text{Qubit}$
2. **é‡å­é—¨åº”ç”¨**ï¼š$\frac{\Gamma \vdash e : \text{Qubit}}{\Gamma \vdash H(e) : \text{Qubit}}$
3. **é‡å­æµ‹é‡**ï¼š$\frac{\Gamma \vdash e : \text{Qubit}}{\Gamma \vdash \text{measure}(e) : \text{bool}}$

**åº”ç”¨ä»·å€¼**ï¼š

- **é‡å­ç¨‹åºéªŒè¯**ï¼šä¸ºé‡å­ç¨‹åºæä¾›ç±»å‹å®‰å…¨
- **é‡å­ç®—æ³•è®¾è®¡**ï¼šæ”¯æŒé‡å­ç®—æ³•çš„å½¢å¼åŒ–è®¾è®¡
- **é‡å­é”™è¯¯çº æ­£**ï¼šä¸ºé‡å­é”™è¯¯çº æ­£æä¾›ç†è®ºåŸºç¡€
- **é‡å­-ç»å…¸æ··åˆ**ï¼šæ”¯æŒé‡å­-ç»å…¸æ··åˆè®¡ç®—

### 6.4 æœºå™¨å­¦ä¹ ç±»å‹è®º

**æœºå™¨å­¦ä¹ ç±»å‹è®º**å°†ç±»å‹è®ºæ‰©å±•åˆ°æœºå™¨å­¦ä¹ é¢†åŸŸï¼Œä¸ºæœºå™¨å­¦ä¹ ç¨‹åºæä¾›ç±»å‹å®‰å…¨ã€‚

**æœºå™¨å­¦ä¹ ç±»å‹**ï¼š

1. **å¼ é‡ç±»å‹**ï¼šè¡¨ç¤ºå¤šç»´æ•°ç»„çš„ç±»å‹
2. **æ¨¡å‹ç±»å‹**ï¼šè¡¨ç¤ºæœºå™¨å­¦ä¹ æ¨¡å‹çš„ç±»å‹
3. **è®­ç»ƒç±»å‹**ï¼šè¡¨ç¤ºè®­ç»ƒè¿‡ç¨‹çš„ç±»å‹

**æ•°å­¦å®šä¹‰**ï¼š

**å¼ é‡ç±»å‹ç³»ç»Ÿ**ï¼š

$$\tau ::= \text{Tensor}[d_1, \ldots, d_n] \mid \text{Model}[\tau_1, \tau_2] \mid \text{Optimizer} \mid \tau_1 \to \tau_2$$

**å¼ é‡ç±»å‹è§„åˆ™**ï¼š

$$\frac{\Gamma \vdash e_1 : \text{Tensor}[d_1, d_2] \quad \Gamma \vdash e_2 : \text{Tensor}[d_2, d_3]}{\Gamma \vdash e_1 \cdot e_2 : \text{Tensor}[d_1, d_3]}$$

**å½¢å¼åŒ–å®ç°**ï¼š

```python
# Python æœºå™¨å­¦ä¹ ç±»å‹è®ºå®ç°
from typing import TypeVar, Generic, List, Tuple
import torch
import torch.nn as nn

# å¼ é‡ç±»å‹
Tensor = TypeVar('Tensor')
Model = TypeVar('Model')
Optimizer = TypeVar('Optimizer')

class TensorType:
    """å¼ é‡ç±»å‹"""
    def __init__(self, shape: Tuple[int, ...]):
        self.shape = shape

    def __str__(self):
        return f"Tensor{self.shape}"

class ModelType:
    """æ¨¡å‹ç±»å‹"""
    def __init__(self, input_type: TensorType, output_type: TensorType):
        self.input_type = input_type
        self.output_type = output_type

    def __str__(self):
        return f"Model[{self.input_type} -> {self.output_type}]"

# ç¥ç»ç½‘ç»œç±»å‹
class NeuralNetwork(nn.Module):
    """ç¥ç»ç½‘ç»œç±»å‹"""
    def __init__(self, input_size: int, hidden_size: int, output_size: int):
        super().__init__()
        self.layer1 = nn.Linear(input_size, hidden_size)
        self.layer2 = nn.Linear(hidden_size, output_size)
        self.activation = nn.ReLU()

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        """å‰å‘ä¼ æ’­"""
        x = self.activation(self.layer1(x))
        x = self.layer2(x)
        return x

# è®­ç»ƒç±»å‹
class TrainingType:
    """è®­ç»ƒç±»å‹"""
    def __init__(self, model: ModelType, optimizer: str, loss_fn: str):
        self.model = model
        self.optimizer = optimizer
        self.loss_fn = loss_fn

# ç±»å‹æ£€æŸ¥å™¨
def type_check_tensor(tensor: torch.Tensor, expected_type: TensorType) -> bool:
    """æ£€æŸ¥å¼ é‡ç±»å‹"""
    return tensor.shape == expected_type.shape

def type_check_model(model: nn.Module, expected_type: ModelType) -> bool:
    """æ£€æŸ¥æ¨¡å‹ç±»å‹"""
    # æ¨¡å‹ç±»å‹æ£€æŸ¥å®ç°
    return True
```

**åº”ç”¨ä»·å€¼**ï¼š

- **æœºå™¨å­¦ä¹ ç¨‹åºéªŒè¯**ï¼šä¸ºæœºå™¨å­¦ä¹ ç¨‹åºæä¾›ç±»å‹å®‰å…¨
- **æ¨¡å‹è®¾è®¡**ï¼šæ”¯æŒæœºå™¨å­¦ä¹ æ¨¡å‹çš„å½¢å¼åŒ–è®¾è®¡
- **è®­ç»ƒè¿‡ç¨‹éªŒè¯**ï¼šä¸ºè®­ç»ƒè¿‡ç¨‹æä¾›æ­£ç¡®æ€§ä¿è¯
- **è‡ªåŠ¨å¾®åˆ†**ï¼šæ”¯æŒè‡ªåŠ¨å¾®åˆ†çš„ç±»å‹å®‰å…¨

### 6.5 åˆ†å¸ƒå¼ç±»å‹è®º

**åˆ†å¸ƒå¼ç±»å‹è®º**å°†ç±»å‹è®ºæ‰©å±•åˆ°åˆ†å¸ƒå¼ç³»ç»Ÿé¢†åŸŸï¼Œä¸ºåˆ†å¸ƒå¼ç¨‹åºæä¾›ç±»å‹å®‰å…¨ã€‚

**åˆ†å¸ƒå¼ç±»å‹**ï¼š

1. **èŠ‚ç‚¹ç±»å‹**ï¼šè¡¨ç¤ºåˆ†å¸ƒå¼èŠ‚ç‚¹çš„ç±»å‹
2. **æ¶ˆæ¯ç±»å‹**ï¼šè¡¨ç¤ºèŠ‚ç‚¹é—´æ¶ˆæ¯çš„ç±»å‹
3. **ä¸€è‡´æ€§ç±»å‹**ï¼šè¡¨ç¤ºåˆ†å¸ƒå¼ä¸€è‡´æ€§çš„ç±»å‹

**æ•°å­¦å®šä¹‰**ï¼š

**åˆ†å¸ƒå¼ç±»å‹ç³»ç»Ÿ**ï¼š

$$\tau ::= \text{Node} \mid \text{Message}[\tau] \mid \text{Consensus}[\tau] \mid \tau_1 \parallel \tau_2 \mid \tau_1 \to \tau_2$$

**åˆ†å¸ƒå¼ç±»å‹è§„åˆ™**ï¼š

$$\frac{\Gamma \vdash e : \tau}{\Gamma \vdash \text{send}(e) : \text{Message}[\tau]}$$

$$\frac{\Gamma \vdash e : \text{Message}[\tau]}{\Gamma \vdash \text{receive}(e) : \tau}$$

**å½¢å¼åŒ–å®ç°**ï¼š

```rust
// Rust åˆ†å¸ƒå¼ç±»å‹è®ºå®ç°
use std::sync::{Arc, Mutex};
use tokio::sync::mpsc;

// èŠ‚ç‚¹ç±»å‹
#[derive(Clone)]
struct Node {
    id: u64,
    address: String,
}

// æ¶ˆæ¯ç±»å‹
#[derive(Clone)]
struct Message<T> {
    from: Node,
    to: Node,
    payload: T,
}

// ä¸€è‡´æ€§ç±»å‹
#[derive(Clone)]
struct Consensus<T> {
    value: T,
    quorum: Vec<Node>,
}

// åˆ†å¸ƒå¼ç³»ç»Ÿç±»å‹
struct DistributedSystem<T> {
    nodes: Vec<Node>,
    messages: Vec<Message<T>>,
}

impl<T: Clone + Send + 'static> DistributedSystem<T> {
    fn new() -> Self {
        Self {
            nodes: Vec::new(),
            messages: Vec::new(),
        }
    }

    fn add_node(&mut self, node: Node) {
        self.nodes.push(node);
    }

    fn send_message(&mut self, message: Message<T>) {
        self.messages.push(message);
    }

    fn broadcast(&mut self, from: Node, payload: T) {
        for node in &self.nodes {
            if node.id != from.id {
                let message = Message {
                    from: from.clone(),
                    to: node.clone(),
                    payload: payload.clone(),
                };
                self.send_message(message);
            }
        }
    }
}

// ç±»å‹æ£€æŸ¥å™¨
fn type_check_message<T>(message: &Message<T>) -> bool {
    // æ¶ˆæ¯ç±»å‹æ£€æŸ¥å®ç°
    true
}

fn type_check_consensus<T>(consensus: &Consensus<T>) -> bool {
    // ä¸€è‡´æ€§ç±»å‹æ£€æŸ¥å®ç°
    consensus.quorum.len() > consensus.quorum.len() / 2
}
```

**åº”ç”¨ä»·å€¼**ï¼š

- **åˆ†å¸ƒå¼ç¨‹åºéªŒè¯**ï¼šä¸ºåˆ†å¸ƒå¼ç¨‹åºæä¾›ç±»å‹å®‰å…¨
- **ä¸€è‡´æ€§ä¿è¯**ï¼šä¸ºåˆ†å¸ƒå¼ä¸€è‡´æ€§æä¾›å½¢å¼åŒ–ä¿è¯
- **æ•…éšœå®¹é”™**ï¼šä¸ºæ•…éšœå®¹é”™æœºåˆ¶æä¾›ç±»å‹å®‰å…¨
- **æ€§èƒ½ä¼˜åŒ–**ï¼šä¸ºåˆ†å¸ƒå¼ç³»ç»Ÿæ€§èƒ½ä¼˜åŒ–æä¾›ç†è®ºåŸºç¡€

## 7. æ€»ç»“ä¸å±•æœ› (ç¼–å·: B.09.04.07)

### 7.1 æ ¸å¿ƒè¦ç‚¹æ€»ç»“

1. **å»ºç«‹äº†å®Œæ•´çš„ç±»å‹è®ºç†è®ºä½“ç³»**
   - ç®€å•ç±»å‹è®ºã€å¤šæ€ç±»å‹è®ºã€ä¾èµ–ç±»å‹è®º
   - Curry-Howardå¯¹åº”
   - è¯æ˜ç³»ç»Ÿå’Œç±»å‹ç³»ç»Ÿ

2. **å®ç°äº†å¤šè¡¨å¾è¡¨è¾¾**
   - æ•°å­¦ç¬¦å·è¡¨å¾ï¼šç±»å‹è®ºè¯­æ³•å’Œè§„åˆ™
   - å¯è§†åŒ–å›¾è¡¨ï¼šç±»å‹æ¨å¯¼å›¾
   - å†å²å‘å±•è¡¨å¾ï¼šç±»å‹è®ºå‘å±•å†ç¨‹
   - å®ä¾‹è¡¨å¾ï¼šä¸°å¯Œçš„ç¼–ç¨‹å®ä¾‹
   - æ€ç»´è¿‡ç¨‹è¡¨å¾ï¼šç±»å‹æ¨å¯¼è¿‡ç¨‹
   - æŠ€æœ¯å®ç°è¡¨å¾ï¼šå¤šç§ç¼–ç¨‹è¯­è¨€å®ç°

3. **å»ºç«‹äº†åº”ç”¨ä½“ç³»**
   - ç¨‹åºéªŒè¯åº”ç”¨ï¼šç±»å‹å®‰å…¨ã€ç¨‹åºæ­£ç¡®æ€§
   - å®šç†è¯æ˜åº”ç”¨ï¼šæ•°å­¦å®šç†çš„å½¢å¼åŒ–è¯æ˜
   - å½¢å¼åŒ–æ•°å­¦åº”ç”¨ï¼šæ•°å­¦ç†è®ºçš„å½¢å¼åŒ–

### 7.2 å‘å±•è¶‹åŠ¿

1. **æ™ºèƒ½åŒ–å‘å±•**
   - æœºå™¨å­¦ä¹ åœ¨ç±»å‹æ¨å¯¼ä¸­çš„åº”ç”¨
   - è‡ªåŠ¨ç±»å‹æ¨æ–­å’Œè¯æ˜
   - æ™ºèƒ½ç¨‹åºåˆæˆ
   - ç¥ç»ç½‘ç»œè¾…åŠ©ç±»å‹æ£€æŸ¥

2. **é‡å­åŒ–å‘å±•**
   - é‡å­ç±»å‹è®º
   - é‡å­è®¡ç®—ä¸­çš„ç±»å‹ç³»ç»Ÿ
   - é‡å­-ç»å…¸æ··åˆç±»å‹è®º
   - é‡å­é”™è¯¯çº æ­£ç±»å‹ç³»ç»Ÿ

3. **åˆ†å¸ƒå¼å‘å±•**
   - åˆ†å¸ƒå¼ç±»å‹è®º
   - åŒºå—é“¾ç±»å‹ç³»ç»Ÿ
   - å…±è¯†æœºåˆ¶ç±»å‹å®‰å…¨
   - é›¶çŸ¥è¯†è¯æ˜ç±»å‹è®º

4. **åº”ç”¨æ‰©å±•**
   - æ›´å¤šé¢†åŸŸçš„ç±»å‹è®ºåº”ç”¨
   - ç±»å‹è®ºåœ¨äººå·¥æ™ºèƒ½ä¸­çš„åº”ç”¨
   - ç±»å‹è®ºåœ¨åŒºå—é“¾ä¸­çš„åº”ç”¨
   - ç±»å‹è®ºåœ¨ç‰©è”ç½‘ä¸­çš„åº”ç”¨

5. **å½¢å¼åŒ–å‘å±•**
   - åŒä¼¦ç±»å‹è®ºæ·±åŒ–
   - é«˜é˜¶ç±»å‹è®ºæ‰©å±•
   - ä¾èµ–ç±»å‹è®ºä¼˜åŒ–
   - ç±»å‹è®ºä¸è¯æ˜è®ºç»Ÿä¸€

### 7.3 æŒ‘æˆ˜ä¸æœºé‡

**ä¸»è¦æŒ‘æˆ˜**ï¼š

1. **ç±»å‹æ¨å¯¼å¤æ‚æ€§**ï¼šå¤æ‚ç±»å‹ç³»ç»Ÿçš„æ¨å¯¼æ•ˆç‡
2. **è¡¨è¾¾èƒ½åŠ›**ï¼šå¹³è¡¡è¡¨è¾¾èƒ½åŠ›å’Œå¯åˆ¤å®šæ€§
3. **ç”¨æˆ·å‹å¥½æ€§**ï¼šæé«˜ç±»å‹ç³»ç»Ÿçš„æ˜“ç”¨æ€§

**å‘å±•æœºé‡**ï¼š

1. **æ–°æŠ€æœ¯èåˆ**ï¼šé‡å­è®¡ç®—ã€äººå·¥æ™ºèƒ½ã€åŒºå—é“¾
2. **åº”ç”¨æ‰©å±•**ï¼šæ›´å¤šé¢†åŸŸçš„åº”ç”¨
3. **æ ‡å‡†åŒ–**ï¼šå»ºç«‹ç±»å‹è®ºæ ‡å‡†

---

**ç›¸å…³é“¾æ¥**ï¼š

- [è¯æ˜ç³»ç»ŸåŸºç¡€](./01-è¯æ˜ç³»ç»ŸåŸºç¡€-æ·±åº¦æ‰©å±•ç‰ˆ.md)
- [è‡ªåŠ¨å®šç†è¯æ˜](./02-è‡ªåŠ¨å®šç†è¯æ˜-æ·±åŒ–ç‰ˆ.md)
- [æ¨¡å‹æ£€æµ‹](./03-æ¨¡å‹æ£€æµ‹-æ·±åŒ–ç‰ˆ.md)
- [æ¨¡å‹è®ºåŸºç¡€](../10-è¯­ä¹‰æ¨¡å‹/æ¨¡å‹è®º/01-æ¨¡å‹è®ºåŸºç¡€-æ·±åº¦æ‰©å±•ç‰ˆ.md)

**å‚è€ƒæ–‡çŒ®**ï¼š

1. Martin-LÃ¶f, P. (1984). "Intuitionistic Type Theory"
2. Girard, J. Y., Lafont, Y., & Taylor, P. (1989). "Proofs and Types"
3. Pierce, B. C. (2002). "Types and Programming Languages"
4. Coquand, T., & Huet, G. (1988). "The Calculus of Constructions"
5. The Univalent Foundations Program (2013). "Homotopy Type Theory: Univalent Foundations of Mathematics"
6. Curry, H. B., & Feys, R. (1958). "Combinatory Logic"
7. Howard, W. A. (1980). "The Formulae-as-Types Notion of Construction"
8. de Bruijn, N. G. (1972). "Lambda Calculus Notation with Nameless Dummies"
9. Reynolds, J. C. (1974). "Towards a Theory of Type Structure"
10. Wadler, P. (2015). "Propositions as Types"

---

## ğŸ—ºï¸ 8. ç±»å‹è®ºçŸ¥è¯†å›¾è°± (ç¼–å·: B.09.04.08)

### 8.1 ç±»å‹è®ºå‘å±•è°±ç³»

```text
[1930s]                           [1970s]                        [2000s+]
   â”‚                                 â”‚                              â”‚
   â–¼                                 â–¼                              â–¼
[ç®€å•ç±»å‹Î»æ¼”ç®—]              [Martin-LÃ¶fç±»å‹è®º]             [åŒä¼¦ç±»å‹è®º]
  (Church)                    (ä¾èµ–ç±»å‹)                    (HoTT/UF)
   â”‚                                 â”‚                              â”‚
   â”œâ”€â”€â”€â”€â–º [System F]                 â”‚                              â”‚
   â”‚      (å¤šæ€ç±»å‹)                 â”‚                              â”‚
   â”‚      (Girard/Reynolds)          â”‚                              â”‚
   â”‚           â”‚                     â”‚                              â”‚
   â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
   â”‚                                 â”‚
   â”‚                    [å½’çº³æ„é€ æ¼”ç®— CIC]
   â”‚                        (Coquand)
   â”‚                             â”‚
   â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
   â”‚                    â”‚                 â”‚
   â”‚                  [Coq]            [Lean]
   â”‚                    â”‚                 â”‚
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â”‚
              [ç°ä»£è¯æ˜åŠ©æ‰‹ç”Ÿæ€]
```

### 8.2 ç±»å‹ç³»ç»Ÿå±‚æ¬¡å›¾

```text
                    [ç±»å‹ç³»ç»Ÿå±‚æ¬¡]
                          â”‚
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                     â”‚                     â”‚
[ç®€å•ç±»å‹]            [å¤šæ€ç±»å‹]            [ä¾èµ–ç±»å‹]
    â”‚                     â”‚                     â”‚
â”Œâ”€â”€â”€â”´â”€â”€â”€â”           â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
â”‚       â”‚           â”‚     â”‚     â”‚          â”‚    â”‚    â”‚
åŸºç¡€  å‡½æ•°       å‚æ•°  é«˜é˜¶   çº¦æŸ      Î ç±»å‹ Î£ç±»å‹ æ’ç­‰
ç±»å‹  ç±»å‹       å¤šæ€  å¤šæ€   å¤šæ€           â”‚    â”‚   ç±»å‹
â”‚       â”‚           â”‚     â”‚     â”‚          â”‚    â”‚    â”‚
int  Aâ†’B       âˆ€Î±.Ï„  F[Î±]  Î±:Îº       (x:A)â†’B  Î£x:A.B Id
bool            â”‚           â”‚          â”‚         â”‚
    â”‚           â”‚           â”‚          â”‚         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                   [è¡¨è¾¾èƒ½åŠ›é€’å¢]
```

### 8.3 Curry-Howardå¯¹åº”å®Œæ•´å›¾

```text
        [é€»è¾‘]                        [ç±»å‹è®º]                      [èŒƒç•´è®º]
           â”‚                             â”‚                             â”‚
           â–¼                             â–¼                             â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   å‘½é¢˜ P     â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   ç±»å‹ A     â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   å¯¹è±¡ A     â”‚
    â”‚   è¯æ˜ Ï€:P   â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   é¡¹ t:A     â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   å…ƒç´  tâˆˆA   â”‚
    â”‚   è•´æ¶µ AâŠƒB   â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   å‡½æ•° Aâ†’B   â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   æ€å°„ Aâ†’B   â”‚
    â”‚   åˆå– Aâˆ§B   â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   ç§¯ AÃ—B     â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   ç§¯ AÃ—B     â”‚
    â”‚   æå– Aâˆ¨B   â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   å’Œ A+B     â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   ä½™ç§¯ A+B   â”‚
    â”‚   çœŸ âŠ¤       â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   å•ä½ 1     â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   ç»ˆå¯¹è±¡ 1   â”‚
    â”‚   å‡ âŠ¥       â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   ç©º 0       â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   åˆå¯¹è±¡ 0   â”‚
    â”‚   å…¨ç§° âˆ€x:A  â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   Î ç±»å‹      â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   ä¾èµ–ç§¯     â”‚
    â”‚   å­˜åœ¨ âˆƒx:A  â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   Î£ç±»å‹      â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   ä¾èµ–å’Œ     â”‚
    â”‚   æ’ç­‰ a=b   â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   Idç±»å‹     â”‚ â•â•â•â•â•â•â•â•â•â•â•â• â”‚   æ’ç­‰æ€å°„   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                             â”‚                             â”‚
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                         â”‚
                           [ä¸‰ä½ä¸€ä½“ï¼šLogic-Type-Category]
```

### 8.4 è¯æ˜åŠ©æ‰‹é€‰æ‹©å†³ç­–æ ‘

```text
                    [é€‰æ‹©è¯æ˜åŠ©æ‰‹]
                          â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚                 â”‚                 â”‚
    [ä¸»è¦ç”¨é€”]        [é€»è¾‘åŸºç¡€]        [ç”Ÿæ€ç³»ç»Ÿ]
        â”‚                 â”‚                 â”‚
   â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
   â”‚    â”‚    â”‚       â”‚    â”‚    â”‚       â”‚    â”‚    â”‚
æ•°å­¦  ç¨‹åº  æ•™å­¦    æ„é€   ç»å…¸  æ··åˆ   æˆç†Ÿ  æ–°å…´  å°ä¼—
å½¢å¼åŒ– éªŒè¯        ä¸»ä¹‰  é€»è¾‘           â”‚    â”‚    â”‚
   â”‚    â”‚    â”‚       â”‚    â”‚    â”‚       â”‚    â”‚    â”‚
   â–¼    â–¼    â–¼       â–¼    â–¼    â–¼       â–¼    â–¼    â–¼
 Lean  Coq  Agda   Agda Isabelle Coq+  Coq  Lean4 Idris
Mathlib CompCert        HOL   å…¬ç†   â”‚    â”‚
   â”‚    â”‚    â”‚       â”‚    â”‚    â”‚       â”‚    â”‚
   â””â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”˜
                          â”‚
               [æ ¹æ®éœ€æ±‚ç»¼åˆè¯„ä¼°]
```

---

**æœ€åæ›´æ–°**: 2025å¹´12æœˆ1æ—¥
**çŠ¶æ€**: âœ… å·²å®Œæˆï¼ˆå«ç±»å‹è®ºå›¾è°±æ‰©å±•ï¼‰
