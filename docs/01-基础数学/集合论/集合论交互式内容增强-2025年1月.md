# 集合论交互式内容增强 - 2025年1月

## 概述

本文档为集合论教育应用添加交互式内容，包括可视化演示、交互式练习和在线测试。

## 1. 可视化演示

### 1.1 集合运算可视化

**文氏图交互演示**:

```html
<!-- 文氏图交互演示 -->
<div class="venn-diagram-container">
  <canvas id="vennCanvas" width="600" height="400"></canvas>
  <div class="controls">
    <button onclick="showUnion()">并集</button>
    <button onclick="showIntersection()">交集</button>
    <button onclick="showDifference()">差集</button>
  </div>
</div>

<script>
function drawVennDiagram() {
  const canvas = document.getElementById('vennCanvas');
  const ctx = canvas.getContext('2d');

  // 绘制集合A
  ctx.beginPath();
  ctx.arc(200, 200, 80, 0, 2 * Math.PI);
  ctx.strokeStyle = 'blue';
  ctx.stroke();
  ctx.fillStyle = 'rgba(0, 0, 255, 0.2)';
  ctx.fill();

  // 绘制集合B
  ctx.beginPath();
  ctx.arc(300, 200, 80, 0, 2 * Math.PI);
  ctx.strokeStyle = 'red';
  ctx.stroke();
  ctx.fillStyle = 'rgba(255, 0, 0, 0.2)';
  ctx.fill();
}

function showUnion() {
  const canvas = document.getElementById('vennCanvas');
  const ctx = canvas.getContext('2d');

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawVennDiagram();

  // 高亮并集区域
  ctx.fillStyle = 'rgba(255, 0, 255, 0.3)';
  ctx.beginPath();
  ctx.arc(200, 200, 80, 0, 2 * Math.PI);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(300, 200, 80, 0, 2 * Math.PI);
  ctx.fill();
}
</script>
```

### 1.2 函数关系可视化

**函数映射演示**:

```html
<!-- 函数映射可视化 -->
<div class="function-mapping">
  <div class="domain" id="domain">
    <div class="element" data-value="1">1</div>
    <div class="element" data-value="2">2</div>
    <div class="element" data-value="3">3</div>
  </div>
  <div class="function-arrow">f(x) = x²</div>
  <div class="codomain" id="codomain">
    <div class="element" data-value="1">1</div>
    <div class="element" data-value="4">4</div>
    <div class="element" data-value="9">9</div>
  </div>
</div>

<style>
.function-mapping {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 30px;
  margin: 30px 0;
}

.domain, .codomain {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.element {
  padding: 10px;
  border: 2px solid #333;
  border-radius: 5px;
  background: white;
  cursor: pointer;
  transition: all 0.3s ease;
}

.element:hover {
  background: #e0e0e0;
  transform: scale(1.1);
}
</style>
```

## 2. 交互式练习

### 2.1 集合运算练习

**动态集合构建器**:

```html
<!-- 动态集合构建器 -->
<div class="set-builder">
  <h3>集合构建练习</h3>
  <div class="builder-container">
    <div class="input-section">
      <label>集合A:</label>
      <input type="text" id="setAInput" placeholder="输入元素，用逗号分隔">
      <button onclick="buildSetA()">构建集合A</button>
    </div>
    <div class="input-section">
      <label>集合B:</label>
      <input type="text" id="setBInput" placeholder="输入元素，用逗号分隔">
      <button onclick="buildSetB()">构建集合B</button>
    </div>
    <div class="operation-section">
      <button onclick="calculateUnion()">A ∪ B</button>
      <button onclick="calculateIntersection()">A ∩ B</button>
      <button onclick="calculateDifference()">A - B</button>
    </div>
    <div class="result-section">
      <h4>结果:</h4>
      <div id="result" class="result-display"></div>
    </div>
  </div>
</div>

<script>
let setA = new Set();
let setB = new Set();

function buildSetA() {
  const input = document.getElementById('setAInput').value;
  const elements = input.split(',').map(e => e.trim()).filter(e => e);
  setA = new Set(elements);
}

function buildSetB() {
  const input = document.getElementById('setBInput').value;
  const elements = input.split(',').map(e => e.trim()).filter(e => e);
  setB = new Set(elements);
}

function calculateUnion() {
  const union = new Set([...setA, ...setB]);
  displayResult('并集 A ∪ B', union);
}

function calculateIntersection() {
  const intersection = new Set([...setA].filter(x => setB.has(x)));
  displayResult('交集 A ∩ B', intersection);
}

function calculateDifference() {
  const difference = new Set([...setA].filter(x => !setB.has(x)));
  displayResult('差集 A - B', difference);
}

function displayResult(operation, set) {
  const resultDiv = document.getElementById('result');
  resultDiv.innerHTML = `<strong>${operation}:</strong> {${Array.from(set).join(', ')}}`;
}
</script>
```

## 3. 在线测试系统

### 3.1 自适应测试

**智能测试系统**:

```html
<!-- 智能测试系统 -->
<div class="adaptive-test">
  <h3>集合论自适应测试</h3>
  <div class="test-container">
    <div class="test-info">
      <span>题目: <span id="questionNumber">1</span>/10</span>
      <span>难度: <span id="difficulty">基础</span></span>
      <span>得分: <span id="score">0</span></span>
    </div>
    <div class="question-display">
      <h4 id="questionText">题目内容</h4>
      <div id="questionOptions" class="options"></div>
    </div>
    <div class="test-controls">
      <button id="submitBtn" onclick="submitAnswer()">提交答案</button>
      <button id="nextBtn" onclick="nextQuestion()" style="display:none;">下一题</button>
    </div>
  </div>
</div>

<script>
const questions = [
  {
    question: "设A = {1,2,3}, B = {2,3,4}，则A ∪ B = ?",
    options: ["{1,2,3}", "{2,3,4}", "{1,2,3,4}", "{2,3}"],
    correct: 2,
    difficulty: "基础"
  },
  {
    question: "设A = {1,2,3}, B = {2,3,4}，则A ∩ B = ?",
    options: ["{1,2,3}", "{2,3,4}", "{1,2,3,4}", "{2,3}"],
    correct: 3,
    difficulty: "基础"
  }
];

let currentQuestion = 0;
let score = 0;

function loadQuestion() {
  const question = questions[currentQuestion];
  document.getElementById('questionNumber').textContent = currentQuestion + 1;
  document.getElementById('questionText').textContent = question.question;

  const optionsDiv = document.getElementById('questionOptions');
  optionsDiv.innerHTML = '';

  question.options.forEach((option, index) => {
    const optionDiv = document.createElement('div');
    optionDiv.className = 'option';
    optionDiv.textContent = option;
    optionDiv.onclick = () => selectOption(index);
    optionsDiv.appendChild(optionDiv);
  });
}

function selectOption(index) {
  document.querySelectorAll('.option').forEach(opt => opt.classList.remove('selected'));
  document.querySelectorAll('.option')[index].classList.add('selected');
}

function submitAnswer() {
  const selected = document.querySelector('.option.selected');
  if (!selected) {
    alert('请选择一个答案');
    return;
  }

  const selectedIndex = Array.from(document.querySelectorAll('.option')).indexOf(selected);
  const question = questions[currentQuestion];

  if (selectedIndex === question.correct) {
    score += 10;
    document.getElementById('score').textContent = score;
    alert('回答正确！');
  } else {
    alert(`回答错误。正确答案是: ${question.options[question.correct]}`);
  }

  document.getElementById('submitBtn').style.display = 'none';
  document.getElementById('nextBtn').style.display = 'inline';
}

function nextQuestion() {
  currentQuestion++;
  if (currentQuestion < questions.length) {
    loadQuestion();
  } else {
    showFinalResult();
  }
}

function showFinalResult() {
  const container = document.querySelector('.test-container');
  container.innerHTML = `
    <h3>测试完成！</h3>
    <p>最终得分: ${score}/${questions.length * 10}</p>
    <p>正确率: ${Math.round(score / (questions.length * 10) * 100)}%</p>
  `;
}

loadQuestion();
</script>
```

## 总结

### 交互式内容增强成果

1. **可视化演示**: 文氏图、函数映射演示
2. **交互式练习**: 动态集合构建器
3. **在线测试**: 自适应测试系统

### 教育价值

- **直观理解**: 通过可视化加深理解
- **实践操作**: 通过交互练习巩固知识
- **即时反馈**: 通过在线测试获得反馈

---

**文档状态**: 交互式内容增强完成
**更新日期**: 2025年1月
**维护者**: FormalMath项目组
