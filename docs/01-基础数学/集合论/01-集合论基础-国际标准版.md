# 集合论基础 - 国际标准版 / Set Theory Foundation - International Standard Edition

## 目录

- [集合论基础 - 国际标准版 / Set Theory Foundation - International Standard Edition](#集合论基础---国际标准版--set-theory-foundation---international-standard-edition)
  - [目录](#目录)
  - [概述](#概述)
  - [1. 基本概念](#1-基本概念)
    - [1.1 集合的定义](#11-集合的定义)
    - [1.2 元素关系](#12-元素关系)
  - [2. ZFC公理系统](#2-zfc公理系统)
    - [2.1 存在性公理](#21-存在性公理)
    - [2.2 构造性公理](#22-构造性公理)
    - [2.3 分离公理模式](#23-分离公理模式)
    - [2.4 替换公理模式](#24-替换公理模式)
    - [2.5 无穷公理](#25-无穷公理)
    - [2.6 正则公理](#26-正则公理)
    - [2.7 选择公理](#27-选择公理)
  - [3. 集合运算](#3-集合运算)
    - [3.1 基本运算](#31-基本运算)
    - [3.2 笛卡尔积](#32-笛卡尔积)
  - [4. 关系与函数](#4-关系与函数)
    - [4.1 关系](#41-关系)
    - [4.2 函数](#42-函数)
  - [5. 序数与基数](#5-序数与基数)
    - [5.1 序数](#51-序数)
    - [5.2 基数](#52-基数)
  - [6. 形式化实现](#6-形式化实现)
    - [6.1 Lean 4 实现](#61-lean-4-实现)
    - [6.2 Haskell 实现](#62-haskell-实现)
  - [7. 参考文献](#7-参考文献)
    - [经典教材](#经典教材)
    - [现代教材](#现代教材)
    - [课程资源](#课程资源)

## 概述

本文档基于以下国际标准制定：

- **Jech, T.**: Set Theory (3rd Millennium Edition)
- **Kunen, K.**: Set Theory: An Introduction to Independence Proofs
- **Enderton, H.B.**: Elements of Set Theory
- **MIT OpenCourseWare**: 18.701 Algebra I
- **Stanford University**: Math 120A Group Theory

## 1. 基本概念

### 1.1 集合的定义

**定义 1.1** (集合 / Set)
在ZFC公理系统中，集合是满足外延公理的对象。两个集合相等当且仅当它们包含相同的元素。

**形式化表述**:
对于任意集合 $A$ 和 $B$，
$$A = B \iff \forall x (x \in A \leftrightarrow x \in B)$$

### 1.2 元素关系

**定义 1.2** (属于关系 / Element Relation)
元素关系 $\in$ 是集合论的基本关系，表示一个对象是另一个集合的元素。

**公理 1.1** (外延公理 / Axiom of Extensionality)
$$\forall x \forall y [\forall z (z \in x \leftrightarrow z \in y) \rightarrow x = y]$$

## 2. ZFC公理系统

### 2.1 存在性公理

**公理 2.1** (空集公理 / Axiom of Empty Set)
$$\exists x \forall y (y \notin x)$$

**定义 2.1** (空集 / Empty Set)
空集是唯一不包含任何元素的集合，记作 $\emptyset$。

**公理 2.2** (配对公理 / Axiom of Pairing)
$$\forall x \forall y \exists z \forall w (w \in z \leftrightarrow w = x \vee w = y)$$

**定义 2.2** (无序对 / Unordered Pair)
对于集合 $a$ 和 $b$，它们的无序对是 $\{a, b\}$。

### 2.2 构造性公理

**公理 2.3** (并集公理 / Axiom of Union)
$$\forall F \exists A \forall x (x \in A \leftrightarrow \exists B (B \in F \wedge x \in B))$$

**定义 2.3** (并集 / Union)
对于集合族 $F$，其并集是 $\bigcup F = \{x \mid \exists B \in F (x \in B)\}$。

**公理 2.4** (幂集公理 / Axiom of Power Set)
$$\forall x \exists y \forall z (z \in y \leftrightarrow z \subseteq x)$$

**定义 2.4** (幂集 / Power Set)
对于集合 $A$，其幂集是 $P(A) = \{B \mid B \subseteq A\}$。

### 2.3 分离公理模式

**公理模式 2.5** (分离公理模式 / Axiom Schema of Separation)
对于每个公式 $\phi(x, z, w_1, \ldots, w_n)$，
$$\forall z \forall w_1 \ldots \forall w_n \exists y \forall x (x \in y \leftrightarrow x \in z \wedge \phi(x, z, w_1, \ldots, w_n))$$

**定义 2.5** (分离 / Separation)
对于集合 $A$ 和性质 $P(x)$，分离集是 $\{x \in A \mid P(x)\}$。

### 2.4 替换公理模式

**公理模式 2.6** (替换公理模式 / Axiom Schema of Replacement)
对于每个公式 $\phi(x, y, A, w_1, \ldots, w_n)$，
$$\forall A \forall w_1 \ldots \forall w_n [\forall x \in A \exists! y \phi(x, y, A, w_1, \ldots, w_n) \rightarrow \exists B \forall y (y \in B \leftrightarrow \exists x \in A \phi(x, y, A, w_1, \ldots, w_n))]$$

### 2.5 无穷公理

**公理 2.7** (无穷公理 / Axiom of Infinity)
$$\exists x [\emptyset \in x \wedge \forall y (y \in x \rightarrow y \cup \{y\} \in x)]$$

**定义 2.6** (归纳集 / Inductive Set)
集合 $A$ 是归纳集，如果 $\emptyset \in A$ 且对于任意 $x \in A$，有 $x \cup \{x\} \in A$。

### 2.6 正则公理

**公理 2.8** (正则公理 / Axiom of Regularity)
$$\forall x [x \neq \emptyset \rightarrow \exists y (y \in x \wedge y \cap x = \emptyset)]$$

### 2.7 选择公理

**公理 2.9** (选择公理 / Axiom of Choice)
$$\forall F [\emptyset \notin F \wedge \forall x \forall y (x \in F \wedge y \in F \wedge x \neq y \rightarrow x \cap y = \emptyset) \rightarrow \exists C \forall x \in F \exists! z (z \in x \cap C)]$$

## 3. 集合运算

### 3.1 基本运算

**定义 3.1** (并集 / Union)
$$A \cup B = \{x \mid x \in A \vee x \in B\}$$

**定义 3.2** (交集 / Intersection)
$$A \cap B = \{x \mid x \in A \wedge x \in B\}$$

**定义 3.3** (差集 / Set Difference)
$$A \setminus B = \{x \mid x \in A \wedge x \notin B\}$$

**定义 3.4** (对称差 / Symmetric Difference)
$$A \triangle B = (A \setminus B) \cup (B \setminus A)$$

### 3.2 笛卡尔积

**定义 3.5** (有序对 / Ordered Pair)
$$(a, b) = \{\{a\}, \{a, b\}\}$$

**定理 3.1** (有序对的性质)
$$(a, b) = (c, d) \iff a = c \wedge b = d$$

**定义 3.6** (笛卡尔积 / Cartesian Product)
$$A \times B = \{(a, b) \mid a \in A \wedge b \in B\}$$

## 4. 关系与函数

### 4.1 关系

**定义 4.1** (二元关系 / Binary Relation)
从集合 $A$ 到集合 $B$ 的二元关系是 $A \times B$ 的子集。

**定义 4.2** (关系的性质)
设 $R$ 是集合 $A$ 上的关系：

1. **自反性** (Reflexivity): $\forall x \in A (x R x)$
2. **非自反性** (Irreflexivity): $\forall x \in A (\neg x R x)$
3. **对称性** (Symmetry): $\forall x, y \in A (x R y \rightarrow y R x)$
4. **反对称性** (Antisymmetry): $\forall x, y \in A (x R y \wedge y R x \rightarrow x = y)$
5. **传递性** (Transitivity): $\forall x, y, z \in A (x R y \wedge y R z \rightarrow x R z)$

**定义 4.3** (等价关系 / Equivalence Relation)
满足自反性、对称性和传递性的关系称为等价关系。

**定义 4.4** (偏序关系 / Partial Order)
满足自反性、反对称性和传递性的关系称为偏序关系。

### 4.2 函数

**定义 4.5** (函数 / Function)
函数是从集合 $A$ 到集合 $B$ 的关系 $f$，满足：

1. $\forall x \in A \exists y \in B ((x, y) \in f)$ (定义域覆盖)
2. $\forall x \in A \forall y, z \in B ((x, y) \in f \wedge (x, z) \in f \rightarrow y = z)$ (单值性)

**定义 4.6** (函数的性质)
设 $f: A \rightarrow B$ 是函数：

1. **单射** (Injective): $\forall x, y \in A (f(x) = f(y) \rightarrow x = y)$
2. **满射** (Surjective): $\forall y \in B \exists x \in A (f(x) = y)$
3. **双射** (Bijective): $f$ 既是单射又是满射

## 5. 序数与基数

### 5.1 序数

**定义 5.1** (传递集 / Transitive Set)
集合 $A$ 是传递的，如果 $\forall x \in A (x \subseteq A)$。

**定义 5.2** (序数 / Ordinal Number)
序数是传递的、良序的集合。

**定理 5.1** (序数的性质)

1. 每个序数的元素都是序数
2. 序数的序数也是序数
3. 对于任意序数 $\alpha, \beta$，要么 $\alpha \in \beta$，要么 $\alpha = \beta$，要么 $\beta \in \alpha$

### 5.2 基数

**定义 5.3** (等势 / Equinumerous)
集合 $A$ 和 $B$ 等势，记作 $A \approx B$，如果存在从 $A$ 到 $B$ 的双射。

**定义 5.4** (基数 / Cardinal Number)
基数是等势类中的最小序数。

**定义 5.5** (基数比较)
对于基数 $\kappa$ 和 $\lambda$：

- $\kappa \leq \lambda$ 如果存在从 $\kappa$ 到 $\lambda$ 的单射
- $\kappa < \lambda$ 如果 $\kappa \leq \lambda$ 且 $\kappa \neq \lambda$

**定理 5.2** (康托尔-伯恩斯坦定理 / Cantor-Bernstein Theorem)
如果 $\kappa \leq \lambda$ 且 $\lambda \leq \kappa$，则 $\kappa = \lambda$。

## 6. 形式化实现

### 6.1 Lean 4 实现

```lean
/--
# 集合论基础 - Lean4形式化实现
# Set Theory Foundation - Lean4 Formal Implementation

基于Mathlib的集合论实现
Based on Mathlib set theory implementation
--/

import Mathlib.Data.Set.Basic
import Mathlib.Logic.Basic
import Mathlib.Order.Basic

-- 集合类型定义
def Set (α : Type u) := Set α

-- 外延公理
theorem extensionality {α : Type u} {A B : Set α} :
  A = B ↔ ∀ x, x ∈ A ↔ x ∈ B := by
  simp [Set.ext_iff]

-- 空集公理
theorem empty_set_exists {α : Type u} :
  ∃ (A : Set α), ∀ x, x ∉ A := by
  use ∅
  simp

-- 配对公理
theorem pairing {α : Type u} {a b : α} :
  ∃ (A : Set α), ∀ x, x ∈ A ↔ x = a ∨ x = b := by
  use {a, b}
  simp

-- 并集公理
theorem union_exists {α : Type u} {F : Set (Set α)} :
  ∃ (A : Set α), ∀ x, x ∈ A ↔ ∃ B ∈ F, x ∈ B := by
  use ⋃₀ F
  simp

-- 幂集公理
theorem power_set_exists {α : Type u} {A : Set α} :
  ∃ (P : Set (Set α)), ∀ B, B ∈ P ↔ B ⊆ A := by
  use 𝒫 A
  simp

-- 分离公理模式
theorem separation {α : Type u} {A : Set α} {P : α → Prop} :
  ∃ (B : Set α), ∀ x, x ∈ B ↔ x ∈ A ∧ P x := by
  use {x ∈ A | P x}
  simp

-- 选择公理
theorem choice {α : Type u} {F : Set (Set α)} (h : ∅ ∉ F) (h' : ∀ A B ∈ F, A ≠ B → A ∩ B = ∅) :
  ∃ (C : Set α), ∀ A ∈ F, ∃! x, x ∈ A ∩ C := by
  -- 这里需要选择公理
  sorry

-- 序数定义
class Ordinal (α : Type u) where
  transitive : ∀ x ∈ α, x ⊆ α
  well_ordered : IsWellOrder α (· ∈ ·)

-- 基数定义
def Cardinal (α : Type u) := 
  { β : Type u // Nonempty (α ≃ β) ∧ ∀ γ : Type u, Nonempty (α ≃ γ) → Nonempty (β ↪ γ) }

-- 基数比较
def Cardinal.le {α β : Type u} (κ : Cardinal α) (λ : Cardinal β) :=
  Nonempty (α ↪ β)

-- 康托尔-伯恩斯坦定理
theorem cantor_bernstein {α β : Type u} (κ : Cardinal α) (λ : Cardinal β) :
  Cardinal.le κ λ → Cardinal.le λ κ → Nonempty (α ≃ β) := by
  -- 需要证明康托尔-伯恩斯坦定理
  sorry
```

### 6.2 Haskell 实现

```haskell
{-# LANGUAGE GADTs, TypeFamilies, DataKinds #-}

import Data.Set (Set)
import qualified Data.Set as Set
import Data.Map (Map)
import qualified Data.Map as Map

-- 集合类型
type Set a = Set a

-- 外延公理
extensionality :: (Ord a) => Set a -> Set a -> Bool
extensionality a b = a == b

-- 空集
emptySet :: Set a
emptySet = Set.empty

-- 配对
pair :: (Ord a) => a -> a -> Set a
pair x y = Set.fromList [x, y]

-- 并集
union :: (Ord a) => Set a -> Set a -> Set a
union = Set.union

-- 交集
intersection :: (Ord a) => Set a -> Set a -> Set a
intersection = Set.intersection

-- 差集
difference :: (Ord a) => Set a -> Set a -> Set a
difference = Set.difference

-- 幂集
powerSet :: (Ord a) => Set a -> Set (Set a)
powerSet s = Set.fromList (map Set.fromList (subsequences (Set.toList s)))

-- 笛卡尔积
cartesianProduct :: (Ord a, Ord b) => Set a -> Set b -> Set (a, b)
cartesianProduct a b = Set.fromList [(x, y) | x <- Set.toList a, y <- Set.toList b]

-- 关系类型
type Relation a b = Set (a, b)

-- 关系性质
isReflexive :: (Ord a) => Relation a a -> Set a -> Bool
isReflexive r domain = all (\x -> Set.member (x, x) r) domain

isSymmetric :: (Ord a) => Relation a a -> Bool
isSymmetric r = all (\(x, y) -> Set.member (y, x) r) r

isTransitive :: (Ord a) => Relation a a -> Bool
isTransitive r = all (\(x, y) -> all (\(y', z) -> 
  if y == y' then Set.member (x, z) r else True) r) r

-- 函数类型
type Function a b = Relation a b

-- 函数性质
isFunction :: (Ord a, Ord b) => Function a b -> Set a -> Bool
isFunction f domain = all (\x -> 
  length [y | (x', y) <- Set.toList f, x' == x] == 1) domain

isInjective :: (Ord a, Ord b) => Function a b -> Bool
isInjective f = all (\(x1, y1) -> all (\(x2, y2) -> 
  if y1 == y2 then x1 == x2 else True) f) f

isSurjective :: (Ord a, Ord b) => Function a b -> Set b -> Bool
isSurjective f codomain = all (\y -> any (\(x, y') -> y == y') f) codomain

-- 序数类型
data Ordinal = Zero | Succ Ordinal | Limit (Set Ordinal)

-- 基数类型
newtype Cardinal = Cardinal { unCardinal :: Ordinal }

-- 基数比较
instance Ord Cardinal where
  compare (Cardinal a) (Cardinal b) = compare a b

-- 演示函数
main :: IO ()
main = do
  putStrLn "=== 集合论基础演示 ==="
  
  -- 基本集合操作
  let a = Set.fromList [1, 2, 3]
  let b = Set.fromList [3, 4, 5]
  putStrLn $ "A = " ++ show a
  putStrLn $ "B = " ++ show b
  putStrLn $ "A ∪ B = " ++ show (union a b)
  putStrLn $ "A ∩ B = " ++ show (intersection a b)
  putStrLn $ "A \\ B = " ++ show (difference a b)
  
  -- 关系性质
  let r = Set.fromList [(1, 1), (2, 2), (3, 3), (1, 2), (2, 1)]
  putStrLn $ "关系R = " ++ show r
  putStrLn $ "R是自反的: " ++ show (isReflexive r (Set.fromList [1, 2, 3]))
  putStrLn $ "R是对称的: " ++ show (isSymmetric r)
  
  putStrLn "演示完成"
```

## 7. 参考文献

### 经典教材

1. Jech, T. (2003). Set Theory (3rd Millennium Edition). Springer.
2. Kunen, K. (2011). Set Theory: An Introduction to Independence Proofs. Elsevier.
3. Enderton, H.B. (1977). Elements of Set Theory. Academic Press.

### 现代教材

1. Hrbacek, K., & Jech, T. (1999). Introduction to Set Theory (3rd Edition). CRC Press.
2. Devlin, K. (1993). The Joy of Sets: Fundamentals of Contemporary Set Theory (2nd Edition). Springer.

### 课程资源

1. MIT OpenCourseWare: 18.701 Algebra I
2. Stanford University: Math 120A Group Theory
3. Harvard University: Math 122 Algebra I

---

**文档版本**: v1.0  
**创建时间**: 2025年1月  
**标准对齐**: 国际标准  
**维护人员**: FormalMath项目组
