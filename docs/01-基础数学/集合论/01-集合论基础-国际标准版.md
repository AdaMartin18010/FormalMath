# é›†åˆè®ºåŸºç¡€ - å›½é™…æ ‡å‡†ç‰ˆ / Set Theory Foundation - International Standard Edition

## ç›®å½•

- [é›†åˆè®ºåŸºç¡€ - å›½é™…æ ‡å‡†ç‰ˆ / Set Theory Foundation - International Standard Edition](#é›†åˆè®ºåŸºç¡€---å›½é™…æ ‡å‡†ç‰ˆ--set-theory-foundation---international-standard-edition)
  - [ç›®å½•](#ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
  - [1. åŸºæœ¬æ¦‚å¿µ](#1-åŸºæœ¬æ¦‚å¿µ)
    - [1.1 é›†åˆçš„å®šä¹‰](#11-é›†åˆçš„å®šä¹‰)
    - [1.2 å…ƒç´ å…³ç³»](#12-å…ƒç´ å…³ç³»)
  - [2. ZFCå…¬ç†ç³»ç»Ÿ](#2-zfcå…¬ç†ç³»ç»Ÿ)
    - [2.1 å­˜åœ¨æ€§å…¬ç†](#21-å­˜åœ¨æ€§å…¬ç†)
    - [2.2 æ„é€ æ€§å…¬ç†](#22-æ„é€ æ€§å…¬ç†)
    - [2.3 åˆ†ç¦»å…¬ç†æ¨¡å¼](#23-åˆ†ç¦»å…¬ç†æ¨¡å¼)
    - [2.4 æ›¿æ¢å…¬ç†æ¨¡å¼](#24-æ›¿æ¢å…¬ç†æ¨¡å¼)
    - [2.5 æ— ç©·å…¬ç†](#25-æ— ç©·å…¬ç†)
    - [2.6 æ­£åˆ™å…¬ç†](#26-æ­£åˆ™å…¬ç†)
    - [2.7 é€‰æ‹©å…¬ç†](#27-é€‰æ‹©å…¬ç†)
  - [3. é›†åˆè¿ç®—](#3-é›†åˆè¿ç®—)
    - [3.1 åŸºæœ¬è¿ç®—](#31-åŸºæœ¬è¿ç®—)
    - [3.2 ç¬›å¡å°”ç§¯](#32-ç¬›å¡å°”ç§¯)
  - [4. å…³ç³»ä¸å‡½æ•°](#4-å…³ç³»ä¸å‡½æ•°)
    - [4.1 å…³ç³»](#41-å…³ç³»)
    - [4.2 å‡½æ•°](#42-å‡½æ•°)
  - [5. åºæ•°ä¸åŸºæ•°](#5-åºæ•°ä¸åŸºæ•°)
    - [5.1 åºæ•°](#51-åºæ•°)
    - [5.2 åŸºæ•°](#52-åŸºæ•°)
  - [6. å½¢å¼åŒ–å®ç°](#6-å½¢å¼åŒ–å®ç°)
    - [6.1 Lean 4 å®ç°](#61-lean-4-å®ç°)
    - [6.2 Haskell å®ç°](#62-haskell-å®ç°)
  - [7. å‚è€ƒæ–‡çŒ®](#7-å‚è€ƒæ–‡çŒ®)
    - [ç»å…¸æ•™æ](#ç»å…¸æ•™æ)
    - [ç°ä»£æ•™æ](#ç°ä»£æ•™æ)
    - [è¯¾ç¨‹èµ„æº](#è¯¾ç¨‹èµ„æº)

## æ¦‚è¿°

æœ¬æ–‡æ¡£åŸºäºä»¥ä¸‹å›½é™…æ ‡å‡†åˆ¶å®šï¼š

- **Jech, T.**: Set Theory (3rd Millennium Edition)
- **Kunen, K.**: Set Theory: An Introduction to Independence Proofs
- **Enderton, H.B.**: Elements of Set Theory
- **MIT OpenCourseWare**: 18.701 Algebra I
- **Stanford University**: Math 120A Group Theory

## 1. åŸºæœ¬æ¦‚å¿µ

### 1.1 é›†åˆçš„å®šä¹‰

**å®šä¹‰ 1.1** (é›†åˆ / Set)
åœ¨ZFCå…¬ç†ç³»ç»Ÿä¸­ï¼Œé›†åˆæ˜¯æ»¡è¶³å¤–å»¶å…¬ç†çš„å¯¹è±¡ã€‚ä¸¤ä¸ªé›†åˆç›¸ç­‰å½“ä¸”ä»…å½“å®ƒä»¬åŒ…å«ç›¸åŒçš„å…ƒç´ ã€‚

**å½¢å¼åŒ–è¡¨è¿°**:
å¯¹äºä»»æ„é›†åˆ $A$ å’Œ $B$ï¼Œ
$$A = B \iff \forall x (x \in A \leftrightarrow x \in B)$$

### 1.2 å…ƒç´ å…³ç³»

**å®šä¹‰ 1.2** (å±äºå…³ç³» / Element Relation)
å…ƒç´ å…³ç³» $\in$ æ˜¯é›†åˆè®ºçš„åŸºæœ¬å…³ç³»ï¼Œè¡¨ç¤ºä¸€ä¸ªå¯¹è±¡æ˜¯å¦ä¸€ä¸ªé›†åˆçš„å…ƒç´ ã€‚

**å…¬ç† 1.1** (å¤–å»¶å…¬ç† / Axiom of Extensionality)
$$\forall x \forall y [\forall z (z \in x \leftrightarrow z \in y) \rightarrow x = y]$$

## 2. ZFCå…¬ç†ç³»ç»Ÿ

### 2.1 å­˜åœ¨æ€§å…¬ç†

**å…¬ç† 2.1** (ç©ºé›†å…¬ç† / Axiom of Empty Set)
$$\exists x \forall y (y \notin x)$$

**å®šä¹‰ 2.1** (ç©ºé›† / Empty Set)
ç©ºé›†æ˜¯å”¯ä¸€ä¸åŒ…å«ä»»ä½•å…ƒç´ çš„é›†åˆï¼Œè®°ä½œ $\emptyset$ã€‚

**å…¬ç† 2.2** (é…å¯¹å…¬ç† / Axiom of Pairing)
$$\forall x \forall y \exists z \forall w (w \in z \leftrightarrow w = x \vee w = y)$$

**å®šä¹‰ 2.2** (æ— åºå¯¹ / Unordered Pair)
å¯¹äºé›†åˆ $a$ å’Œ $b$ï¼Œå®ƒä»¬çš„æ— åºå¯¹æ˜¯ $\{a, b\}$ã€‚

### 2.2 æ„é€ æ€§å…¬ç†

**å…¬ç† 2.3** (å¹¶é›†å…¬ç† / Axiom of Union)
$$\forall F \exists A \forall x (x \in A \leftrightarrow \exists B (B \in F \wedge x \in B))$$

**å®šä¹‰ 2.3** (å¹¶é›† / Union)
å¯¹äºé›†åˆæ— $F$ï¼Œå…¶å¹¶é›†æ˜¯ $\bigcup F = \{x \mid \exists B \in F (x \in B)\}$ã€‚

**å…¬ç† 2.4** (å¹‚é›†å…¬ç† / Axiom of Power Set)
$$\forall x \exists y \forall z (z \in y \leftrightarrow z \subseteq x)$$

**å®šä¹‰ 2.4** (å¹‚é›† / Power Set)
å¯¹äºé›†åˆ $A$ï¼Œå…¶å¹‚é›†æ˜¯ $P(A) = \{B \mid B \subseteq A\}$ã€‚

### 2.3 åˆ†ç¦»å…¬ç†æ¨¡å¼

**å…¬ç†æ¨¡å¼ 2.5** (åˆ†ç¦»å…¬ç†æ¨¡å¼ / Axiom Schema of Separation)
å¯¹äºæ¯ä¸ªå…¬å¼ $\phi(x, z, w_1, \ldots, w_n)$ï¼Œ
$$\forall z \forall w_1 \ldots \forall w_n \exists y \forall x (x \in y \leftrightarrow x \in z \wedge \phi(x, z, w_1, \ldots, w_n))$$

**å®šä¹‰ 2.5** (åˆ†ç¦» / Separation)
å¯¹äºé›†åˆ $A$ å’Œæ€§è´¨ $P(x)$ï¼Œåˆ†ç¦»é›†æ˜¯ $\{x \in A \mid P(x)\}$ã€‚

### 2.4 æ›¿æ¢å…¬ç†æ¨¡å¼

**å…¬ç†æ¨¡å¼ 2.6** (æ›¿æ¢å…¬ç†æ¨¡å¼ / Axiom Schema of Replacement)
å¯¹äºæ¯ä¸ªå…¬å¼ $\phi(x, y, A, w_1, \ldots, w_n)$ï¼Œ
$$\forall A \forall w_1 \ldots \forall w_n [\forall x \in A \exists! y \phi(x, y, A, w_1, \ldots, w_n) \rightarrow \exists B \forall y (y \in B \leftrightarrow \exists x \in A \phi(x, y, A, w_1, \ldots, w_n))]$$

### 2.5 æ— ç©·å…¬ç†

**å…¬ç† 2.7** (æ— ç©·å…¬ç† / Axiom of Infinity)
$$\exists x [\emptyset \in x \wedge \forall y (y \in x \rightarrow y \cup \{y\} \in x)]$$

**å®šä¹‰ 2.6** (å½’çº³é›† / Inductive Set)
é›†åˆ $A$ æ˜¯å½’çº³é›†ï¼Œå¦‚æœ $\emptyset \in A$ ä¸”å¯¹äºä»»æ„ $x \in A$ï¼Œæœ‰ $x \cup \{x\} \in A$ã€‚

### 2.6 æ­£åˆ™å…¬ç†

**å…¬ç† 2.8** (æ­£åˆ™å…¬ç† / Axiom of Regularity)
$$\forall x [x \neq \emptyset \rightarrow \exists y (y \in x \wedge y \cap x = \emptyset)]$$

### 2.7 é€‰æ‹©å…¬ç†

**å…¬ç† 2.9** (é€‰æ‹©å…¬ç† / Axiom of Choice)
$$\forall F [\emptyset \notin F \wedge \forall x \forall y (x \in F \wedge y \in F \wedge x \neq y \rightarrow x \cap y = \emptyset) \rightarrow \exists C \forall x \in F \exists! z (z \in x \cap C)]$$

## 3. é›†åˆè¿ç®—

### 3.1 åŸºæœ¬è¿ç®—

**å®šä¹‰ 3.1** (å¹¶é›† / Union)
$$A \cup B = \{x \mid x \in A \vee x \in B\}$$

**å®šä¹‰ 3.2** (äº¤é›† / Intersection)
$$A \cap B = \{x \mid x \in A \wedge x \in B\}$$

**å®šä¹‰ 3.3** (å·®é›† / Set Difference)
$$A \setminus B = \{x \mid x \in A \wedge x \notin B\}$$

**å®šä¹‰ 3.4** (å¯¹ç§°å·® / Symmetric Difference)
$$A \triangle B = (A \setminus B) \cup (B \setminus A)$$

### 3.2 ç¬›å¡å°”ç§¯

**å®šä¹‰ 3.5** (æœ‰åºå¯¹ / Ordered Pair)
$$(a, b) = \{\{a\}, \{a, b\}\}$$

**å®šç† 3.1** (æœ‰åºå¯¹çš„æ€§è´¨)
$$(a, b) = (c, d) \iff a = c \wedge b = d$$

**å®šä¹‰ 3.6** (ç¬›å¡å°”ç§¯ / Cartesian Product)
$$A \times B = \{(a, b) \mid a \in A \wedge b \in B\}$$

## 4. å…³ç³»ä¸å‡½æ•°

### 4.1 å…³ç³»

**å®šä¹‰ 4.1** (äºŒå…ƒå…³ç³» / Binary Relation)
ä»é›†åˆ $A$ åˆ°é›†åˆ $B$ çš„äºŒå…ƒå…³ç³»æ˜¯ $A \times B$ çš„å­é›†ã€‚

**å®šä¹‰ 4.2** (å…³ç³»çš„æ€§è´¨)
è®¾ $R$ æ˜¯é›†åˆ $A$ ä¸Šçš„å…³ç³»ï¼š

1. **è‡ªåæ€§** (Reflexivity): $\forall x \in A (x R x)$
2. **éè‡ªåæ€§** (Irreflexivity): $\forall x \in A (\neg x R x)$
3. **å¯¹ç§°æ€§** (Symmetry): $\forall x, y \in A (x R y \rightarrow y R x)$
4. **åå¯¹ç§°æ€§** (Antisymmetry): $\forall x, y \in A (x R y \wedge y R x \rightarrow x = y)$
5. **ä¼ é€’æ€§** (Transitivity): $\forall x, y, z \in A (x R y \wedge y R z \rightarrow x R z)$

**å®šä¹‰ 4.3** (ç­‰ä»·å…³ç³» / Equivalence Relation)
æ»¡è¶³è‡ªåæ€§ã€å¯¹ç§°æ€§å’Œä¼ é€’æ€§çš„å…³ç³»ç§°ä¸ºç­‰ä»·å…³ç³»ã€‚

**å®šä¹‰ 4.4** (ååºå…³ç³» / Partial Order)
æ»¡è¶³è‡ªåæ€§ã€åå¯¹ç§°æ€§å’Œä¼ é€’æ€§çš„å…³ç³»ç§°ä¸ºååºå…³ç³»ã€‚

### 4.2 å‡½æ•°

**å®šä¹‰ 4.5** (å‡½æ•° / Function)
å‡½æ•°æ˜¯ä»é›†åˆ $A$ åˆ°é›†åˆ $B$ çš„å…³ç³» $f$ï¼Œæ»¡è¶³ï¼š

1. $\forall x \in A \exists y \in B ((x, y) \in f)$ (å®šä¹‰åŸŸè¦†ç›–)
2. $\forall x \in A \forall y, z \in B ((x, y) \in f \wedge (x, z) \in f \rightarrow y = z)$ (å•å€¼æ€§)

**å®šä¹‰ 4.6** (å‡½æ•°çš„æ€§è´¨)
è®¾ $f: A \rightarrow B$ æ˜¯å‡½æ•°ï¼š

1. **å•å°„** (Injective): $\forall x, y \in A (f(x) = f(y) \rightarrow x = y)$
2. **æ»¡å°„** (Surjective): $\forall y \in B \exists x \in A (f(x) = y)$
3. **åŒå°„** (Bijective): $f$ æ—¢æ˜¯å•å°„åˆæ˜¯æ»¡å°„

## 5. åºæ•°ä¸åŸºæ•°

### 5.1 åºæ•°

**å®šä¹‰ 5.1** (ä¼ é€’é›† / Transitive Set)
é›†åˆ $A$ æ˜¯ä¼ é€’çš„ï¼Œå¦‚æœ $\forall x \in A (x \subseteq A)$ã€‚

**å®šä¹‰ 5.2** (åºæ•° / Ordinal Number)
åºæ•°æ˜¯ä¼ é€’çš„ã€è‰¯åºçš„é›†åˆã€‚

**å®šç† 5.1** (åºæ•°çš„æ€§è´¨)

1. æ¯ä¸ªåºæ•°çš„å…ƒç´ éƒ½æ˜¯åºæ•°
2. åºæ•°çš„åºæ•°ä¹Ÿæ˜¯åºæ•°
3. å¯¹äºä»»æ„åºæ•° $\alpha, \beta$ï¼Œè¦ä¹ˆ $\alpha \in \beta$ï¼Œè¦ä¹ˆ $\alpha = \beta$ï¼Œè¦ä¹ˆ $\beta \in \alpha$

### 5.2 åŸºæ•°

**å®šä¹‰ 5.3** (ç­‰åŠ¿ / Equinumerous)
é›†åˆ $A$ å’Œ $B$ ç­‰åŠ¿ï¼Œè®°ä½œ $A \approx B$ï¼Œå¦‚æœå­˜åœ¨ä» $A$ åˆ° $B$ çš„åŒå°„ã€‚

**å®šä¹‰ 5.4** (åŸºæ•° / Cardinal Number)
åŸºæ•°æ˜¯ç­‰åŠ¿ç±»ä¸­çš„æœ€å°åºæ•°ã€‚

**å®šä¹‰ 5.5** (åŸºæ•°æ¯”è¾ƒ)
å¯¹äºåŸºæ•° $\kappa$ å’Œ $\lambda$ï¼š

- $\kappa \leq \lambda$ å¦‚æœå­˜åœ¨ä» $\kappa$ åˆ° $\lambda$ çš„å•å°„
- $\kappa < \lambda$ å¦‚æœ $\kappa \leq \lambda$ ä¸” $\kappa \neq \lambda$

**å®šç† 5.2** (åº·æ‰˜å°”-ä¼¯æ©æ–¯å¦å®šç† / Cantor-Bernstein Theorem)
å¦‚æœ $\kappa \leq \lambda$ ä¸” $\lambda \leq \kappa$ï¼Œåˆ™ $\kappa = \lambda$ã€‚

## 6. å½¢å¼åŒ–å®ç°

### 6.1 Lean 4 å®ç°

```lean
/--
# é›†åˆè®ºåŸºç¡€ - Lean4å½¢å¼åŒ–å®ç°
# Set Theory Foundation - Lean4 Formal Implementation

åŸºäºMathlibçš„é›†åˆè®ºå®ç°
Based on Mathlib set theory implementation
--/

import Mathlib.Data.Set.Basic
import Mathlib.Logic.Basic
import Mathlib.Order.Basic

-- é›†åˆç±»å‹å®šä¹‰
def Set (Î± : Type u) := Set Î±

-- å¤–å»¶å…¬ç†
theorem extensionality {Î± : Type u} {A B : Set Î±} :
  A = B â†” âˆ€ x, x âˆˆ A â†” x âˆˆ B := by
  simp [Set.ext_iff]

-- ç©ºé›†å…¬ç†
theorem empty_set_exists {Î± : Type u} :
  âˆƒ (A : Set Î±), âˆ€ x, x âˆ‰ A := by
  use âˆ…
  simp

-- é…å¯¹å…¬ç†
theorem pairing {Î± : Type u} {a b : Î±} :
  âˆƒ (A : Set Î±), âˆ€ x, x âˆˆ A â†” x = a âˆ¨ x = b := by
  use {a, b}
  simp

-- å¹¶é›†å…¬ç†
theorem union_exists {Î± : Type u} {F : Set (Set Î±)} :
  âˆƒ (A : Set Î±), âˆ€ x, x âˆˆ A â†” âˆƒ B âˆˆ F, x âˆˆ B := by
  use â‹ƒâ‚€ F
  simp

-- å¹‚é›†å…¬ç†
theorem power_set_exists {Î± : Type u} {A : Set Î±} :
  âˆƒ (P : Set (Set Î±)), âˆ€ B, B âˆˆ P â†” B âŠ† A := by
  use ğ’« A
  simp

-- åˆ†ç¦»å…¬ç†æ¨¡å¼
theorem separation {Î± : Type u} {A : Set Î±} {P : Î± â†’ Prop} :
  âˆƒ (B : Set Î±), âˆ€ x, x âˆˆ B â†” x âˆˆ A âˆ§ P x := by
  use {x âˆˆ A | P x}
  simp

-- é€‰æ‹©å…¬ç†
theorem choice {Î± : Type u} {F : Set (Set Î±)} (h : âˆ… âˆ‰ F) (h' : âˆ€ A B âˆˆ F, A â‰  B â†’ A âˆ© B = âˆ…) :
  âˆƒ (C : Set Î±), âˆ€ A âˆˆ F, âˆƒ! x, x âˆˆ A âˆ© C := by
  -- è¿™é‡Œéœ€è¦é€‰æ‹©å…¬ç†
  sorry

-- åºæ•°å®šä¹‰
class Ordinal (Î± : Type u) where
  transitive : âˆ€ x âˆˆ Î±, x âŠ† Î±
  well_ordered : IsWellOrder Î± (Â· âˆˆ Â·)

-- åŸºæ•°å®šä¹‰
def Cardinal (Î± : Type u) := 
  { Î² : Type u // Nonempty (Î± â‰ƒ Î²) âˆ§ âˆ€ Î³ : Type u, Nonempty (Î± â‰ƒ Î³) â†’ Nonempty (Î² â†ª Î³) }

-- åŸºæ•°æ¯”è¾ƒ
def Cardinal.le {Î± Î² : Type u} (Îº : Cardinal Î±) (Î» : Cardinal Î²) :=
  Nonempty (Î± â†ª Î²)

-- åº·æ‰˜å°”-ä¼¯æ©æ–¯å¦å®šç†
theorem cantor_bernstein {Î± Î² : Type u} (Îº : Cardinal Î±) (Î» : Cardinal Î²) :
  Cardinal.le Îº Î» â†’ Cardinal.le Î» Îº â†’ Nonempty (Î± â‰ƒ Î²) := by
  -- éœ€è¦è¯æ˜åº·æ‰˜å°”-ä¼¯æ©æ–¯å¦å®šç†
  sorry
```

### 6.2 Haskell å®ç°

```haskell
{-# LANGUAGE GADTs, TypeFamilies, DataKinds #-}

import Data.Set (Set)
import qualified Data.Set as Set
import Data.Map (Map)
import qualified Data.Map as Map

-- é›†åˆç±»å‹
type Set a = Set a

-- å¤–å»¶å…¬ç†
extensionality :: (Ord a) => Set a -> Set a -> Bool
extensionality a b = a == b

-- ç©ºé›†
emptySet :: Set a
emptySet = Set.empty

-- é…å¯¹
pair :: (Ord a) => a -> a -> Set a
pair x y = Set.fromList [x, y]

-- å¹¶é›†
union :: (Ord a) => Set a -> Set a -> Set a
union = Set.union

-- äº¤é›†
intersection :: (Ord a) => Set a -> Set a -> Set a
intersection = Set.intersection

-- å·®é›†
difference :: (Ord a) => Set a -> Set a -> Set a
difference = Set.difference

-- å¹‚é›†
powerSet :: (Ord a) => Set a -> Set (Set a)
powerSet s = Set.fromList (map Set.fromList (subsequences (Set.toList s)))

-- ç¬›å¡å°”ç§¯
cartesianProduct :: (Ord a, Ord b) => Set a -> Set b -> Set (a, b)
cartesianProduct a b = Set.fromList [(x, y) | x <- Set.toList a, y <- Set.toList b]

-- å…³ç³»ç±»å‹
type Relation a b = Set (a, b)

-- å…³ç³»æ€§è´¨
isReflexive :: (Ord a) => Relation a a -> Set a -> Bool
isReflexive r domain = all (\x -> Set.member (x, x) r) domain

isSymmetric :: (Ord a) => Relation a a -> Bool
isSymmetric r = all (\(x, y) -> Set.member (y, x) r) r

isTransitive :: (Ord a) => Relation a a -> Bool
isTransitive r = all (\(x, y) -> all (\(y', z) -> 
  if y == y' then Set.member (x, z) r else True) r) r

-- å‡½æ•°ç±»å‹
type Function a b = Relation a b

-- å‡½æ•°æ€§è´¨
isFunction :: (Ord a, Ord b) => Function a b -> Set a -> Bool
isFunction f domain = all (\x -> 
  length [y | (x', y) <- Set.toList f, x' == x] == 1) domain

isInjective :: (Ord a, Ord b) => Function a b -> Bool
isInjective f = all (\(x1, y1) -> all (\(x2, y2) -> 
  if y1 == y2 then x1 == x2 else True) f) f

isSurjective :: (Ord a, Ord b) => Function a b -> Set b -> Bool
isSurjective f codomain = all (\y -> any (\(x, y') -> y == y') f) codomain

-- åºæ•°ç±»å‹
data Ordinal = Zero | Succ Ordinal | Limit (Set Ordinal)

-- åŸºæ•°ç±»å‹
newtype Cardinal = Cardinal { unCardinal :: Ordinal }

-- åŸºæ•°æ¯”è¾ƒ
instance Ord Cardinal where
  compare (Cardinal a) (Cardinal b) = compare a b

-- æ¼”ç¤ºå‡½æ•°
main :: IO ()
main = do
  putStrLn "=== é›†åˆè®ºåŸºç¡€æ¼”ç¤º ==="
  
  -- åŸºæœ¬é›†åˆæ“ä½œ
  let a = Set.fromList [1, 2, 3]
  let b = Set.fromList [3, 4, 5]
  putStrLn $ "A = " ++ show a
  putStrLn $ "B = " ++ show b
  putStrLn $ "A âˆª B = " ++ show (union a b)
  putStrLn $ "A âˆ© B = " ++ show (intersection a b)
  putStrLn $ "A \\ B = " ++ show (difference a b)
  
  -- å…³ç³»æ€§è´¨
  let r = Set.fromList [(1, 1), (2, 2), (3, 3), (1, 2), (2, 1)]
  putStrLn $ "å…³ç³»R = " ++ show r
  putStrLn $ "Ræ˜¯è‡ªåçš„: " ++ show (isReflexive r (Set.fromList [1, 2, 3]))
  putStrLn $ "Ræ˜¯å¯¹ç§°çš„: " ++ show (isSymmetric r)
  
  putStrLn "æ¼”ç¤ºå®Œæˆ"
```

## 7. å‚è€ƒæ–‡çŒ®

### ç»å…¸æ•™æ

1. Jech, T. (2003). Set Theory (3rd Millennium Edition). Springer.
2. Kunen, K. (2011). Set Theory: An Introduction to Independence Proofs. Elsevier.
3. Enderton, H.B. (1977). Elements of Set Theory. Academic Press.

### ç°ä»£æ•™æ

1. Hrbacek, K., & Jech, T. (1999). Introduction to Set Theory (3rd Edition). CRC Press.
2. Devlin, K. (1993). The Joy of Sets: Fundamentals of Contemporary Set Theory (2nd Edition). Springer.

### è¯¾ç¨‹èµ„æº

1. MIT OpenCourseWare: 18.701 Algebra I
2. Stanford University: Math 120A Group Theory
3. Harvard University: Math 122 Algebra I

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¶é—´**: 2025å¹´1æœˆ  
**æ ‡å‡†å¯¹é½**: å›½é™…æ ‡å‡†  
**ç»´æŠ¤äººå‘˜**: FormalMathé¡¹ç›®ç»„
