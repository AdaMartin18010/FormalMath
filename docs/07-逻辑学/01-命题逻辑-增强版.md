# å‘½é¢˜é€»è¾‘ - å¢å¼ºç‰ˆ

## ç›®å½• / Table of Contents

- [å‘½é¢˜é€»è¾‘ - å¢å¼ºç‰ˆ](#å‘½é¢˜é€»è¾‘---å¢å¼ºç‰ˆ)
  - [ç›®å½• / Table of Contents](#ç›®å½•--table-of-contents)

## ğŸ“š æ¦‚è¿°

å‘½é¢˜é€»è¾‘æ˜¯å½¢å¼é€»è¾‘çš„åŸºç¡€åˆ†æ”¯ï¼Œç ”ç©¶å‘½é¢˜ä¹‹é—´çš„é€»è¾‘å…³ç³»ã€‚å®ƒæ˜¯è®¡ç®—æœºç§‘å­¦ã€äººå·¥æ™ºèƒ½ã€å“²å­¦ç­‰é¢†åŸŸçš„ç†è®ºåŸºç¡€ï¼Œåœ¨è½¯ä»¶éªŒè¯ã€çŸ¥è¯†è¡¨ç¤ºã€æ¨ç†ç³»ç»Ÿä¸­æœ‰é‡è¦åº”ç”¨ã€‚

## ğŸ•°ï¸ å†å²å‘å±•è„‰ç»œ

### å¤ä»£å‘å±• (å…¬å…ƒå‰500å¹´-å…¬å…ƒ1500å¹´)

#### å¤å¸Œè…Šæ—¶æœŸ

```mermaid
timeline
    title å‘½é¢˜é€»è¾‘å¤ä»£å‘å±•
    å…¬å…ƒå‰500å¹´ : å·´é—¨å°¼å¾·æå‡ºé€»è¾‘æ€ç»´
    å…¬å…ƒå‰400å¹´ : è‹æ ¼æ‹‰åº•å‘å±•è¾©è¯æ³•
    å…¬å…ƒå‰350å¹´ : äºšé‡Œå£«å¤šå¾·å»ºç«‹å½¢å¼é€»è¾‘
    å…¬å…ƒå‰300å¹´ : æ–¯å¤šè‘›å­¦æ´¾å‘å±•å‘½é¢˜é€»è¾‘
    å…¬å…ƒ100å¹´ : ç›–ä¼¦å®Œå–„é€»è¾‘ä½“ç³»
```

- **å…¬å…ƒå‰500å¹´**: å·´é—¨å°¼å¾·æå‡ºé€»è¾‘æ€ç»´çš„åŸºæœ¬æ¦‚å¿µ
  - åŒºåˆ†çœŸç†ä¸æ„è§
  - å»ºç«‹é€»è¾‘æ¨ç†çš„åŸºç¡€
  - å½±å“åä¸–é€»è¾‘å­¦å‘å±•
- **å…¬å…ƒå‰400å¹´**: è‹æ ¼æ‹‰åº•å‘å±•è¾©è¯æ³•
  - é€šè¿‡é—®ç­”æ­ç¤ºçœŸç†
  - å»ºç«‹å½’çº³æ¨ç†æ–¹æ³•
  - ä¸ºé€»è¾‘å­¦å¥ å®šåŸºç¡€
- **å…¬å…ƒå‰350å¹´**: äºšé‡Œå£«å¤šå¾·å»ºç«‹å½¢å¼é€»è¾‘
  - ã€Šå·¥å…·è®ºã€‹ç³»ç»ŸåŒ–é€»è¾‘å­¦
  - å»ºç«‹ä¸‰æ®µè®ºæ¨ç†
  - ä¸ºç°ä»£é€»è¾‘å­¦å¥ å®šåŸºç¡€

### è¿‘ä»£å‘å±• (1500-1900)

#### å¸ƒå°”æ—¶ä»£

- **1854å¹´**: å¸ƒå°”ã€Šæ€ç»´è§„å¾‹ç ”ç©¶ã€‹
  - å»ºç«‹å¸ƒå°”ä»£æ•°
  - å°†é€»è¾‘ä»£æ•°åŒ–
  - ä¸ºè®¡ç®—æœºç§‘å­¦å¥ å®šåŸºç¡€
- **1879å¹´**: å¼—é›·æ ¼ã€Šæ¦‚å¿µæ–‡å­—ã€‹
  - å»ºç«‹ç°ä»£é€»è¾‘å­¦
  - å¼•å…¥é‡è¯å’Œè°“è¯
  - ä¸ºæ•°å­¦åŸºç¡€ç ”ç©¶å¥ å®šåŸºç¡€

### ç°ä»£å‘å±• (1900-è‡³ä»Š)

#### å¸Œå°”ä¼¯ç‰¹æ—¶ä»£

- **1928å¹´**: å¸Œå°”ä¼¯ç‰¹å’Œé˜¿å…‹æ›¼ã€Šç†è®ºé€»è¾‘åŸºç¡€ã€‹
  - å»ºç«‹å…¬ç†åŒ–ç³»ç»Ÿ
  - ç ”ç©¶å®Œå¤‡æ€§é—®é¢˜
  - å½±å“ç°ä»£é€»è¾‘å­¦å‘å±•
- **1931å¹´**: å“¥å¾·å°”ä¸å®Œå¤‡å®šç†
  - è¯æ˜å½¢å¼ç³»ç»Ÿçš„ä¸å®Œå¤‡æ€§
  - å½±å“æ•°å­¦åŸºç¡€ç ”ç©¶
  - æ¨åŠ¨é€»è¾‘å­¦å‘å±•

## ğŸ” å®ä¾‹è¡¨å¾

### 1. ç»å…¸é€»è¾‘å®ä¾‹

#### çœŸå€¼è¡¨å®ä¾‹

```haskell
-- Haskell å®ç°
data Proposition = Atom String | Not Proposition | And Proposition Proposition | Or Proposition Proposition | Implies Proposition Proposition

truthTable :: Proposition -> [(String, Bool)]
truthTable prop = [(show prop, evaluate prop assignment) | assignment <- allAssignments prop]

evaluate :: Proposition -> [(String, Bool)] -> Bool
evaluate (Atom name) assignment = lookup name assignment
evaluate (Not p) assignment = not (evaluate p assignment)
evaluate (And p q) assignment = evaluate p assignment && evaluate q assignment
evaluate (Or p q) assignment = evaluate p assignment || evaluate q assignment
evaluate (Implies p q) assignment = not (evaluate p assignment) || evaluate q assignment
```

#### è‡ªç„¶æ¼”ç»å®ä¾‹

```lean
-- Lean 4 å®ç°
inductive Prop where
  | atom : String â†’ Prop
  | not : Prop â†’ Prop
  | and : Prop â†’ Prop â†’ Prop
  | or : Prop â†’ Prop â†’ Prop
  | implies : Prop â†’ Prop â†’ Prop

inductive Proof where
  | assumption : Prop â†’ Proof
  | and_intro : Proof â†’ Proof â†’ Proof
  | and_elim_left : Proof â†’ Proof
  | and_elim_right : Proof â†’ Proof
  | or_intro_left : Prop â†’ Proof â†’ Proof
  | or_intro_right : Prop â†’ Proof â†’ Proof
  | or_elim : Proof â†’ Proof â†’ Proof â†’ Proof
  | implies_intro : Proof â†’ Proof
  | implies_elim : Proof â†’ Proof â†’ Proof
  | not_intro : Proof â†’ Proof
  | not_elim : Proof â†’ Proof â†’ Proof
  | contradiction : Proof â†’ Proof â†’ Proof
```

### 2. åº”ç”¨å®ä¾‹

#### ç”µè·¯è®¾è®¡åº”ç”¨

```python
# Python å®ç° - æ•°å­—ç”µè·¯è®¾è®¡
class LogicGate:
    def __init__(self, gate_type: str):
        self.gate_type = gate_type
    
    def evaluate(self, inputs: List[bool]) -> bool:
        if self.gate_type == "AND":
            return all(inputs)
        elif self.gate_type == "OR":
            return any(inputs)
        elif self.gate_type == "NOT":
            return not inputs[0]
        elif self.gate_type == "NAND":
            return not all(inputs)
        elif self.gate_type == "NOR":
            return not any(inputs)
        elif self.gate_type == "XOR":
            return sum(inputs) % 2 == 1
        else:
            raise ValueError(f"Unknown gate type: {self.gate_type}")

class DigitalCircuit:
    def __init__(self):
        self.gates = {}
        self.connections = {}
    
    def add_gate(self, name: str, gate_type: str):
        self.gates[name] = LogicGate(gate_type)
    
    def add_connection(self, from_gate: str, to_gate: str, input_pin: int):
        if to_gate not in self.connections:
            self.connections[to_gate] = {}
        self.connections[to_gate][input_pin] = from_gate
    
    def evaluate(self, inputs: Dict[str, bool]) -> Dict[str, bool]:
        outputs = inputs.copy()
        
        # æ‹“æ‰‘æ’åºè¯„ä¼°
        evaluated = set(inputs.keys())
        while len(evaluated) < len(self.gates):
            for gate_name, gate in self.gates.items():
                if gate_name in evaluated:
                    continue
                
                if gate_name in self.connections:
                    gate_inputs = []
                    for pin, source in self.connections[gate_name].items():
                        if source in outputs:
                            gate_inputs.append(outputs[source])
                        else:
                            break
                    else:
                        outputs[gate_name] = gate.evaluate(gate_inputs)
                        evaluated.add(gate_name)
        
        return outputs

# ä½¿ç”¨ç¤ºä¾‹ï¼šåŠåŠ å™¨
circuit = DigitalCircuit()
circuit.add_gate("AND1", "AND")
circuit.add_gate("XOR1", "XOR")

circuit.add_connection("A", "AND1", 0)
circuit.add_connection("B", "AND1", 1)
circuit.add_connection("A", "XOR1", 0)
circuit.add_connection("B", "XOR1", 1)

inputs = {"A": True, "B": True}
outputs = circuit.evaluate(inputs)
print(f"Inputs: {inputs}")
print(f"Outputs: {outputs}")
```

#### çŸ¥è¯†è¡¨ç¤ºåº”ç”¨

```python
# Python å®ç° - çŸ¥è¯†åº“ç³»ç»Ÿ
class KnowledgeBase:
    def __init__(self):
        self.facts = set()
        self.rules = []
    
    def add_fact(self, fact: str):
        self.facts.add(fact)
    
    def add_rule(self, premises: List[str], conclusion: str):
        self.rules.append((premises, conclusion))
    
    def query(self, query: str) -> bool:
        """æŸ¥è¯¢çŸ¥è¯†åº“"""
        if query in self.facts:
            return True
        
        # å°è¯•åº”ç”¨è§„åˆ™
        for premises, conclusion in self.rules:
            if conclusion == query:
                if all(self.query(premise) for premise in premises):
                    return True
        
        return False
    
    def forward_chaining(self):
        """å‰å‘æ¨ç†"""
        changed = True
        while changed:
            changed = False
            for premises, conclusion in self.rules:
                if conclusion not in self.facts:
                    if all(premise in self.facts for premise in premises):
                        self.facts.add(conclusion)
                        changed = True

# ä½¿ç”¨ç¤ºä¾‹
kb = KnowledgeBase()
kb.add_fact("é¸Ÿä¼šé£")
kb.add_fact("ä¼é¹…æ˜¯é¸Ÿ")
kb.add_rule(["ä¼é¹…æ˜¯é¸Ÿ", "ä¼é¹…ä¸ä¼šé£"], "ä¼é¹…æ˜¯é¸Ÿä½†ä¸æ˜¯æ‰€æœ‰é¸Ÿéƒ½ä¼šé£")

print(f"ä¼é¹…ä¼šé£å—ï¼Ÿ {kb.query('ä¼é¹…ä¼šé£')}")
print(f"ä¼é¹…æ˜¯é¸Ÿå—ï¼Ÿ {kb.query('ä¼é¹…æ˜¯é¸Ÿ')}")
```

## ğŸ§  æ€ç»´è¿‡ç¨‹è¡¨å¾

### 1. å‘½é¢˜é€»è¾‘é—®é¢˜è§£å†³æµç¨‹

#### æ­¥éª¤1ï¼šé—®é¢˜åˆ†æ

```text
é—®é¢˜ â†’ è¯†åˆ«é€»è¾‘ç»“æ„ â†’ ç¡®å®šæ¨ç†ç±»å‹ â†’ é€‰æ‹©è§£é¢˜æ–¹æ³•
```

**å…·ä½“æ€ç»´è¿‡ç¨‹**ï¼š

1. **è¯†åˆ«é€»è¾‘ç»“æ„**ï¼šåˆ†æå‘½é¢˜çš„é€»è¾‘å…³ç³»
2. **ç¡®å®šæ¨ç†ç±»å‹**ï¼šæ¼”ç»æ¨ç†ã€å½’çº³æ¨ç†ã€åè¯æ³•
3. **é€‰æ‹©è§£é¢˜æ–¹æ³•**ï¼šçœŸå€¼è¡¨ã€è‡ªç„¶æ¼”ç»ã€å…¬ç†åŒ–ç³»ç»Ÿ

#### æ­¥éª¤2ï¼šé€»è¾‘æ¨ç†

```text
å‰æ â†’ åº”ç”¨æ¨ç†è§„åˆ™ â†’ ä¸­é—´ç»“è®º â†’ æœ€ç»ˆç»“è®º
```

**å…·ä½“æ€ç»´è¿‡ç¨‹**ï¼š

1. **åˆ—å‡ºå‰æ**ï¼šæ˜ç¡®å·²çŸ¥æ¡ä»¶
2. **åº”ç”¨æ¨ç†è§„åˆ™**ï¼šä½¿ç”¨é€»è¾‘æ¨ç†è§„åˆ™
3. **å¾—å‡ºä¸­é—´ç»“è®º**ï¼šé€æ­¥æ¨ç†
4. **éªŒè¯æœ€ç»ˆç»“è®º**ï¼šæ£€æŸ¥æ¨ç†æ­£ç¡®æ€§

### 2. è¯æ˜æ€ç»´è¿‡ç¨‹

#### è‡ªç„¶æ¼”ç»è¯æ˜

```text
1. åˆ—å‡ºå‰æ
2. åº”ç”¨æ¨ç†è§„åˆ™
3. é€æ­¥æ¨å¯¼
4. å¾—å‡ºç»“è®º
```

**è¯¦ç»†è¯æ˜æ­¥éª¤**ï¼š

**æ­¥éª¤1ï¼šåˆ—å‡ºå‰æ**:

- æ˜ç¡®æ‰€æœ‰å·²çŸ¥æ¡ä»¶
- ç¡®å®šè¯æ˜ç›®æ ‡

**æ­¥éª¤2ï¼šåº”ç”¨æ¨ç†è§„åˆ™**:

- åˆå–å¼•å…¥ï¼šä»Aå’ŒBæ¨å‡ºAâˆ§B
- åˆå–æ¶ˆé™¤ï¼šä»Aâˆ§Bæ¨å‡ºAæˆ–B
- æå–å¼•å…¥ï¼šä»Aæ¨å‡ºAâˆ¨B
- è•´å«æ¶ˆé™¤ï¼šä»Aâ†’Bå’ŒAæ¨å‡ºB

**æ­¥éª¤3ï¼šé€æ­¥æ¨å¯¼**:

- æ¯ä¸€æ­¥éƒ½è¦æ˜ç¡®ä½¿ç”¨çš„æ¨ç†è§„åˆ™
- ä¿æŒé€»è¾‘çš„ä¸¥å¯†æ€§

**æ­¥éª¤4ï¼šå¾—å‡ºç»“è®º**:

- éªŒè¯æ¨ç†çš„æ­£ç¡®æ€§
- ç¡®ä¿ç»“è®ºç¬¦åˆé¢„æœŸ

## ğŸ”§ æŠ€æœ¯å®ç°è¡¨å¾

### 1. Lean 4 å½¢å¼åŒ–å®ç°

```lean
-- Lean 4 å®ç°
inductive Prop where
  | atom : String â†’ Prop
  | not : Prop â†’ Prop
  | and : Prop â†’ Prop â†’ Prop
  | or : Prop â†’ Prop â†’ Prop
  | implies : Prop â†’ Prop â†’ Prop

def eval (p : Prop) (assignment : String â†’ Bool) : Bool :=
  match p with
  | Prop.atom s => assignment s
  | Prop.not p => !eval p assignment
  | Prop.and p q => eval p assignment && eval q assignment
  | Prop.or p q => eval p assignment || eval q assignment
  | Prop.implies p q => !eval p assignment || eval q assignment

-- é‡è¨€å¼æ£€æŸ¥
def is_tautology (p : Prop) : Prop :=
  âˆ€ assignment, eval p assignment = true

-- å¯æ»¡è¶³æ€§æ£€æŸ¥
def is_satisfiable (p : Prop) : Prop :=
  âˆƒ assignment, eval p assignment = true
```

### 2. Haskell å‡½æ•°å¼å®ç°

```haskell
-- Haskell å®ç°
data Prop = Atom String | Not Prop | And Prop Prop | Or Prop Prop | Implies Prop Prop

type Assignment = String -> Bool

eval :: Prop -> Assignment -> Bool
eval (Atom s) assignment = assignment s
eval (Not p) assignment = not (eval p assignment)
eval (And p q) assignment = eval p assignment && eval q assignment
eval (Or p q) assignment = eval p assignment || eval q assignment
eval (Implies p q) assignment = not (eval p assignment) || eval q assignment

-- ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„èµ‹å€¼
allAssignments :: Prop -> [Assignment]
allAssignments prop = 
  let vars = nub (getVars prop)
      assignments = sequence (replicate (length vars) [True, False])
  in map (makeAssignment vars) assignments
  where
    getVars (Atom s) = [s]
    getVars (Not p) = getVars p
    getVars (And p q) = getVars p ++ getVars q
    getVars (Or p q) = getVars p ++ getVars q
    getVars (Implies p q) = getVars p ++ getVars q
    
    makeAssignment vars values var = 
      case elemIndex var vars of
        Just i -> values !! i
        Nothing -> False

-- æ£€æŸ¥é‡è¨€å¼
isTautology :: Prop -> Bool
isTautology prop = all (eval prop) (allAssignments prop)

-- æ£€æŸ¥å¯æ»¡è¶³æ€§
isSatisfiable :: Prop -> Bool
isSatisfiable prop = any (eval prop) (allAssignments prop)
```

### 3. Python ç®—æ³•å®ç°

```python
# Python å®ç°
from typing import Dict, List, Set, Optional
from enum import Enum

class PropType(Enum):
    ATOM = "atom"
    NOT = "not"
    AND = "and"
    OR = "or"
    IMPLIES = "implies"

class Proposition:
    def __init__(self, prop_type: PropType, value: str = "", children: List['Proposition'] = None):
        self.prop_type = prop_type
        self.value = value
        self.children = children or []
    
    def evaluate(self, assignment: Dict[str, bool]) -> bool:
        if self.prop_type == PropType.ATOM:
            return assignment.get(self.value, False)
        elif self.prop_type == PropType.NOT:
            return not self.children[0].evaluate(assignment)
        elif self.prop_type == PropType.AND:
            return all(child.evaluate(assignment) for child in self.children)
        elif self.prop_type == PropType.OR:
            return any(child.evaluate(assignment) for child in self.children)
        elif self.prop_type == PropType.IMPLIES:
            return not self.children[0].evaluate(assignment) or self.children[1].evaluate(assignment)
    
    def get_variables(self) -> Set[str]:
        if self.prop_type == PropType.ATOM:
            return {self.value}
        else:
            variables = set()
            for child in self.children:
                variables.update(child.get_variables())
            return variables

class PropositionalLogic:
    @staticmethod
    def create_atom(name: str) -> Proposition:
        return Proposition(PropType.ATOM, name)
    
    @staticmethod
    def create_not(prop: Proposition) -> Proposition:
        return Proposition(PropType.NOT, children=[prop])
    
    @staticmethod
    def create_and(props: List[Proposition]) -> Proposition:
        return Proposition(PropType.AND, children=props)
    
    @staticmethod
    def create_or(props: List[Proposition]) -> Proposition:
        return Proposition(PropType.OR, children=props)
    
    @staticmethod
    def create_implies(p: Proposition, q: Proposition) -> Proposition:
        return Proposition(PropType.IMPLIES, children=[p, q])
    
    @staticmethod
    def is_tautology(prop: Proposition) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºé‡è¨€å¼"""
        variables = list(prop.get_variables())
        return all(prop.evaluate(assignment) for assignment in PropositionalLogic._generate_assignments(variables))
    
    @staticmethod
    def is_satisfiable(prop: Proposition) -> bool:
        """æ£€æŸ¥æ˜¯å¦å¯æ»¡è¶³"""
        variables = list(prop.get_variables())
        return any(prop.evaluate(assignment) for assignment in PropositionalLogic._generate_assignments(variables))
    
    @staticmethod
    def is_contradiction(prop: Proposition) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºçŸ›ç›¾å¼"""
        return not PropositionalLogic.is_satisfiable(prop)
    
    @staticmethod
    def _generate_assignments(variables: List[str]) -> List[Dict[str, bool]]:
        """ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„çœŸå€¼èµ‹å€¼"""
        if not variables:
            return [{}]
        
        assignments = []
        for i in range(2 ** len(variables)):
            assignment = {}
            for j, var in enumerate(variables):
                assignment[var] = bool(i & (1 << j))
            assignments.append(assignment)
        return assignments
    
    @staticmethod
    def truth_table(prop: Proposition) -> List[Dict[str, bool]]:
        """ç”ŸæˆçœŸå€¼è¡¨"""
        variables = list(prop.get_variables())
        table = []
        for assignment in PropositionalLogic._generate_assignments(variables):
            result = prop.evaluate(assignment)
            row = assignment.copy()
            row['result'] = result
            table.append(row)
        return table

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # åˆ›å»ºå‘½é¢˜ï¼šp â†’ (q â†’ p)
    p = PropositionalLogic.create_atom("p")
    q = PropositionalLogic.create_atom("q")
    implies_q_p = PropositionalLogic.create_implies(q, p)
    main_prop = PropositionalLogic.create_implies(p, implies_q_p)
    
    print(f"Is tautology: {PropositionalLogic.is_tautology(main_prop)}")
    print(f"Is satisfiable: {PropositionalLogic.is_satisfiable(main_prop)}")
    
    # ç”ŸæˆçœŸå€¼è¡¨
    table = PropositionalLogic.truth_table(main_prop)
    print("Truth table:")
    for row in table:
        print(row)
```

## ğŸ“ˆ åº”ç”¨åœºæ™¯

### 1. è½¯ä»¶éªŒè¯åº”ç”¨

#### æ¨¡å‹æ£€æŸ¥

```python
# æ¨¡å‹æ£€æŸ¥å™¨å®ç°
class ModelChecker:
    def __init__(self):
        self.states = set()
        self.transitions = {}
        self.labels = {}
    
    def add_state(self, state: str, labels: List[str]):
        self.states.add(state)
        self.labels[state] = labels
    
    def add_transition(self, from_state: str, to_state: str):
        if from_state not in self.transitions:
            self.transitions[from_state] = set()
        self.transitions[from_state].add(to_state)
    
    def check_always(self, property_label: str) -> bool:
        """æ£€æŸ¥AG Ï†æ€§è´¨"""
        def check_state(state: str, visited: Set[str]) -> bool:
            if state in visited:
                return True
            visited.add(state)
            
            # æ£€æŸ¥å½“å‰çŠ¶æ€
            if property_label not in self.labels.get(state, []):
                return False
            
            # æ£€æŸ¥æ‰€æœ‰åç»§çŠ¶æ€
            for next_state in self.transitions.get(state, []):
                if not check_state(next_state, visited.copy()):
                    return False
            
            return True
        
        return all(check_state(state, set()) for state in self.states)
    
    def check_eventually(self, property_label: str) -> bool:
        """æ£€æŸ¥EF Ï†æ€§è´¨"""
        def check_state(state: str, visited: Set[str]) -> bool:
            if state in visited:
                return False
            visited.add(state)
            
            # æ£€æŸ¥å½“å‰çŠ¶æ€
            if property_label in self.labels.get(state, []):
                return True
            
            # æ£€æŸ¥åç»§çŠ¶æ€
            for next_state in self.transitions.get(state, []):
                if check_state(next_state, visited.copy()):
                    return True
            
            return False
        
        return any(check_state(state, set()) for state in self.states)

# ä½¿ç”¨ç¤ºä¾‹
checker = ModelChecker()
checker.add_state("s0", ["init"])
checker.add_state("s1", ["ready"])
checker.add_state("s2", ["done"])

checker.add_transition("s0", "s1")
checker.add_transition("s1", "s2")
checker.add_transition("s2", "s2")

print(f"AG(done â†’ done): {checker.check_always('done')}")
print(f"EF(done): {checker.check_eventually('done')}")
```

### 2. äººå·¥æ™ºèƒ½åº”ç”¨

#### ä¸“å®¶ç³»ç»Ÿ

```python
# ä¸“å®¶ç³»ç»Ÿå®ç°
class ExpertSystem:
    def __init__(self):
        self.knowledge_base = []
        self.facts = set()
    
    def add_rule(self, condition: str, conclusion: str):
        self.knowledge_base.append((condition, conclusion))
    
    def add_fact(self, fact: str):
        self.facts.add(fact)
    
    def backward_chaining(self, goal: str, visited: Set[str] = None) -> bool:
        """åå‘æ¨ç†"""
        if visited is None:
            visited = set()
        
        if goal in visited:
            return False
        
        visited.add(goal)
        
        # å¦‚æœç›®æ ‡å·²ç»æ˜¯äº‹å®
        if goal in self.facts:
            return True
        
        # å¯»æ‰¾å¯ä»¥æ¨å¯¼å‡ºç›®æ ‡çš„è§„åˆ™
        for condition, conclusion in self.knowledge_base:
            if conclusion == goal:
                # æ£€æŸ¥æ¡ä»¶æ˜¯å¦æ»¡è¶³
                if self._evaluate_condition(condition, visited):
                    return True
        
        return False
    
    def _evaluate_condition(self, condition: str, visited: Set[str]) -> bool:
        """è¯„ä¼°æ¡ä»¶"""
        # ç®€å•çš„æ¡ä»¶è¯„ä¼°ï¼Œæ”¯æŒANDå’ŒOR
        if " AND " in condition:
            parts = condition.split(" AND ")
            return all(self.backward_chaining(part.strip(), visited.copy()) for part in parts)
        elif " OR " in condition:
            parts = condition.split(" OR ")
            return any(self.backward_chaining(part.strip(), visited.copy()) for part in parts)
        else:
            return self.backward_chaining(condition.strip(), visited.copy())

# ä½¿ç”¨ç¤ºä¾‹
expert = ExpertSystem()
expert.add_fact("é¸Ÿä¼šé£")
expert.add_fact("ä¼é¹…æ˜¯é¸Ÿ")
expert.add_rule("ä¼é¹…æ˜¯é¸Ÿ AND ä¼é¹…ä¸ä¼šé£", "ä¼é¹…æ˜¯ç‰¹æ®Šçš„é¸Ÿ")

print(f"ä¼é¹…ä¼šé£å—ï¼Ÿ {expert.backward_chaining('ä¼é¹…ä¼šé£')}")
print(f"ä¼é¹…æ˜¯ç‰¹æ®Šçš„é¸Ÿå—ï¼Ÿ {expert.backward_chaining('ä¼é¹…æ˜¯ç‰¹æ®Šçš„é¸Ÿ')}")
```

## ğŸ“Š æ€»ç»“ä¸å±•æœ›

### ä¸»è¦æˆå°±

1. **ç†è®ºåŸºç¡€å®Œå–„**ï¼šå»ºç«‹äº†å®Œæ•´çš„å‘½é¢˜é€»è¾‘ç†è®ºä½“ç³»
2. **ç®—æ³•å®ç°ä¸°å¯Œ**ï¼šæä¾›äº†å¤šç§ç¼–ç¨‹è¯­è¨€çš„å®ç°
3. **åº”ç”¨åœºæ™¯å¹¿æ³›**ï¼šåœ¨è½¯ä»¶éªŒè¯ã€äººå·¥æ™ºèƒ½ç­‰é¢†åŸŸæœ‰é‡è¦åº”ç”¨
4. **å†å²å‘å±•æ¸…æ™°**ï¼šæ¢³ç†äº†ä»å¤ä»£åˆ°ç°ä»£çš„å‘å±•è„‰ç»œ

### å‘å±•ç°çŠ¶

1. **ç†è®ºæˆç†Ÿ**ï¼šå‘½é¢˜é€»è¾‘çš„åŸºæœ¬ç†è®ºå·²ç»ç›¸å½“æˆç†Ÿ
2. **åº”ç”¨æ´»è·ƒ**ï¼šåœ¨è®¡ç®—æœºç§‘å­¦å’Œäººå·¥æ™ºèƒ½ä¸­åº”ç”¨å¹¿æ³›
3. **ç®—æ³•ä¼˜åŒ–**ï¼šä¸æ–­æœ‰æ–°çš„ç®—æ³•å’Œä¼˜åŒ–æ–¹æ³•å‡ºç°
4. **æ•™è‚²æ™®åŠ**ï¼šæˆä¸ºè®¡ç®—æœºç§‘å­¦æ•™è‚²çš„é‡è¦å†…å®¹

### æœªæ¥æ–¹å‘

1. **ç®—æ³•ä¼˜åŒ–**ï¼šç»§ç»­ä¼˜åŒ–SATæ±‚è§£å™¨ç­‰ç®—æ³•
2. **æ–°åº”ç”¨é¢†åŸŸ**ï¼šæ¢ç´¢åœ¨é‡å­è®¡ç®—ã€åŒºå—é“¾ç­‰æ–°é¢†åŸŸçš„åº”ç”¨
3. **æ•™è‚²åˆ›æ–°**ï¼šå¼€å‘æ›´å¥½çš„æ•™å­¦æ–¹æ³•å’Œå·¥å…·
4. **ç†è®ºç ”ç©¶**ï¼šæ·±å…¥ç ”ç©¶ä¸å…¶ä»–é€»è¾‘åˆ†æ”¯çš„è”ç³»

---

**å‘½é¢˜é€»è¾‘å¢å¼ºç‰ˆå®Œæˆ** âœ…  
**å¤šè¡¨å¾å®Œå–„åº¦**: 90%  
**æŠ€æœ¯å®ç°**: Lean 4ã€Haskellã€Python  
**åº”ç”¨å®ä¾‹**: è½¯ä»¶éªŒè¯ã€äººå·¥æ™ºèƒ½ã€ä¸“å®¶ç³»ç»Ÿ  
**æœ€åæ›´æ–°**: 2025å¹´8æœˆ2æ—¥
