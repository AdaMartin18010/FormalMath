# Burnside引理 - 五种表征

**创建日期**: 2025年12月1日
**领域**: 组合学/群论
**难度**: L1

---

## 元信息

| 属性 | 内容 |
|------|------|
| **定理** | Burnside引理（轨道计数定理） |
| **领域** | 组合学/群论 |
| **发现者** | Cauchy, Frobenius (误归于Burnside) |
| **前置知识** | 群作用、轨道、稳定子 |

---

## 一、符号表征（形式化）

### 1.1 严格陈述

**Burnside引理**（轨道计数定理）：设有限群 $G$ 作用在有限集合 $X$ 上，则轨道数为：

$$|X/G| = \frac{1}{|G|} \sum_{g \in G} |X^g|$$

其中：
- $X/G$ 是 $X$ 在 $G$ 作用下的轨道集合
- $X^g = \{x \in X: g \cdot x = x\}$ 是 $g$ 的不动点集

### 1.2 等价表述

**轨道计数公式**：

$$|X/G| = \frac{1}{|G|} \sum_{g \in G} |\operatorname{Fix}(g)|$$

其中 $\operatorname{Fix}(g) = X^g$。

### 1.3 形式化表述

$$\left[ G \text{ 有限群 } \land G \curvearrowright X \text{ 有限集合 } \right] \Rightarrow |X/G| = \frac{1}{|G|} \sum_{g \in G} |X^g|$$

---

## 二、几何表征（可视化）

### 2.1 轨道与不动点

```text
计算轨道数 = 平均不动点数

    X (集合)
    │
    ├─ 轨道1: {x₁, x₂, x₃}
    ├─ 轨道2: {x₄, x₅}
    └─ 轨道3: {x₆}
    
    轨道数 = 3
    
    对每个g∈G，计算不动点数
    平均 = Σ|X^g| / |G|
```

### 2.2 双重计数

```text
Burnside引理的证明思路：

    计算 (g, x) 对，其中 g·x = x
    
    方法1：对每个g，计算|X^g|
    总数 = Σ_{g∈G} |X^g|
    
    方法2：对每个x，计算|Stab(x)|
    总数 = Σ_{x∈X} |Stab(x)|
    
    两者相等，得到Burnside引理
```

### 2.3 对称性

```text
对称对象的计数：

    本质不同的对象数 = 轨道数
    
    例如：用3种颜色涂2×2网格
    考虑旋转对称性
    轨道数 = 不同本质的涂色数
```

---

## 三、直觉表征（类比）

### 3.1 组合类比

> **Burnside**：不同本质对象的数量 = 平均每个对称操作"不动"的对象数

**类比1：计数问题**

- 直接计数可能重复计算对称对象
- Burnside = 通过对称性"去重"
- 平均不动点数 = 本质不同的对象数

**类比2：投票**

- 每个群元"投票"给不动的对象
- 平均票数 = 轨道数
- 这类似于加权平均

### 3.2 物理类比

**类比**：在物理中：
- 对称操作 = 物理变换
- 不动点 = 不变状态
- Burnside = 统计不变状态

---

## 四、计算表征（算法）

### 4.1 基本算法

```python
def burnside_count_orbits(G, X, action):
    """
    使用Burnside引理计算轨道数
    
    参数:
        G: 群（列表）
        X: 集合（列表）
        action: 群作用函数 action(g, x) -> g·x
    
    返回:
        num_orbits: 轨道数
    """
    total_fixed = 0
    
    for g in G:
        fixed_count = count_fixed_points(g, X, action)
        total_fixed += fixed_count
    
    num_orbits = total_fixed // len(G)
    return num_orbits

def count_fixed_points(g, X, action):
    """
    计算g的不动点数
    
    参数:
        g: 群元
        X: 集合
        action: 群作用
    
    返回:
        count: 不动点数
    """
    count = 0
    for x in X:
        if action(g, x) == x:
            count += 1
    return count

# 例子：用2种颜色涂3个位置的项链（考虑旋转）
def color_necklace_example():
    """
    用r种颜色涂n个位置的项链，考虑旋转对称
    """
    n = 3  # 位置数
    r = 2  # 颜色数
    
    # 所有可能的涂色
    colorings = []
    for i in range(r**n):
        coloring = []
        temp = i
        for _ in range(n):
            coloring.append(temp % r)
            temp //= r
        colorings.append(tuple(coloring))
    
    # 旋转群 Z/nZ
    def rotate(coloring, k):
        """旋转k个位置"""
        return tuple(coloring[(i + k) % n] for i in range(n))
    
    # 群作用
    G = list(range(n))  # 旋转0, 1, ..., n-1个位置
    
    def action(k, coloring):
        return rotate(coloring, k)
    
    num_orbits = burnside_count_orbits(G, colorings, action)
    print(f"用{r}种颜色涂{n}个位置的项链，考虑旋转，有{num_orbits}种本质不同的涂色")
    
    return num_orbits

color_necklace_example()
```

### 4.2 应用：计数问题

```python
def count_colorings_with_symmetry(n_positions, n_colors, symmetry_group, action):
    """
    计算考虑对称性的涂色数
    
    参数:
        n_positions: 位置数
        n_colors: 颜色数
        symmetry_group: 对称群
        action: 群作用
    
    返回:
        num_colorings: 本质不同的涂色数
    """
    # 所有可能的涂色
    all_colorings = []
    for i in range(n_colors**n_positions):
        coloring = []
        temp = i
        for _ in range(n_positions):
            coloring.append(temp % n_colors)
            temp //= n_colors
        all_colorings.append(tuple(coloring))
    
    # 使用Burnside引理
    num_colorings = burnside_count_orbits(symmetry_group, all_colorings, action)
    
    return num_colorings

# 例子：2×2网格的涂色（考虑旋转和反射）
def grid_coloring_example():
    """
    用2种颜色涂2×2网格，考虑D₄对称（旋转和反射）
    """
    n_positions = 4  # 2×2 = 4个位置
    n_colors = 2
    
    # D₄群（8个元素）
    # 旋转：0°, 90°, 180°, 270°
    # 反射：4种反射轴
    
    def rotate_90(grid):
        """旋转90度"""
        # grid是2×2，展平为4元组
        return (grid[2], grid[0], grid[3], grid[1])
    
    def reflect_horizontal(grid):
        """水平反射"""
        return (grid[2], grid[3], grid[0], grid[1])
    
    # 构造D₄群（简化，只考虑部分对称）
    G = ['id', 'rot90', 'rot180', 'rot270', 'refl_h']
    
    def action(g, grid):
        if g == 'id':
            return grid
        elif g == 'rot90':
            return rotate_90(grid)
        elif g == 'rot180':
            return rotate_90(rotate_90(grid))
        elif g == 'rot270':
            return rotate_90(rotate_90(rotate_90(grid)))
        elif g == 'refl_h':
            return reflect_horizontal(grid)
    
    # 所有涂色
    all_colorings = []
    for i in range(2**4):
        coloring = tuple((i >> j) & 1 for j in range(4))
        all_colorings.append(coloring)
    
    num = burnside_count_orbits(G, all_colorings, action)
    print(f"2×2网格用2种颜色涂色，考虑D₄对称，有{num}种本质不同的涂色")
    
    return num
```

### 4.3 验证：直接计算轨道

```python
def count_orbits_directly(G, X, action):
    """
    直接计算轨道数（用于验证Burnside引理）
    
    参数:
        G: 群
        X: 集合
        action: 群作用
    
    返回:
        num_orbits: 轨道数
        orbits: 轨道列表
    """
    visited = set()
    orbits = []
    
    for x in X:
        if x in visited:
            continue
        
        # 计算x的轨道
        orbit = set()
        queue = [x]
        
        while queue:
            current = queue.pop(0)
            if current in visited:
                continue
            
            visited.add(current)
            orbit.add(current)
            
            # 添加所有g·current
            for g in G:
                gx = action(g, current)
                if gx not in visited:
                    queue.append(gx)
        
        orbits.append(orbit)
    
    return len(orbits), orbits

# 验证Burnside引理
def verify_burnside_lemma(G, X, action):
    """
    验证Burnside引理
    
    参数:
        G: 群
        X: 集合
        action: 群作用
    
    返回:
        burnside_count: Burnside引理计算的轨道数
        direct_count: 直接计算的轨道数
        match: 是否一致
    """
    burnside_count = burnside_count_orbits(G, X, action)
    direct_count, _ = count_orbits_directly(G, X, action)
    
    match = burnside_count == direct_count
    
    return {
        'burnside_count': burnside_count,
        'direct_count': direct_count,
        'match': match
    }
```

---

## 五、范畴表征（抽象）

### 5.1 轨道-稳定子定理

**Burnside引理**与**轨道-稳定子定理**相关：

- **轨道-稳定子**：$|G \cdot x| = |G| / |\operatorname{Stab}(x)|$
- **Burnside**：$|X/G| = \frac{1}{|G|} \sum_{g \in G} |X^g|$
- 两者通过双重计数联系

### 5.2 表示论

在**表示论**中：

- Burnside引理对应特征标的内积
- 这是特征标理论的基础

### 5.3 组合结构

在**组合数学**中：

- Burnside引理是计数对称对象的标准方法
- 应用于图论、设计理论等

---

## 六、应用实例

### 6.1 经典例子

**例子1**：用3种颜色涂正三角形的顶点，考虑旋转对称

- $G = \mathbb{Z}/3\mathbb{Z}$（3个旋转）
- $X$ = 所有 $3^3 = 27$ 种涂色
- 使用Burnside引理计算本质不同的涂色数

**例子2**：项链问题

- 用 $r$ 种颜色涂 $n$ 个位置的项链
- 考虑旋转对称（$G = \mathbb{Z}/n\mathbb{Z}$）
- 本质不同的项链数 = $\frac{1}{n} \sum_{d|n} \phi(d) r^{n/d}$

**例子3**：立方体的面涂色

- 用 $r$ 种颜色涂立方体的6个面
- 考虑旋转对称（$G$ 是立方体的旋转群，24阶）
- 使用Burnside引理计算

### 6.2 图论应用

**例子4**：图的同构类

- 计算 $n$ 个顶点的图的同构类数
- 对称群 $S_n$ 作用在图的集合上
- 使用Burnside引理

**例子5**：化学结构

- 计算分子的同分异构体数
- 考虑分子的对称性
- 使用Burnside引理

---

## 七、历史背景

### 7.1 发现历史

- **19世纪**：Cauchy 和 Frobenius 证明
- **误称**：错误地归于Burnside
- **现代**：成为组合数学的基础工具

### 7.2 现代意义

Burnside引理是：
- 组合数学的基础定理
- 计数对称对象的标准方法
- 图论和设计理论的应用

---

## 八、证明思路

### 8.1 标准证明（双重计数）

**证明**：

1. **计算不动点对**：计算 $(g, x)$ 对，其中 $g \cdot x = x$

2. **方法1**：对每个 $g \in G$，计算 $|X^g|$
   $$\sum_{g \in G} |X^g|$$

3. **方法2**：对每个 $x \in X$，计算 $|\operatorname{Stab}(x)|$
   $$\sum_{x \in X} |\operatorname{Stab}(x)| = \sum_{x \in X} \frac{|G|}{|G \cdot x|} = |G| \sum_{x \in X} \frac{1}{|G \cdot x|}$$

4. **轨道分解**：$\sum_{x \in X} \frac{1}{|G \cdot x|} = \sum_{O \in X/G} \sum_{x \in O} \frac{1}{|O|} = |X/G|$

5. **结论**：$\sum_{g \in G} |X^g| = |G| \cdot |X/G|$，因此 $|X/G| = \frac{1}{|G|} \sum_{g \in G} |X^g|$

### 8.2 使用特征标

**证明思路**：

- 使用表示论的方法
- Burnside引理对应特征标的内积
- 这是更抽象的证明

---

## 九、推广与变体

### 9.1 加权版本

对于加权集合，有加权的Burnside引理。

### 9.2 无限群

对于无限群，有类似的定理（需要测度）。

### 9.3 Pólya计数定理

**Pólya计数定理**是Burnside引理的推广，考虑颜色的权重。

---

**状态**: ✅ 完成（已深化）
**字数**: 约2,400字
**数学公式数**: 8个
**例子数**: 6个
**最后更新**: 2026年01月02日
