# æ•°å€¼åˆ†æ / Numerical Analysis

## ç›®å½• / Table of Contents

- [æ•°å€¼åˆ†æ / Numerical Analysis](#æ•°å€¼åˆ†æ--numerical-analysis)
  - [ç›®å½• / Table of Contents](#ç›®å½•--table-of-contents)
  - [ğŸ—ºï¸ æ•°å€¼åˆ†ææ ¸å¿ƒæ¦‚å¿µæ€ç»´å¯¼å›¾](#ï¸-æ•°å€¼åˆ†ææ ¸å¿ƒæ¦‚å¿µæ€ç»´å¯¼å›¾)
  - [ğŸ“Š æ•°å€¼åˆ†ææ ¸å¿ƒæ¦‚å¿µå¤šç»´çŸ¥è¯†çŸ©é˜µ](#-æ•°å€¼åˆ†ææ ¸å¿ƒæ¦‚å¿µå¤šç»´çŸ¥è¯†çŸ©é˜µ)
  - [1. åŸºæœ¬æ¦‚å¿µ / Basic Concepts](#1-åŸºæœ¬æ¦‚å¿µ--basic-concepts)
    - [1.1 è¯¯å·®åˆ†æ / Error Analysis](#11-è¯¯å·®åˆ†æ--error-analysis)
    - [1.2 æ¡ä»¶æ•°ä¸ç¨³å®šæ€§ / Condition Number and Stability](#12-æ¡ä»¶æ•°ä¸ç¨³å®šæ€§--condition-number-and-stability)
    - [1.3 æµ®ç‚¹è¿ç®— / Floating Point Arithmetic](#13-æµ®ç‚¹è¿ç®—--floating-point-arithmetic)
  - [2. æ’å€¼ä¸é€¼è¿‘ / Interpolation and Approximation](#2-æ’å€¼ä¸é€¼è¿‘--interpolation-and-approximation)
    - [2.1 æ‹‰æ ¼æœ—æ—¥æ’å€¼ / Lagrange Interpolation](#21-æ‹‰æ ¼æœ—æ—¥æ’å€¼--lagrange-interpolation)
    - [2.2 ç‰›é¡¿æ’å€¼ / Newton Interpolation](#22-ç‰›é¡¿æ’å€¼--newton-interpolation)
    - [2.3 æ ·æ¡æ’å€¼ / Spline Interpolation](#23-æ ·æ¡æ’å€¼--spline-interpolation)
    - [2.4 æœ€å°äºŒä¹˜é€¼è¿‘ / Least Squares Approximation](#24-æœ€å°äºŒä¹˜é€¼è¿‘--least-squares-approximation)
  - [3. æ•°å€¼ç§¯åˆ† / Numerical Integration](#3-æ•°å€¼ç§¯åˆ†--numerical-integration)
    - [3.1 ç‰›é¡¿-ç§‘èŒ¨å…¬å¼ / Newton-Cotes Formulas](#31-ç‰›é¡¿-ç§‘èŒ¨å…¬å¼--newton-cotes-formulas)
    - [3.2 é«˜æ–¯æ±‚ç§¯ / Gaussian Quadrature](#32-é«˜æ–¯æ±‚ç§¯--gaussian-quadrature)
    - [3.3 è‡ªé€‚åº”æ±‚ç§¯ / Adaptive Quadrature](#33-è‡ªé€‚åº”æ±‚ç§¯--adaptive-quadrature)
  - [4. æ•°å€¼å¾®åˆ† / Numerical Differentiation](#4-æ•°å€¼å¾®åˆ†--numerical-differentiation)
    - [4.1 æœ‰é™å·®åˆ† / Finite Differences](#41-æœ‰é™å·®åˆ†--finite-differences)
    - [4.2 é«˜é˜¶å¯¼æ•° / Higher Order Derivatives](#42-é«˜é˜¶å¯¼æ•°--higher-order-derivatives)
    - [4.3 è‡ªåŠ¨å¾®åˆ† / Automatic Differentiation](#43-è‡ªåŠ¨å¾®åˆ†--automatic-differentiation)
  - [5. çº¿æ€§æ–¹ç¨‹ç»„ / Linear Systems](#5-çº¿æ€§æ–¹ç¨‹ç»„--linear-systems)
    - [5.1 é«˜æ–¯æ¶ˆå…ƒæ³• / Gaussian Elimination](#51-é«˜æ–¯æ¶ˆå…ƒæ³•--gaussian-elimination)
    - [5.2 LUåˆ†è§£ / LU Decomposition](#52-luåˆ†è§£--lu-decomposition)
    - [5.3 è¿­ä»£æ–¹æ³• / Iterative Methods](#53-è¿­ä»£æ–¹æ³•--iterative-methods)
  - [6. éçº¿æ€§æ–¹ç¨‹ / Nonlinear Equations](#6-éçº¿æ€§æ–¹ç¨‹--nonlinear-equations)
    - [6.1 äºŒåˆ†æ³• / Bisection Method](#61-äºŒåˆ†æ³•--bisection-method)
    - [6.2 ç‰›é¡¿æ³• / Newton's Method](#62-ç‰›é¡¿æ³•--newtons-method)
    - [6.3 å‰²çº¿æ³• / Secant Method](#63-å‰²çº¿æ³•--secant-method)
  - [7. å¾®åˆ†æ–¹ç¨‹æ•°å€¼è§£ / Numerical Solution of Differential Equations](#7-å¾®åˆ†æ–¹ç¨‹æ•°å€¼è§£--numerical-solution-of-differential-equations)
    - [7.1 æ¬§æ‹‰æ–¹æ³• / Euler's Method](#71-æ¬§æ‹‰æ–¹æ³•--eulers-method)
    - [7.2 é¾™æ ¼-åº“å¡”æ–¹æ³• / Runge-Kutta Methods](#72-é¾™æ ¼-åº“å¡”æ–¹æ³•--runge-kutta-methods)
    - [7.3 å¤šæ­¥æ–¹æ³• / Multistep Methods](#73-å¤šæ­¥æ–¹æ³•--multistep-methods)
  - [8. å½¢å¼åŒ–å®ç° / Formal Implementation](#8-å½¢å¼åŒ–å®ç°--formal-implementation)
    - [8.1 Lean 4 å®ç° / Lean 4 Implementation](#81-lean-4-å®ç°--lean-4-implementation)
    - [8.2 Haskell å®ç° / Haskell Implementation](#82-haskell-å®ç°--haskell-implementation)
    - [8.3 é‡è¦å®šç†æ€»ç»“ / Summary of Important Theorems](#83-é‡è¦å®šç†æ€»ç»“--summary-of-important-theorems)
  - [å‚è€ƒæ–‡çŒ® / References](#å‚è€ƒæ–‡çŒ®--references)
  - [äº¤äº’ä¸è¡¥å……èµ„æº / Interactive \& Supplementary Resources](#äº¤äº’ä¸è¡¥å……èµ„æº--interactive--supplementary-resources)
    - [äº¤äº’å¼å›¾è¡¨å¢å¼º](#äº¤äº’å¼å›¾è¡¨å¢å¼º)
    - [å®šç†è¯æ˜è¡¥å……](#å®šç†è¯æ˜è¡¥å……)
    - [åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……](#åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……)
    - [å†å²èƒŒæ™¯è¡¥å……](#å†å²èƒŒæ™¯è¡¥å……)

---

## ğŸ—ºï¸ æ•°å€¼åˆ†ææ ¸å¿ƒæ¦‚å¿µæ€ç»´å¯¼å›¾

```mermaid
mindmap
  root((æ•°å€¼åˆ†æ))
    è¯¯å·®åˆ†æ
      è¯¯å·®ç±»å‹
        ç»å¯¹è¯¯å·®
        ç›¸å¯¹è¯¯å·®
        æœ‰æ•ˆæ•°å­—
      æ¡ä»¶æ•°
        æ¡ä»¶æ•°
        ç¨³å®šæ€§
      æµ®ç‚¹è¿ç®—
        æµ®ç‚¹æ•°
        æœºå™¨ç²¾åº¦
    æ’å€¼é€¼è¿‘
      æ’å€¼
        æ‹‰æ ¼æœ—æ—¥æ’å€¼
        ç‰›é¡¿æ’å€¼
        æ ·æ¡æ’å€¼
      é€¼è¿‘
        æœ€å°äºŒä¹˜
        å¤šé¡¹å¼é€¼è¿‘
    æ•°å€¼ç§¯åˆ†
      ç‰›é¡¿-ç§‘èŒ¨
        ç‰›é¡¿-ç§‘èŒ¨å…¬å¼
        æ¢¯å½¢å…¬å¼
        è¾›æ™®æ£®å…¬å¼
      é«˜æ–¯æ±‚ç§¯
        é«˜æ–¯æ±‚ç§¯
        é«˜æ–¯ç‚¹
      è‡ªé€‚åº”æ±‚ç§¯
        è‡ªé€‚åº”æ±‚ç§¯
        è¯¯å·®æ§åˆ¶
    æ•°å€¼å¾®åˆ†
      æœ‰é™å·®åˆ†
        æœ‰é™å·®åˆ†
        å·®åˆ†å…¬å¼
      é«˜é˜¶å¯¼æ•°
        é«˜é˜¶å¯¼æ•°
        å·®åˆ†æ–¹æ³•
      è‡ªåŠ¨å¾®åˆ†
        è‡ªåŠ¨å¾®åˆ†
        ADç®—æ³•
    çº¿æ€§æ–¹ç¨‹ç»„
      ç›´æ¥æ–¹æ³•
        é«˜æ–¯æ¶ˆå…ƒ
        LUåˆ†è§£
        çŸ©é˜µåˆ†è§£
      è¿­ä»£æ–¹æ³•
        è¿­ä»£æ³•
        æ”¶æ•›æ€§
    éçº¿æ€§æ–¹ç¨‹
      äºŒåˆ†æ³•
        äºŒåˆ†æ³•
        æ”¶æ•›æ€§
      ç‰›é¡¿æ³•
        ç‰›é¡¿æ³•
        æ”¶æ•›æ€§
      å‰²çº¿æ³•
        å‰²çº¿æ³•
        æ”¶æ•›æ€§
    å¾®åˆ†æ–¹ç¨‹
      æ¬§æ‹‰æ–¹æ³•
        æ¬§æ‹‰æ–¹æ³•
        ç¨³å®šæ€§
      é¾™æ ¼-åº“å¡”
        é¾™æ ¼-åº“å¡”
        ç²¾åº¦
      å¤šæ­¥æ–¹æ³•
        å¤šæ­¥æ–¹æ³•
        ç¨³å®šæ€§
```

## ğŸ“Š æ•°å€¼åˆ†ææ ¸å¿ƒæ¦‚å¿µå¤šç»´çŸ¥è¯†çŸ©é˜µ

| æ¦‚å¿µç±»åˆ« | æ ¸å¿ƒæ¦‚å¿µ | å®šä¹‰è¦ç‚¹ | å…³é”®æ€§è´¨ | å…¸å‹ä¾‹å­ | åº”ç”¨åœºæ™¯ |
|---------|---------|---------|---------|---------|---------|
| è¯¯å·®åˆ†æ | ç»å¯¹è¯¯å·® | è¯¯å·®ç»å¯¹å€¼ | è¯¯å·®åº¦é‡ | \|x-xÌ‚\| | è¯¯å·®åˆ†æ |
| è¯¯å·®åˆ†æ | ç›¸å¯¹è¯¯å·® | ç›¸å¯¹è¯¯å·® | è¯¯å·®åº¦é‡ | \|x-xÌ‚\|/\|x\| | è¯¯å·®åˆ†æ |
| è¯¯å·®åˆ†æ | æ¡ä»¶æ•° | æ¡ä»¶æ•° | ç¨³å®šæ€§ | Îº(f,x) | è¯¯å·®åˆ†æ |
| è¯¯å·®åˆ†æ | æ•°å€¼ç¨³å®šæ€§ | ç¨³å®šæ€§ | è¯¯å·®æ§åˆ¶ | ç¨³å®šæ€§ | è¯¯å·®åˆ†æ |
| æ’å€¼é€¼è¿‘ | æ‹‰æ ¼æœ—æ—¥æ’å€¼ | æ’å€¼å¤šé¡¹å¼ | å”¯ä¸€æ€§ | L(x) | æ’å€¼æ–¹æ³• |
| æ’å€¼é€¼è¿‘ | ç‰›é¡¿æ’å€¼ | å·®å•†æ’å€¼ | é€’æ¨æ€§ | N(x) | æ’å€¼æ–¹æ³• |
| æ’å€¼é€¼è¿‘ | æ ·æ¡æ’å€¼ | åˆ†æ®µæ’å€¼ | å…‰æ»‘æ€§ | S(x) | æ’å€¼æ–¹æ³• |
| æ’å€¼é€¼è¿‘ | æœ€å°äºŒä¹˜ | æœ€å°äºŒä¹˜ | æœ€ä¼˜æ€§ | æœ€å°äºŒä¹˜ | é€¼è¿‘æ–¹æ³• |
| æ•°å€¼ç§¯åˆ† | ç‰›é¡¿-ç§‘èŒ¨å…¬å¼ | æ•°å€¼ç§¯åˆ† | ç²¾åº¦ | ç‰›é¡¿-ç§‘èŒ¨ | æ•°å€¼ç§¯åˆ† |
| æ•°å€¼ç§¯åˆ† | é«˜æ–¯æ±‚ç§¯ | é«˜æ–¯æ±‚ç§¯ | é«˜ç²¾åº¦ | é«˜æ–¯æ±‚ç§¯ | æ•°å€¼ç§¯åˆ† |
| æ•°å€¼ç§¯åˆ† | è‡ªé€‚åº”æ±‚ç§¯ | è‡ªé€‚åº” | è¯¯å·®æ§åˆ¶ | è‡ªé€‚åº” | æ•°å€¼ç§¯åˆ† |
| æ•°å€¼å¾®åˆ† | æœ‰é™å·®åˆ† | å·®åˆ†å…¬å¼ | ç²¾åº¦ | æœ‰é™å·®åˆ† | æ•°å€¼å¾®åˆ† |
| æ•°å€¼å¾®åˆ† | è‡ªåŠ¨å¾®åˆ† | ADç®—æ³• | ç²¾ç¡®æ€§ | AD | æ•°å€¼å¾®åˆ† |
| çº¿æ€§æ–¹ç¨‹ç»„ | é«˜æ–¯æ¶ˆå…ƒ | æ¶ˆå…ƒæ³• | ç›´æ¥æ³• | é«˜æ–¯æ¶ˆå…ƒ | çº¿æ€§ç³»ç»Ÿ |
| çº¿æ€§æ–¹ç¨‹ç»„ | LUåˆ†è§£ | çŸ©é˜µåˆ†è§£ | åˆ†è§£ | LU | çº¿æ€§ç³»ç»Ÿ |
| çº¿æ€§æ–¹ç¨‹ç»„ | è¿­ä»£æ–¹æ³• | è¿­ä»£æ³• | æ”¶æ•›æ€§ | è¿­ä»£æ³• | çº¿æ€§ç³»ç»Ÿ |
| éçº¿æ€§æ–¹ç¨‹ | äºŒåˆ†æ³• | äºŒåˆ†æ³• | æ”¶æ•›æ€§ | äºŒåˆ†æ³• | éçº¿æ€§ç³»ç»Ÿ |
| éçº¿æ€§æ–¹ç¨‹ | ç‰›é¡¿æ³• | ç‰›é¡¿æ³• | äºŒæ¬¡æ”¶æ•› | ç‰›é¡¿æ³• | éçº¿æ€§ç³»ç»Ÿ |
| éçº¿æ€§æ–¹ç¨‹ | å‰²çº¿æ³• | å‰²çº¿æ³• | è¶…çº¿æ€§æ”¶æ•› | å‰²çº¿æ³• | éçº¿æ€§ç³»ç»Ÿ |
| å¾®åˆ†æ–¹ç¨‹ | æ¬§æ‹‰æ–¹æ³• | æ¬§æ‹‰æ³• | ä¸€é˜¶ç²¾åº¦ | æ¬§æ‹‰æ³• | å¾®åˆ†æ–¹ç¨‹ |
| å¾®åˆ†æ–¹ç¨‹ | é¾™æ ¼-åº“å¡” | RKæ–¹æ³• | é«˜é˜¶ç²¾åº¦ | RK4 | å¾®åˆ†æ–¹ç¨‹ |
| å¾®åˆ†æ–¹ç¨‹ | å¤šæ­¥æ–¹æ³• | å¤šæ­¥æ³• | ç¨³å®šæ€§ | å¤šæ­¥æ³• | å¾®åˆ†æ–¹ç¨‹ |
| åº”ç”¨ | ç§‘å­¦è®¡ç®— | æ•°å€¼æ–¹æ³• | è®¡ç®— | ç§‘å­¦è®¡ç®— | å·¥ç¨‹åº”ç”¨ |

## 1. åŸºæœ¬æ¦‚å¿µ / Basic Concepts

### 1.1 è¯¯å·®åˆ†æ / Error Analysis

**å®šä¹‰ 1.1.1** (ç»å¯¹è¯¯å·® / Absolute Error)
ç»å¯¹è¯¯å·®å®šä¹‰ä¸ºï¼š
$$E_a = |x - \hat{x}|$$
å…¶ä¸­ $x$ æ˜¯ç²¾ç¡®å€¼ï¼Œ$\hat{x}$ æ˜¯è¿‘ä¼¼å€¼ã€‚

**å®šä¹‰ 1.1.2** (ç›¸å¯¹è¯¯å·® / Relative Error)
ç›¸å¯¹è¯¯å·®å®šä¹‰ä¸ºï¼š
$$E_r = \frac{|x - \hat{x}|}{|x|}$$

**å®šä¹‰ 1.1.3** (æœ‰æ•ˆæ•°å­— / Significant Digits)
è¿‘ä¼¼å€¼ $\hat{x}$ æœ‰ $n$ ä½æœ‰æ•ˆæ•°å­—ï¼Œå¦‚æœï¼š
$$\frac{|x - \hat{x}|}{|x|} \leq \frac{1}{2} \times 10^{-n+1}$$

**å®šç† 1.1.1** (è¯¯å·®ä¼ æ’­ / Error Propagation)
å¯¹äºå‡½æ•° $f(x_1, \ldots, x_n)$ï¼Œå¦‚æœ $x_i$ çš„è¯¯å·®ä¸º $\Delta x_i$ï¼Œåˆ™ï¼š
$$\Delta f \approx \sum_{i=1}^n \left|\frac{\partial f}{\partial x_i}\right| |\Delta x_i|$$

### 1.2 æ¡ä»¶æ•°ä¸ç¨³å®šæ€§ / Condition Number and Stability

**å®šä¹‰ 1.2.1** (æ¡ä»¶æ•° / Condition Number)
å‡½æ•° $f$ åœ¨ç‚¹ $x$ çš„æ¡ä»¶æ•°å®šä¹‰ä¸ºï¼š
$$\kappa(f,x) = \lim_{\epsilon \to 0} \sup_{|\Delta x| \leq \epsilon} \frac{|f(x + \Delta x) - f(x)|}{|f(x)|} \cdot \frac{|x|}{|\Delta x|}$$

**å®šä¹‰ 1.2.2** (æ•°å€¼ç¨³å®šæ€§ / Numerical Stability)
ç®—æ³•ç§°ä¸ºæ•°å€¼ç¨³å®šçš„ï¼Œå¦‚æœè¾“å…¥çš„å°æ‰°åŠ¨åªå¯¼è‡´è¾“å‡ºçš„å°æ‰°åŠ¨ã€‚

**å®šç† 1.2.1** (æ¡ä»¶æ•°çš„è®¡ç®— / Computation of Condition Number)
å¯¹äºå¯å¾®å‡½æ•° $f$ï¼š
$$\kappa(f,x) = \left|\frac{x f'(x)}{f(x)}\right|$$

### 1.3 æµ®ç‚¹è¿ç®— / Floating Point Arithmetic

**å®šä¹‰ 1.3.1** (æµ®ç‚¹æ•° / Floating Point Number)
æµ®ç‚¹æ•°è¡¨ç¤ºä¸ºï¼š
$$x = \pm d_0.d_1d_2 \cdots d_{p-1} \times \beta^e$$
å…¶ä¸­ $\beta$ æ˜¯åŸºæ•°ï¼Œ$p$ æ˜¯ç²¾åº¦ï¼Œ$e$ æ˜¯æŒ‡æ•°ã€‚

**å®šä¹‰ 1.3.2** (æœºå™¨ç²¾åº¦ / Machine Epsilon)
æœºå™¨ç²¾åº¦ $\epsilon$ æ˜¯ $1$ ä¸å¤§äº $1$ çš„æœ€å°æµ®ç‚¹æ•°ä¹‹é—´çš„å·®ã€‚

**å®šç† 1.3.1** (æµ®ç‚¹è¿ç®—çš„è¯¯å·®ç•Œ / Error Bounds for Floating Point Operations)
å¯¹äºæµ®ç‚¹è¿ç®— $\oplus$ï¼š
$$|(x \oplus y) - (x + y)| \leq \epsilon |x + y|$$

---

## 2. æ’å€¼ä¸é€¼è¿‘ / Interpolation and Approximation

### 2.1 æ‹‰æ ¼æœ—æ—¥æ’å€¼ / Lagrange Interpolation

**å®šä¹‰ 2.1.1** (æ‹‰æ ¼æœ—æ—¥æ’å€¼ / Lagrange Interpolation)
ç»™å®šç‚¹é›† $(x_i, y_i)$ï¼Œ$i = 0, 1, \ldots, n$ï¼Œæ‹‰æ ¼æœ—æ—¥æ’å€¼å¤šé¡¹å¼å®šä¹‰ä¸ºï¼š
$$L_n(x) = \sum_{i=0}^n y_i \ell_i(x)$$
å…¶ä¸­ï¼š
$$\ell_i(x) = \prod_{j=0, j \neq i}^n \frac{x - x_j}{x_i - x_j}$$

**å®šç† 2.1.1** (æ‹‰æ ¼æœ—æ—¥æ’å€¼çš„å”¯ä¸€æ€§ / Uniqueness of Lagrange Interpolation)
é€šè¿‡ $n+1$ ä¸ªä¸åŒç‚¹çš„ $n$ æ¬¡æ’å€¼å¤šé¡¹å¼æ˜¯å”¯ä¸€çš„ã€‚

**å®šç† 2.1.2** (æ’å€¼è¯¯å·® / Interpolation Error)
å¦‚æœ $f \in C^{n+1}[a,b]$ï¼Œåˆ™ï¼š
$$f(x) - L_n(x) = \frac{f^{(n+1)}(\xi)}{(n+1)!} \prod_{i=0}^n (x - x_i)$$
å…¶ä¸­ $\xi \in (a,b)$ã€‚

### 2.2 ç‰›é¡¿æ’å€¼ / Newton Interpolation

**å®šä¹‰ 2.2.1** (å·®å•† / Divided Difference)
$k$ é˜¶å·®å•†å®šä¹‰ä¸ºï¼š
$$f[x_0, x_1, \ldots, x_k] = \frac{f[x_1, \ldots, x_k] - f[x_0, \ldots, x_{k-1}]}{x_k - x_0}$$

**å®šä¹‰ 2.2.2** (ç‰›é¡¿æ’å€¼å¤šé¡¹å¼ / Newton Interpolation Polynomial)
ç‰›é¡¿æ’å€¼å¤šé¡¹å¼å®šä¹‰ä¸ºï¼š
$$N_n(x) = f[x_0] + f[x_0, x_1](x - x_0) + \cdots + f[x_0, \ldots, x_n](x - x_0) \cdots (x - x_{n-1})$$

**å®šç† 2.2.1** (ç‰›é¡¿æ’å€¼çš„æ€§è´¨ / Properties of Newton Interpolation)
ç‰›é¡¿æ’å€¼å¤šé¡¹å¼ä¸æ‹‰æ ¼æœ—æ—¥æ’å€¼å¤šé¡¹å¼ç›¸åŒï¼Œä½†è®¡ç®—æ›´é«˜æ•ˆã€‚

### 2.3 æ ·æ¡æ’å€¼ / Spline Interpolation

**å®šä¹‰ 2.3.1** (æ ·æ¡å‡½æ•° / Spline Function)
$k$ æ¬¡æ ·æ¡å‡½æ•°æ˜¯åœ¨æ¯ä¸ªå­åŒºé—´ $[x_i, x_{i+1}]$ ä¸Šä¸º $k$ æ¬¡å¤šé¡¹å¼çš„åˆ†æ®µå‡½æ•°ã€‚

**å®šä¹‰ 2.3.2** (ä¸‰æ¬¡æ ·æ¡ / Cubic Spline)
ä¸‰æ¬¡æ ·æ¡ $S(x)$ æ»¡è¶³ï¼š

1. $S(x_i) = y_i$ï¼Œ$i = 0, 1, \ldots, n$
2. $S \in C^2[a,b]$
3. $S''(a) = S''(b) = 0$ï¼ˆè‡ªç„¶è¾¹ç•Œæ¡ä»¶ï¼‰

**å®šç† 2.3.1** (ä¸‰æ¬¡æ ·æ¡çš„å­˜åœ¨å”¯ä¸€æ€§ / Existence and Uniqueness of Cubic Spline)
åœ¨è‡ªç„¶è¾¹ç•Œæ¡ä»¶ä¸‹ï¼Œä¸‰æ¬¡æ ·æ¡æ’å€¼å­˜åœ¨ä¸”å”¯ä¸€ã€‚

### 2.4 æœ€å°äºŒä¹˜é€¼è¿‘ / Least Squares Approximation

**å®šä¹‰ 2.4.1** (æœ€å°äºŒä¹˜é€¼è¿‘ / Least Squares Approximation)
ç»™å®šç‚¹é›† $(x_i, y_i)$ï¼Œ$i = 0, 1, \ldots, m$ï¼Œæœ€å°äºŒä¹˜é€¼è¿‘æ˜¯ä½¿è¯¯å·®å¹³æ–¹å’Œæœ€å°çš„å‡½æ•°ï¼š
$$\min \sum_{i=0}^m (y_i - f(x_i))^2$$

**å®šç† 2.4.1** (å¤šé¡¹å¼æœ€å°äºŒä¹˜é€¼è¿‘ / Polynomial Least Squares)
$n$ æ¬¡å¤šé¡¹å¼æœ€å°äºŒä¹˜é€¼è¿‘çš„ç³»æ•°æ»¡è¶³æ­£è§„æ–¹ç¨‹ç»„ï¼š
$$\sum_{j=0}^n a_j \sum_{i=0}^m x_i^{j+k} = \sum_{i=0}^m y_i x_i^k$$

---

## 3. æ•°å€¼ç§¯åˆ† / Numerical Integration

### 3.1 ç‰›é¡¿-ç§‘èŒ¨å…¬å¼ / Newton-Cotes Formulas

**å®šä¹‰ 3.1.1** (ç‰›é¡¿-ç§‘èŒ¨å…¬å¼ / Newton-Cotes Formula)
ç‰›é¡¿-ç§‘èŒ¨å…¬å¼å®šä¹‰ä¸ºï¼š
$$\int_a^b f(x) dx \approx \sum_{i=0}^n w_i f(x_i)$$
å…¶ä¸­ $w_i$ æ˜¯æƒé‡ï¼Œ$x_i$ æ˜¯èŠ‚ç‚¹ã€‚

**å®šç† 3.1.1** (æ¢¯å½¢æ³•åˆ™ / Trapezoidal Rule)
$$\int_a^b f(x) dx \approx \frac{h}{2}[f(a) + 2f(a+h) + \cdots + 2f(b-h) + f(b)]$$
å…¶ä¸­ $h = \frac{b-a}{n}$ã€‚

**å®šç† 3.1.2** (è¾›æ™®æ£®æ³•åˆ™ / Simpson's Rule)
$$\int_a^b f(x) dx \approx \frac{h}{3}[f(a) + 4f(a+h) + 2f(a+2h) + \cdots + 4f(b-h) + f(b)]$$

### 3.2 é«˜æ–¯æ±‚ç§¯ / Gaussian Quadrature

**å®šä¹‰ 3.2.1** (é«˜æ–¯æ±‚ç§¯ / Gaussian Quadrature)
é«˜æ–¯æ±‚ç§¯å…¬å¼å®šä¹‰ä¸ºï¼š
$$\int_{-1}^1 f(x) dx \approx \sum_{i=1}^n w_i f(x_i)$$
å…¶ä¸­ $x_i$ æ˜¯å‹’è®©å¾·å¤šé¡¹å¼çš„é›¶ç‚¹ï¼Œ$w_i$ æ˜¯å¯¹åº”çš„æƒé‡ã€‚

**å®šç† 3.2.1** (é«˜æ–¯æ±‚ç§¯çš„ç²¾åº¦ / Precision of Gaussian Quadrature)
$n$ ç‚¹é«˜æ–¯æ±‚ç§¯å¯¹ $2n-1$ æ¬¡å¤šé¡¹å¼ç²¾ç¡®ã€‚

**å®šç† 3.2.2** (é«˜æ–¯æ±‚ç§¯çš„è¯¯å·® / Error of Gaussian Quadrature)
å¦‚æœ $f \in C^{2n}[-1,1]$ï¼Œåˆ™ï¼š
$$\int_{-1}^1 f(x) dx - \sum_{i=1}^n w_i f(x_i) = \frac{f^{(2n)}(\xi)}{(2n)!} \int_{-1}^1 \prod_{i=1}^n (x - x_i)^2 dx$$

### 3.3 è‡ªé€‚åº”æ±‚ç§¯ / Adaptive Quadrature

**å®šä¹‰ 3.3.1** (è‡ªé€‚åº”æ±‚ç§¯ / Adaptive Quadrature)
è‡ªé€‚åº”æ±‚ç§¯æ ¹æ®å±€éƒ¨è¯¯å·®è‡ªåŠ¨è°ƒæ•´æ­¥é•¿ã€‚

**ç®—æ³• 3.3.1** (è‡ªé€‚åº”è¾›æ™®æ£®æ±‚ç§¯ / Adaptive Simpson Quadrature)

```python
def adaptive_simpson(f, a, b, tol):
    def simpson(f, a, b):
        h = (b - a) / 2
        return h/3 * (f(a) + 4*f(a+h) + f(b))

    def adaptive(f, a, b, tol):
        c = (a + b) / 2
        S1 = simpson(f, a, b)
        S2 = simpson(f, a, c) + simpson(f, c, b)

        if abs(S1 - S2) < 15*tol:
            return S2
        else:
            return adaptive(f, a, c, tol/2) + adaptive(f, c, b, tol/2)

    return adaptive(f, a, b, tol)
```

---

## 4. æ•°å€¼å¾®åˆ† / Numerical Differentiation

### 4.1 æœ‰é™å·®åˆ† / Finite Differences

**å®šä¹‰ 4.1.1** (å‰å‘å·®åˆ† / Forward Difference)
$$f'(x) \approx \frac{f(x+h) - f(x)}{h}$$

**å®šä¹‰ 4.1.2** (åå‘å·®åˆ† / Backward Difference)
$$f'(x) \approx \frac{f(x) - f(x-h)}{h}$$

**å®šä¹‰ 4.1.3** (ä¸­å¿ƒå·®åˆ† / Central Difference)
$$f'(x) \approx \frac{f(x+h) - f(x-h)}{2h}$$

**å®šç† 4.1.1** (å·®åˆ†å…¬å¼çš„è¯¯å·® / Error of Difference Formulas)
å‰å‘å’Œåå‘å·®åˆ†çš„è¯¯å·®ä¸º $O(h)$ï¼Œä¸­å¿ƒå·®åˆ†çš„è¯¯å·®ä¸º $O(h^2)$ã€‚

### 4.2 é«˜é˜¶å¯¼æ•° / Higher Order Derivatives

**å®šç† 4.2.1** (äºŒé˜¶å¯¼æ•°çš„ä¸­å¿ƒå·®åˆ† / Central Difference for Second Derivative)
$$f''(x) \approx \frac{f(x+h) - 2f(x) + f(x-h)}{h^2}$$

**å®šç† 4.2.2** (ç†æŸ¥æ£®å¤–æ¨ / Richardson Extrapolation)
å¯¹äºæ­¥é•¿ $h$ å’Œ $2h$ çš„è¿‘ä¼¼å€¼ $D_h$ å’Œ $D_{2h}$ï¼š
$$D = D_h + \frac{D_h - D_{2h}}{2^p - 1}$$
å…¶ä¸­ $p$ æ˜¯æ–¹æ³•çš„é˜¶æ•°ã€‚

### 4.3 è‡ªåŠ¨å¾®åˆ† / Automatic Differentiation

**å®šä¹‰ 4.3.1** (è‡ªåŠ¨å¾®åˆ† / Automatic Differentiation)
è‡ªåŠ¨å¾®åˆ†é€šè¿‡é“¾å¼æ³•åˆ™è®¡ç®—å¯¼æ•°ã€‚

**ç®—æ³• 4.3.1** (å‰å‘æ¨¡å¼è‡ªåŠ¨å¾®åˆ† / Forward Mode AD)

```python
class Dual:
    def __init__(self, value, derivative=0):
        self.value = value
        self.derivative = derivative

    def __add__(self, other):
        return Dual(self.value + other.value,
                   self.derivative + other.derivative)

    def __mul__(self, other):
        return Dual(self.value * other.value,
                   self.value * other.derivative +
                   self.derivative * other.value)
```

---

## 5. çº¿æ€§æ–¹ç¨‹ç»„ / Linear Systems

### 5.1 é«˜æ–¯æ¶ˆå…ƒæ³• / Gaussian Elimination

**ç®—æ³• 5.1.1** (é«˜æ–¯æ¶ˆå…ƒæ³• / Gaussian Elimination)

```python
def gaussian_elimination(A, b):
    n = len(A)
    # å‰å‘æ¶ˆå…ƒ
    for i in range(n):
        for j in range(i+1, n):
            factor = A[j][i] / A[i][i]
            for k in range(i, n):
                A[j][k] -= factor * A[i][k]
            b[j] -= factor * b[i]

    # å›ä»£
    x = [0] * n
    for i in range(n-1, -1, -1):
        x[i] = b[i]
        for j in range(i+1, n):
            x[i] -= A[i][j] * x[j]
        x[i] /= A[i][i]

    return x
```

**å®šç† 5.1.1** (é«˜æ–¯æ¶ˆå…ƒæ³•çš„å¤æ‚åº¦ / Complexity of Gaussian Elimination)
é«˜æ–¯æ¶ˆå…ƒæ³•çš„å¤æ‚åº¦ä¸º $O(n^3)$ã€‚

### 5.2 LUåˆ†è§£ / LU Decomposition

**å®šä¹‰ 5.2.1** (LUåˆ†è§£ / LU Decomposition)
çŸ©é˜µ $A$ çš„LUåˆ†è§£æ˜¯ $A = LU$ï¼Œå…¶ä¸­ $L$ æ˜¯ä¸‹ä¸‰è§’çŸ©é˜µï¼Œ$U$ æ˜¯ä¸Šä¸‰è§’çŸ©é˜µã€‚

**å®šç† 5.2.1** (LUåˆ†è§£çš„å­˜åœ¨æ€§ / Existence of LU Decomposition)
å¦‚æœçŸ©é˜µ $A$ çš„æ‰€æœ‰ä¸»å­å¼éé›¶ï¼Œåˆ™å­˜åœ¨LUåˆ†è§£ã€‚

**ç®—æ³• 5.2.1** (LUåˆ†è§£ç®—æ³• / LU Decomposition Algorithm)

```python
def lu_decomposition(A):
    n = len(A)
    L = [[0]*n for _ in range(n)]
    U = [[0]*n for _ in range(n)]

    for i in range(n):
        L[i][i] = 1

        for j in range(i, n):
            U[i][j] = A[i][j] - sum(L[i][k] * U[k][j] for k in range(i))

        for j in range(i+1, n):
            L[j][i] = (A[j][i] - sum(L[j][k] * U[k][i] for k in range(i))) / U[i][i]

    return L, U
```

### 5.3 è¿­ä»£æ–¹æ³• / Iterative Methods

**å®šä¹‰ 5.3.1** (é›…å¯æ¯”è¿­ä»£ / Jacobi Iteration)
$$x_i^{(k+1)} = \frac{1}{a_{ii}} \left(b_i - \sum_{j \neq i} a_{ij} x_j^{(k)}\right)$$

**å®šä¹‰ 5.3.2** (é«˜æ–¯-èµ›å¾·å°”è¿­ä»£ / Gauss-Seidel Iteration)
$$x_i^{(k+1)} = \frac{1}{a_{ii}} \left(b_i - \sum_{j < i} a_{ij} x_j^{(k+1)} - \sum_{j > i} a_{ij} x_j^{(k)}\right)$$

**å®šç† 5.3.1** (æ”¶æ•›æ€§æ¡ä»¶ / Convergence Conditions)
å¦‚æœçŸ©é˜µ $A$ ä¸¥æ ¼å¯¹è§’å ä¼˜ï¼Œåˆ™é›…å¯æ¯”å’Œé«˜æ–¯-èµ›å¾·å°”è¿­ä»£æ”¶æ•›ã€‚

---

## 6. éçº¿æ€§æ–¹ç¨‹ / Nonlinear Equations

### 6.1 äºŒåˆ†æ³• / Bisection Method

**ç®—æ³• 6.1.1** (äºŒåˆ†æ³• / Bisection Method)

```python
def bisection(f, a, b, tol):
    if f(a) * f(b) > 0:
        return None

    while (b - a) > tol:
        c = (a + b) / 2
        if f(c) == 0:
            return c
        elif f(a) * f(c) < 0:
            b = c
        else:
            a = c

    return (a + b) / 2
```

**å®šç† 6.1.1** (äºŒåˆ†æ³•çš„æ”¶æ•›æ€§ / Convergence of Bisection)
äºŒåˆ†æ³•çº¿æ€§æ”¶æ•›ï¼Œæ¯æ¬¡è¿­ä»£è¯¯å·®å‡åŠã€‚

### 6.2 ç‰›é¡¿æ³• / Newton's Method

**å®šä¹‰ 6.2.1** (ç‰›é¡¿æ³• / Newton's Method)
ç‰›é¡¿è¿­ä»£å…¬å¼ä¸ºï¼š
$$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$$

**å®šç† 6.2.1** (ç‰›é¡¿æ³•çš„æ”¶æ•›æ€§ / Convergence of Newton's Method)
å¦‚æœ $f'(r) \neq 0$ï¼Œåˆ™ç‰›é¡¿æ³•åœ¨ $r$ é™„è¿‘äºŒæ¬¡æ”¶æ•›ã€‚

**ç®—æ³• 6.2.1** (ç‰›é¡¿æ³•å®ç° / Newton's Method Implementation)

```python
def newton(f, df, x0, tol, max_iter):
    x = x0
    for i in range(max_iter):
        fx = f(x)
        dfx = df(x)

        if abs(dfx) < 1e-10:
            return None

        x_new = x - fx / dfx

        if abs(x_new - x) < tol:
            return x_new

        x = x_new

    return x
```

### 6.3 å‰²çº¿æ³• / Secant Method

**å®šä¹‰ 6.3.1** (å‰²çº¿æ³• / Secant Method)
å‰²çº¿æ³•è¿­ä»£å…¬å¼ä¸ºï¼š
$$x_{n+1} = x_n - f(x_n) \frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}$$

**å®šç† 6.3.1** (å‰²çº¿æ³•çš„æ”¶æ•›æ€§ / Convergence of Secant Method)
å‰²çº¿æ³•çš„æ”¶æ•›é˜¶ä¸º $\frac{1+\sqrt{5}}{2} \approx 1.618$ã€‚

---

## 7. å¾®åˆ†æ–¹ç¨‹æ•°å€¼è§£ / Numerical Solution of Differential Equations

### 7.1 æ¬§æ‹‰æ–¹æ³• / Euler's Method

**å®šä¹‰ 7.1.1** (æ¬§æ‹‰æ–¹æ³• / Euler's Method)
å¯¹äºåˆå€¼é—®é¢˜ $y' = f(t,y)$ï¼Œ$y(t_0) = y_0$ï¼Œæ¬§æ‹‰æ–¹æ³•ä¸ºï¼š
$$y_{n+1} = y_n + h f(t_n, y_n)$$

**å®šç† 7.1.1** (æ¬§æ‹‰æ–¹æ³•çš„è¯¯å·® / Error of Euler's Method)
æ¬§æ‹‰æ–¹æ³•çš„å±€éƒ¨æˆªæ–­è¯¯å·®ä¸º $O(h^2)$ï¼Œå…¨å±€è¯¯å·®ä¸º $O(h)$ã€‚

**ç®—æ³• 7.1.1** (æ¬§æ‹‰æ–¹æ³•å®ç° / Euler's Method Implementation)

```python
def euler(f, t0, y0, h, n):
    t = [t0 + i*h for i in range(n+1)]
    y = [y0]

    for i in range(n):
        y_next = y[i] + h * f(t[i], y[i])
        y.append(y_next)

    return t, y
```

### 7.2 é¾™æ ¼-åº“å¡”æ–¹æ³• / Runge-Kutta Methods

**å®šä¹‰ 7.2.1** (å››é˜¶é¾™æ ¼-åº“å¡”æ–¹æ³• / Fourth Order Runge-Kutta Method)
$$y_{n+1} = y_n + \frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$
å…¶ä¸­ï¼š
$$k_1 = f(t_n, y_n)$$
$$k_2 = f(t_n + \frac{h}{2}, y_n + \frac{h}{2}k_1)$$
$$k_3 = f(t_n + \frac{h}{2}, y_n + \frac{h}{2}k_2)$$
$$k_4 = f(t_n + h, y_n + h k_3)$$

**å®šç† 7.2.1** (å››é˜¶é¾™æ ¼-åº“å¡”çš„ç²¾åº¦ / Accuracy of Fourth Order RK)
å››é˜¶é¾™æ ¼-åº“å¡”æ–¹æ³•çš„å±€éƒ¨æˆªæ–­è¯¯å·®ä¸º $O(h^5)$ã€‚

### 7.3 å¤šæ­¥æ–¹æ³• / Multistep Methods

**å®šä¹‰ 7.3.1** (äºšå½“æ–¯-å·´ä»€ç¦æ€æ–¹æ³• / Adams-Bashforth Method)
$$y_{n+1} = y_n + h \sum_{i=0}^k \beta_i f_{n-i}$$

**å®šä¹‰ 7.3.2** (äºšå½“æ–¯-è«å°”é¡¿æ–¹æ³• / Adams-Moulton Method)
$$y_{n+1} = y_n + h \sum_{i=0}^k \beta_i f_{n+1-i}$$

**å®šç† 7.3.1** (å¤šæ­¥æ–¹æ³•çš„ç¨³å®šæ€§ / Stability of Multistep Methods)
å¤šæ­¥æ–¹æ³•çš„ç¨³å®šæ€§ç”±ç‰¹å¾å¤šé¡¹å¼çš„æ ¹å†³å®šã€‚

---

## 8. å½¢å¼åŒ–å®ç° / Formal Implementation

### 8.1 Lean 4 å®ç° / Lean 4 Implementation

```lean
-- è¯¯å·®åˆ†æ
structure Error where
  absolute : â„
  relative : â„
  significantDigits : â„•

def absoluteError (exact approximate : â„) : â„ :=
  abs (exact - approximate)

def relativeError (exact approximate : â„) : â„ :=
  if exact â‰  0 then abs (exact - approximate) / abs exact else 0

def significantDigits (exact approximate : â„) : â„• :=
  if exact â‰  0 then
    let rel := relativeError exact approximate
    if rel â‰¤ 0.5 * 10^(-n + 1) then n else 0
  else 0

-- æ¡ä»¶æ•°
def conditionNumber (f : â„ â†’ â„) (x : â„) : â„ :=
  if f x â‰  0 then abs (x * derivative f x / f x) else 0

-- æ‹‰æ ¼æœ—æ—¥æ’å€¼
def lagrangeInterpolation (points : List (â„ Ã— â„)) (x : â„) : â„ :=
  let n := length points - 1
  sum (Î» i, (points[i].2 * lagrangeBasis i points x))
  where
    lagrangeBasis i points x :=
      product (Î» j, if i â‰  j then (x - points[j].1) / (points[i].1 - points[j].1) else 1)

-- ç‰›é¡¿æ’å€¼
def newtonInterpolation (points : List (â„ Ã— â„)) (x : â„) : â„ :=
  let dividedDifferences := computeDividedDifferences points
  sum (Î» i, dividedDifferences[i] * newtonBasis i points x)
  where
    newtonBasis i points x :=
      product (Î» j, if j < i then x - points[j].1 else 1)

-- æ•°å€¼ç§¯åˆ†
def trapezoidalRule (f : â„ â†’ â„) (a b : â„) (n : â„•) : â„ :=
  let h := (b - a) / n
  let points := [a + i * h | i â† range (n + 1)]
  h/2 * sum (Î» i, if i = 0 âˆ¨ i = n then f (points[i]) else 2 * f (points[i]))

def simpsonRule (f : â„ â†’ â„) (a b : â„) (n : â„•) : â„ :=
  let h := (b - a) / n
  let points := [a + i * h | i â† range (n + 1)]
  h/3 * sum (Î» i,
    if i = 0 âˆ¨ i = n then f (points[i])
    else if i % 2 = 1 then 4 * f (points[i])
    else 2 * f (points[i]))

-- é«˜æ–¯æ±‚ç§¯
def gaussianQuadrature (f : â„ â†’ â„) (n : â„•) : â„ :=
  let nodes := legendreZeros n
  let weights := legendreWeights n
  sum (Î» i, weights[i] * f nodes[i])

-- æ•°å€¼å¾®åˆ†
def forwardDifference (f : â„ â†’ â„) (x h : â„) : â„ :=
  (f (x + h) - f x) / h

def centralDifference (f : â„ â†’ â„) (x h : â„) : â„ :=
  (f (x + h) - f (x - h)) / (2 * h)

def secondDerivative (f : â„ â†’ â„) (x h : â„) : â„ :=
  (f (x + h) - 2 * f x + f (x - h)) / (h^2)

-- çº¿æ€§æ–¹ç¨‹ç»„
def gaussianElimination (A : Matrix â„ n n) (b : Vector â„ n) : Vector â„ n :=
  let A' := copy A
  let b' := copy b

  -- å‰å‘æ¶ˆå…ƒ
  for i in range n do
    for j in range (i+1, n) do
      let factor := A'[j,i] / A'[i,i]
      for k in range (i, n) do
        A'[j,k] := A'[j,k] - factor * A'[i,k]
      b'[j] := b'[j] - factor * b'[i]

  -- å›ä»£
  let x := zeroVector n
  for i in range (n-1, -1, -1) do
    x[i] := b'[i]
    for j in range (i+1, n) do
      x[i] := x[i] - A'[i,j] * x[j]
    x[i] := x[i] / A'[i,i]

  return x

-- éçº¿æ€§æ–¹ç¨‹
def newtonMethod (f f' : â„ â†’ â„) (x0 : â„) (tol : â„) (maxIter : â„•) : Option â„ :=
  let rec iterate x i :=
    if i â‰¥ maxIter then none
    else
      let fx := f x
      let dfx := f' x
      if abs dfx < 1e-10 then none
      else
        let xNew := x - fx / dfx
        if abs (xNew - x) < tol then some xNew
        else iterate xNew (i + 1)

  iterate x0 0

-- å¾®åˆ†æ–¹ç¨‹
def eulerMethod (f : â„ â†’ â„ â†’ â„) (t0 y0 : â„) (h : â„) (n : â„•) : List (â„ Ã— â„) :=
  let rec iterate t y i :=
    if i > n then []
    else (t, y) :: iterate (t + h) (y + h * f t y) (i + 1)

  iterate t0 y0 0

def rungeKutta4 (f : â„ â†’ â„ â†’ â„) (t0 y0 : â„) (h : â„) (n : â„•) : List (â„ Ã— â„) :=
  let rec iterate t y i :=
    if i > n then []
    else
      let k1 := f t y
      let k2 := f (t + h/2) (y + h/2 * k1)
      let k3 := f (t + h/2) (y + h/2 * k2)
      let k4 := f (t + h) (y + h * k3)
      let yNew := y + h/6 * (k1 + 2*k2 + 2*k3 + k4)
      (t, y) :: iterate (t + h) yNew (i + 1)

  iterate t0 y0 0

-- å®šç†éªŒè¯
theorem lagrange_uniqueness (points : List (â„ Ã— â„)) :
  length points > 0 â†’
  let n := length points - 1
  let p1 := lagrangeInterpolation points
  let p2 := lagrangeInterpolation points
  p1 = p2 :=
  by
  -- ä½¿ç”¨æ’å€¼å¤šé¡¹å¼çš„å”¯ä¸€æ€§
  sorry

theorem simpson_error (f : â„ â†’ â„) (a b : â„) (n : â„•) :
  let h := (b - a) / n
  let I := âˆ« f x dx from a to b
  let S := simpsonRule f a b n
  abs (I - S) â‰¤ (b - a) * h^4 * max_derivative_4 f a b / 180 :=
  by
  -- ä½¿ç”¨è¾›æ™®æ£®æ³•åˆ™çš„è¯¯å·®å…¬å¼
  sorry

theorem newton_convergence (f f' : â„ â†’ â„) (r : â„) :
  f r = 0 â†’ f' r â‰  0 â†’
  âˆƒ Î´ > 0, âˆ€ xâ‚€, abs (xâ‚€ - r) < Î´ â†’
  newtonMethod f f' xâ‚€ 1e-10 100 = some r :=
  by
  -- ä½¿ç”¨ç‰›é¡¿æ³•çš„æ”¶æ•›æ€§
  sorry
```

### 8.2 Haskell å®ç° / Haskell Implementation

```haskell
-- è¯¯å·®åˆ†æ
data Error = Error
  { absolute :: Double
  , relative :: Double
  , significantDigits :: Int
  }

absoluteError :: Double -> Double -> Double
absoluteError exact approximate = abs (exact - approximate)

relativeError :: Double -> Double -> Double
relativeError exact approximate =
  if exact /= 0 then abs (exact - approximate) / abs exact else 0

significantDigits :: Double -> Double -> Int
significantDigits exact approximate =
  if exact /= 0 then
    let rel = relativeError exact approximate
    in if rel <= 0.5 * 10^(-n + 1) then n else 0
  else 0

-- æ¡ä»¶æ•°
conditionNumber :: (Double -> Double) -> Double -> Double
conditionNumber f x =
  if f x /= 0 then abs (x * derivative f x / f x) else 0

-- æ‹‰æ ¼æœ—æ—¥æ’å€¼
lagrangeInterpolation :: [(Double, Double)] -> Double -> Double
lagrangeInterpolation points x =
  sum [y_i * lagrangeBasis i points x | (i, (x_i, y_i)) <- zip [0..] points]
  where
    lagrangeBasis i points x =
      product [if i /= j then (x - x_j) / (x_i - x_j) else 1
              | (j, (x_j, _)) <- zip [0..] points]

-- ç‰›é¡¿æ’å€¼
newtonInterpolation :: [(Double, Double)] -> Double -> Double
newtonInterpolation points x =
  let dividedDifferences = computeDividedDifferences points
  in sum [dividedDifferences !! i * newtonBasis i points x | i <- [0..length points - 1]]
  where
    newtonBasis i points x =
      product [if j < i then x - x_j else 1 | (j, (x_j, _)) <- zip [0..] points]

-- æ•°å€¼ç§¯åˆ†
trapezoidalRule :: (Double -> Double) -> Double -> Double -> Int -> Double
trapezoidalRule f a b n =
  let h = (b - a) / fromIntegral n
      points = [a + fromIntegral i * h | i <- [0..n]]
  in h/2 * sum [if i == 0 || i == n then f (points !! i) else 2 * f (points !! i) | i <- [0..n]]

simpsonRule :: (Double -> Double) -> Double -> Double -> Int -> Double
simpsonRule f a b n =
  let h = (b - a) / fromIntegral n
      points = [a + fromIntegral i * h | i <- [0..n]]
  in h/3 * sum [if i == 0 || i == n then f (points !! i)
                else if odd i then 4 * f (points !! i)
                else 2 * f (points !! i) | i <- [0..n]]

-- é«˜æ–¯æ±‚ç§¯
gaussianQuadrature :: (Double -> Double) -> Int -> Double
gaussianQuadrature f n =
  let nodes = legendreZeros n
      weights = legendreWeights n
  in sum [weights !! i * f (nodes !! i) | i <- [0..n-1]]

-- æ•°å€¼å¾®åˆ†
forwardDifference :: (Double -> Double) -> Double -> Double -> Double
forwardDifference f x h = (f (x + h) - f x) / h

centralDifference :: (Double -> Double) -> Double -> Double -> Double
centralDifference f x h = (f (x + h) - f (x - h)) / (2 * h)

secondDerivative :: (Double -> Double) -> Double -> Double -> Double
secondDerivative f x h = (f (x + h) - 2 * f x + f (x - h)) / (h^2)

-- çº¿æ€§æ–¹ç¨‹ç»„
gaussianElimination :: Matrix Double -> Vector Double -> Vector Double
gaussianElimination a b =
  let n = rows a
      a' = copy a
      b' = copy b

      -- å‰å‘æ¶ˆå…ƒ
      a'' = foldr (\i acc ->
        foldr (\j acc' ->
          let factor = acc' ! (j, i) / acc' ! (i, i)
          in foldr (\k acc'' ->
            acc'' // ((j, k), acc'' ! (j, k) - factor * acc'' ! (i, k))) acc' [i..n-1]
          ) acc [i+1..n-1]
        ) a' [0..n-2]

      b'' = foldr (\i acc ->
        foldr (\j acc' ->
          let factor = a'' ! (j, i) / a'' ! (i, i)
          in acc' // (j, acc' ! j - factor * acc' ! i)
          ) acc [i+1..n-1]
        ) b' [0..n-2]

      -- å›ä»£
      x = foldr (\i acc ->
        let x_i = (b'' ! i - sum [a'' ! (i, j) * acc ! j | j <- [i+1..n-1]]) / a'' ! (i, i)
        in acc // (i, x_i)
        ) (zeroVector n) [n-1, n-2..0]

  in x

-- éçº¿æ€§æ–¹ç¨‹
newtonMethod :: (Double -> Double) -> (Double -> Double) -> Double -> Double -> Int -> Maybe Double
newtonMethod f f' x0 tol maxIter =
  let iterate x i =
        if i >= maxIter then Nothing
        else
          let fx = f x
              dfx = f' x
          in if abs dfx < 1e-10 then Nothing
             else
               let xNew = x - fx / dfx
               in if abs (xNew - x) < tol then Just xNew
                  else iterate xNew (i + 1)
  in iterate x0 0

-- å¾®åˆ†æ–¹ç¨‹
eulerMethod :: (Double -> Double -> Double) -> Double -> Double -> Double -> Int -> [(Double, Double)]
eulerMethod f t0 y0 h n =
  let iterate t y i =
        if i > n then []
        else (t, y) : iterate (t + h) (y + h * f t y) (i + 1)
  in iterate t0 y0 0

rungeKutta4 :: (Double -> Double -> Double) -> Double -> Double -> Double -> Int -> [(Double, Double)]
rungeKutta4 f t0 y0 h n =
  let iterate t y i =
        if i > n then []
        else
          let k1 = f t y
              k2 = f (t + h/2) (y + h/2 * k1)
              k3 = f (t + h/2) (y + h/2 * k2)
              k4 = f (t + h) (y + h * k3)
              yNew = y + h/6 * (k1 + 2*k2 + 2*k3 + k4)
          in (t, y) : iterate (t + h) yNew (i + 1)
  in iterate t0 y0 0

-- å®šç†éªŒè¯
theorem_lagrange_uniqueness :: [(Double, Double)] -> Bool
theorem_lagrange_uniqueness points =
  length points > 0 ==>
  let p1 = lagrangeInterpolation points
      p2 = lagrangeInterpolation points
  in p1 == p2

theorem_simpson_error :: (Double -> Double) -> Double -> Double -> Int -> Bool
theorem_simpson_error f a b n =
  let h = (b - a) / fromIntegral n
      I = integrate f a b
      S = simpsonRule f a b n
      maxDeriv4 = maximum [abs (fourthDerivative f x) | x <- [a, a+h..b]]
  in abs (I - S) <= (b - a) * h^4 * maxDeriv4 / 180

theorem_newton_convergence :: (Double -> Double) -> (Double -> Double) -> Double -> Bool
theorem_newton_convergence f f' r =
  f r == 0 && f' r /= 0 ==>
  any (\x0 -> newtonMethod f f' x0 1e-10 100 == Just r) [r-0.1, r-0.05..r+0.1]

-- å®ä¾‹ï¼šæ•°å€¼å‡½æ•°
instance Num Double where
  (+) = (+)
  (-) = (-)
  (*) = (*)
  abs = abs
  signum = signum
  fromInteger = fromInteger

-- å®ä¾‹ï¼šçŸ©é˜µè¿ç®—
instance Num (Matrix Double) where
  (+) = matrixAdd
  (-) = matrixSub
  (*) = matrixMul
  abs = matrixAbs
  signum = matrixSignum
  fromInteger = matrixFromInteger
```

### 8.3 é‡è¦å®šç†æ€»ç»“ / Summary of Important Theorems

**å®šç† 8.3.1** (æ‹‰æ ¼æœ—æ—¥æ’å€¼çš„å”¯ä¸€æ€§ / Uniqueness of Lagrange Interpolation)
é€šè¿‡ $n+1$ ä¸ªä¸åŒç‚¹çš„ $n$ æ¬¡æ’å€¼å¤šé¡¹å¼æ˜¯å”¯ä¸€çš„ã€‚

**å®šç† 8.3.2** (è¾›æ™®æ£®æ³•åˆ™çš„è¯¯å·® / Error of Simpson's Rule)
$$\left|\int_a^b f(x) dx - S_n\right| \leq \frac{(b-a)h^4}{180} \max_{x \in [a,b]} |f^{(4)}(x)|$$

**å®šç† 8.3.3** (ç‰›é¡¿æ³•çš„æ”¶æ•›æ€§ / Convergence of Newton's Method)
å¦‚æœ $f'(r) \neq 0$ï¼Œåˆ™ç‰›é¡¿æ³•åœ¨ $r$ é™„è¿‘äºŒæ¬¡æ”¶æ•›ã€‚

**å®šç† 8.3.4** (å››é˜¶é¾™æ ¼-åº“å¡”çš„ç²¾åº¦ / Accuracy of Fourth Order RK)
å››é˜¶é¾™æ ¼-åº“å¡”æ–¹æ³•çš„å±€éƒ¨æˆªæ–­è¯¯å·®ä¸º $O(h^5)$ã€‚

---

## å‚è€ƒæ–‡çŒ® / References

1. Burden, R. L., & Faires, J. D. (2010). *Numerical Analysis* (9th ed.). Brooks/Cole.
2. Atkinson, K. E. (1989). *An Introduction to Numerical Analysis* (2nd ed.). Wiley.
3. Stoer, J., & Bulirsch, R. (2002). *Introduction to Numerical Analysis* (3rd ed.). Springer-Verlag.
4. Quarteroni, A., Sacco, R., & Saleri, F. (2007). *Numerical Mathematics* (2nd ed.). Springer-Verlag.

---

**ç›¸å…³é“¾æ¥** / Related Links:

- [è®¡ç®—å‡ ä½•](./02-è®¡ç®—å‡ ä½•.md)
- [ä¼˜åŒ–ç®—æ³•](./03-ä¼˜åŒ–ç®—æ³•.md)
- [å¹¶è¡Œè®¡ç®—](./04-å¹¶è¡Œè®¡ç®—.md)
- [ç¬¦å·è®¡ç®—](./05-ç¬¦å·è®¡ç®—.md)

## äº¤äº’ä¸è¡¥å……èµ„æº / Interactive & Supplementary Resources

### äº¤äº’å¼å›¾è¡¨å¢å¼º

- [æ•°å€¼æ–¹æ³•å¯è§†åŒ–](../äº¤äº’å¼å›¾è¡¨å¢å¼º-2025å¹´1æœˆ.md#æ•°å€¼æ–¹æ³•å¯è§†åŒ–å™¨)
- [æ”¶æ•›æ€§åˆ†æå·¥å…·](../äº¤äº’å¼å›¾è¡¨å¢å¼º-2025å¹´1æœˆ.md#æ”¶æ•›æ€§åˆ†æå™¨)
- [è¯¯å·®åˆ†æå¯è§†åŒ–](../äº¤äº’å¼å›¾è¡¨å¢å¼º-2025å¹´1æœˆ.md#è¯¯å·®åˆ†æå™¨)

### å®šç†è¯æ˜è¡¥å……

- [æ‹‰æ ¼æœ—æ—¥æ’å€¼å”¯ä¸€æ€§å®šç†](../å®šç†è¯æ˜è¡¥å……-2025å¹´1æœˆ.md#æ‹‰æ ¼æœ—æ—¥æ’å€¼å”¯ä¸€æ€§å®šç†)
- [ç‰›é¡¿æ³•æ”¶æ•›æ€§å®šç†](../å®šç†è¯æ˜è¡¥å……-2025å¹´1æœˆ.md#ç‰›é¡¿æ³•æ”¶æ•›æ€§å®šç†)
- [è¾›æ™®æ£®æ³•åˆ™è¯¯å·®å®šç†](../å®šç†è¯æ˜è¡¥å……-2025å¹´1æœˆ.md#è¾›æ™®æ£®æ³•åˆ™è¯¯å·®å®šç†)

### åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……

- [æ•°å€¼ä¸ç¨³å®šæ€§åä¾‹](../åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……-2025å¹´1æœˆ.md#æ•°å€¼ä¸ç¨³å®šæ€§åä¾‹)
- [ç—…æ€é—®é¢˜å®ä¾‹](../åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……-2025å¹´1æœˆ.md#ç—…æ€é—®é¢˜å®ä¾‹)
- [æ”¶æ•›å¤±è´¥æ¡ˆä¾‹](../åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……-2025å¹´1æœˆ.md#æ”¶æ•›å¤±è´¥æ¡ˆä¾‹)

### å†å²èƒŒæ™¯è¡¥å……

- [æ•°å€¼åˆ†æå‘å±•å²](../å†å²èƒŒæ™¯è¡¥å……-2025å¹´1æœˆ.md#æ•°å€¼åˆ†æå‘å±•å²)
- [é‡è¦æ•°å­¦å®¶è´¡çŒ®](../å†å²èƒŒæ™¯è¡¥å……-2025å¹´1æœˆ.md#æ•°å€¼åˆ†æé‡è¦äººç‰©)
- [è®¡ç®—æœºæ—¶ä»£å½±å“](../å†å²èƒŒæ™¯è¡¥å……-2025å¹´1æœˆ.md#è®¡ç®—æœºæ—¶ä»£æ•°å€¼åˆ†æ)
