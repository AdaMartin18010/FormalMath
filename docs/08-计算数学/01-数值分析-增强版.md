# æ•°å€¼åˆ†æ - å¢å¼ºç‰ˆ

## ç›®å½•

- [æ•°å€¼åˆ†æ - å¢å¼ºç‰ˆ](#æ•°å€¼åˆ†æ---å¢å¼ºç‰ˆ)
  - [ç›®å½•](#ç›®å½•)
  - [ğŸ“š æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ•°ï¸ å†å²å‘å±•è„‰ç»œ](#ï¸-å†å²å‘å±•è„‰ç»œ)
    - [å¤ä»£å‘å±• (å…¬å…ƒå‰300å¹´-å…¬å…ƒ1500å¹´)](#å¤ä»£å‘å±•-å…¬å…ƒå‰300å¹´-å…¬å…ƒ1500å¹´)
      - [å¤å¸Œè…Šæ—¶æœŸ](#å¤å¸Œè…Šæ—¶æœŸ)
    - [è¿‘ä»£å‘å±• (1500-1900)](#è¿‘ä»£å‘å±•-1500-1900)
      - [ç‰›é¡¿æ—¶ä»£](#ç‰›é¡¿æ—¶ä»£)
      - [æ¬§æ‹‰æ—¶ä»£](#æ¬§æ‹‰æ—¶ä»£)
    - [ç°ä»£å‘å±• (1900-è‡³ä»Š)](#ç°ä»£å‘å±•-1900-è‡³ä»Š)
      - [è®¡ç®—æœºæ—¶ä»£](#è®¡ç®—æœºæ—¶ä»£)
      - [å½“ä»£å‘å±•](#å½“ä»£å‘å±•)
  - [ğŸ“Š é‡è¦äººç‰©è´¡çŒ®è¡¨](#-é‡è¦äººç‰©è´¡çŒ®è¡¨)
  - [ğŸ” å®ä¾‹è¡¨å¾](#-å®ä¾‹è¡¨å¾)
    - [1. ç»å…¸æ•°å€¼åˆ†æå®ä¾‹](#1-ç»å…¸æ•°å€¼åˆ†æå®ä¾‹)
      - [æ‹‰æ ¼æœ—æ—¥æ’å€¼å®ä¾‹](#æ‹‰æ ¼æœ—æ—¥æ’å€¼å®ä¾‹)
      - [é«˜æ–¯æ±‚ç§¯å®ä¾‹](#é«˜æ–¯æ±‚ç§¯å®ä¾‹)
      - [ç‰›é¡¿æ³•å®ä¾‹](#ç‰›é¡¿æ³•å®ä¾‹)
    - [2. åº”ç”¨å®ä¾‹](#2-åº”ç”¨å®ä¾‹)
      - [ç§‘å­¦è®¡ç®—åº”ç”¨](#ç§‘å­¦è®¡ç®—åº”ç”¨)
      - [é‡‘èè®¡ç®—åº”ç”¨](#é‡‘èè®¡ç®—åº”ç”¨)
  - [ğŸ§  æ€ç»´è¿‡ç¨‹è¡¨å¾](#-æ€ç»´è¿‡ç¨‹è¡¨å¾)
    - [1. æ•°å€¼åˆ†æé—®é¢˜è§£å†³æµç¨‹](#1-æ•°å€¼åˆ†æé—®é¢˜è§£å†³æµç¨‹)
      - [æ­¥éª¤1ï¼šé—®é¢˜åˆ†æ](#æ­¥éª¤1é—®é¢˜åˆ†æ)
      - [æ­¥éª¤2ï¼šç®—æ³•è®¾è®¡](#æ­¥éª¤2ç®—æ³•è®¾è®¡)
      - [æ­¥éª¤3ï¼šç»“æœéªŒè¯](#æ­¥éª¤3ç»“æœéªŒè¯)
    - [2. è¯æ˜æ€ç»´è¿‡ç¨‹](#2-è¯æ˜æ€ç»´è¿‡ç¨‹)
      - [æ‹‰æ ¼æœ—æ—¥æ’å€¼å”¯ä¸€æ€§è¯æ˜](#æ‹‰æ ¼æœ—æ—¥æ’å€¼å”¯ä¸€æ€§è¯æ˜)
      - [ç‰›é¡¿æ³•æ”¶æ•›æ€§è¯æ˜](#ç‰›é¡¿æ³•æ”¶æ•›æ€§è¯æ˜)
    - [3. æ¦‚å¿µç†è§£æ­¥éª¤](#3-æ¦‚å¿µç†è§£æ­¥éª¤)
      - [ç†è§£æ•°å€¼ç¨³å®šæ€§](#ç†è§£æ•°å€¼ç¨³å®šæ€§)
    - [4. é—®é¢˜è§£å†³ç­–ç•¥](#4-é—®é¢˜è§£å†³ç­–ç•¥)
      - [æ•°å€¼åˆ†æé—®é¢˜åˆ†ç±»](#æ•°å€¼åˆ†æé—®é¢˜åˆ†ç±»)
      - [å¸¸è§æ€ç»´è¯¯åŒº](#å¸¸è§æ€ç»´è¯¯åŒº)
    - [5. ç®—æ³•æ€ç»´åˆ†æ](#5-ç®—æ³•æ€ç»´åˆ†æ)
      - [æ•°å€¼åˆ†æç®—æ³•è®¾è®¡](#æ•°å€¼åˆ†æç®—æ³•è®¾è®¡)
  - [ğŸ”§ æŠ€æœ¯å®ç°è¡¨å¾](#-æŠ€æœ¯å®ç°è¡¨å¾)
    - [1. Lean 4 å½¢å¼åŒ–å®ç°](#1-lean-4-å½¢å¼åŒ–å®ç°)
    - [2. Haskell å‡½æ•°å¼å®ç°](#2-haskell-å‡½æ•°å¼å®ç°)
    - [3. Python ç®—æ³•å®ç°](#3-python-ç®—æ³•å®ç°)
  - [ğŸ“ˆ åº”ç”¨åœºæ™¯](#-åº”ç”¨åœºæ™¯)
    - [1. ç§‘å­¦è®¡ç®—åº”ç”¨](#1-ç§‘å­¦è®¡ç®—åº”ç”¨)
      - [å¾®åˆ†æ–¹ç¨‹æ±‚è§£](#å¾®åˆ†æ–¹ç¨‹æ±‚è§£)
    - [2. å·¥ç¨‹è®¡ç®—åº”ç”¨](#2-å·¥ç¨‹è®¡ç®—åº”ç”¨)
      - [æœ‰é™å…ƒæ–¹æ³•](#æœ‰é™å…ƒæ–¹æ³•)
    - [3. é‡‘èè®¡ç®—åº”ç”¨](#3-é‡‘èè®¡ç®—åº”ç”¨)
      - [è’™ç‰¹å¡æ´›æ–¹æ³•](#è’™ç‰¹å¡æ´›æ–¹æ³•)
  - [ğŸ“Š æ€»ç»“ä¸å±•æœ›](#-æ€»ç»“ä¸å±•æœ›)
    - [ä¸»è¦æˆå°±](#ä¸»è¦æˆå°±)
    - [å‘å±•ç°çŠ¶](#å‘å±•ç°çŠ¶)
    - [æœªæ¥æ–¹å‘](#æœªæ¥æ–¹å‘)
  - [äº¤äº’ä¸è¡¥å……èµ„æº / Interactive \& Supplementary Resources](#äº¤äº’ä¸è¡¥å……èµ„æº--interactive--supplementary-resources)
    - [äº¤äº’å¼å›¾è¡¨å¢å¼º](#äº¤äº’å¼å›¾è¡¨å¢å¼º)
    - [å®šç†è¯æ˜è¡¥å……](#å®šç†è¯æ˜è¡¥å……)
    - [åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……](#åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……)
    - [å†å²èƒŒæ™¯è¡¥å……](#å†å²èƒŒæ™¯è¡¥å……)

## ğŸ“š æ¦‚è¿°

æ•°å€¼åˆ†ææ˜¯ç ”ç©¶ç”¨æ•°å€¼æ–¹æ³•è§£å†³æ•°å­¦é—®é¢˜çš„å­¦ç§‘ï¼ŒåŒ…æ‹¬æ’å€¼ã€ç§¯åˆ†ã€å¾®åˆ†ã€æ–¹ç¨‹æ±‚è§£ç­‰ã€‚
å®ƒæ˜¯ç§‘å­¦è®¡ç®—çš„åŸºç¡€ï¼Œåœ¨å·¥ç¨‹ã€ç‰©ç†ã€é‡‘èç­‰é¢†åŸŸæœ‰å¹¿æ³›åº”ç”¨ã€‚

## ğŸ•°ï¸ å†å²å‘å±•è„‰ç»œ

### å¤ä»£å‘å±• (å…¬å…ƒå‰300å¹´-å…¬å…ƒ1500å¹´)

#### å¤å¸Œè…Šæ—¶æœŸ

```mermaid
timeline
    title æ•°å€¼åˆ†æå¤ä»£å‘å±•
    å…¬å…ƒå‰300å¹´ : æ¬§å‡ é‡Œå¾—ç®—æ³•
    å…¬å…ƒå‰250å¹´ : é˜¿åŸºç±³å¾·æ±‚Ï€
    å…¬å…ƒ100å¹´ : æ‰˜å‹’å¯†å¤©æ–‡è®¡ç®—
    å…¬å…ƒ500å¹´ : å°åº¦æ•°å­—ç³»ç»Ÿ
    å…¬å…ƒ1200å¹´ : æ–æ³¢é‚£å¥‘æ•°åˆ—
```

- **å…¬å…ƒå‰300å¹´**: æ¬§å‡ é‡Œå¾—ç®—æ³•å¥ å®šæ•°å€¼è®¡ç®—åŸºç¡€
  - æœ€å¤§å…¬çº¦æ•°çš„é«˜æ•ˆç®—æ³•
  - ä¸ºç°ä»£æ•°å€¼åˆ†æå¥ å®šåŸºç¡€
  - å½±å“ç®—æ³•è®¾è®¡æ•°åƒå¹´
- **å…¬å…ƒå‰250å¹´**: é˜¿åŸºç±³å¾·ç”¨å‡ ä½•æ–¹æ³•æ±‚Ï€
  - ä½¿ç”¨å¤šè¾¹å½¢é€¼è¿‘åœ†
  - å»ºç«‹æ•°å€¼é€¼è¿‘çš„åŸºæœ¬æ€æƒ³
  - ä¸ºæ•°å€¼ç§¯åˆ†å¥ å®šåŸºç¡€
- **å…¬å…ƒ100å¹´**: æ‰˜å‹’å¯†è¿›è¡Œå¤©æ–‡æ•°å€¼è®¡ç®—
  - å»ºç«‹ä¸‰è§’å‡½æ•°è¡¨
  - å‘å±•æ’å€¼æ–¹æ³•
  - ä¸ºæ•°å€¼åˆ†ææä¾›åº”ç”¨åœºæ™¯

### è¿‘ä»£å‘å±• (1500-1900)

#### ç‰›é¡¿æ—¶ä»£

- **1665å¹´**: ç‰›é¡¿å‘æ˜å¾®ç§¯åˆ†
  - å»ºç«‹å¾®åˆ†å’Œç§¯åˆ†ç†è®º
  - ä¸ºæ•°å€¼åˆ†ææä¾›ç†è®ºåŸºç¡€
  - å‘å±•ç‰›é¡¿æ’å€¼æ³•
- **1687å¹´**: ç‰›é¡¿ã€Šè‡ªç„¶å“²å­¦çš„æ•°å­¦åŸç†ã€‹
  - å»ºç«‹åŠ›å­¦æ•°å€¼æ–¹æ³•
  - å‘å±•å¾®åˆ†æ–¹ç¨‹æ•°å€¼è§£
  - å½±å“ç§‘å­¦è®¡ç®—å‘å±•

#### æ¬§æ‹‰æ—¶ä»£

- **1736å¹´**: æ¬§æ‹‰ç ”ç©¶æ•°å€¼æ–¹æ³•
  - å‘å±•æ¬§æ‹‰æ–¹æ³•è§£å¾®åˆ†æ–¹ç¨‹
  - å»ºç«‹æ•°å€¼ç§¯åˆ†ç†è®º
  - ä¸ºç°ä»£æ•°å€¼åˆ†æå¥ å®šåŸºç¡€
- **1748å¹´**: æ¬§æ‹‰ç ”ç©¶çº§æ•°
  - å»ºç«‹æ³°å‹’çº§æ•°ç†è®º
  - ä¸ºå‡½æ•°é€¼è¿‘æä¾›å·¥å…·
  - å½±å“æ•°å€¼åˆ†æå‘å±•

### ç°ä»£å‘å±• (1900-è‡³ä»Š)

#### è®¡ç®—æœºæ—¶ä»£

- **1940å¹´ä»£**: å†¯Â·è¯ºä¾æ›¼å»ºç«‹æ•°å€¼åˆ†æ
  - å»ºç«‹ç°ä»£æ•°å€¼åˆ†æç†è®º
  - å‘å±•ç¨³å®šæ€§ç†è®º
  - ä¸ºç§‘å­¦è®¡ç®—å¥ å®šåŸºç¡€
- **1950å¹´ä»£**: æ•°å€¼åˆ†æå¿«é€Ÿå‘å±•
  - å‘å±•æœ‰é™å·®åˆ†æ–¹æ³•
  - å»ºç«‹æœ‰é™å…ƒæ–¹æ³•
  - ä¸ºå·¥ç¨‹è®¡ç®—æä¾›å·¥å…·

#### å½“ä»£å‘å±•

- **1970å¹´ä»£**: è‡ªé€‚åº”æ–¹æ³•å…´èµ·
  - å‘å±•è‡ªé€‚åº”ç§¯åˆ†
  - å»ºç«‹è‡ªé€‚åº”ç½‘æ ¼
  - æé«˜è®¡ç®—æ•ˆç‡
- **1990å¹´ä»£**: å¹¶è¡Œè®¡ç®—å‘å±•
  - å‘å±•å¹¶è¡Œç®—æ³•
  - å»ºç«‹åˆ†å¸ƒå¼è®¡ç®—
  - å¤„ç†å¤§è§„æ¨¡é—®é¢˜

## ğŸ“Š é‡è¦äººç‰©è´¡çŒ®è¡¨

| äººç‰© | æ—¶æœŸ | ä¸»è¦è´¡çŒ® | å½±å“ |
|------|------|----------|------|
| æ¬§å‡ é‡Œå¾— | å…¬å…ƒå‰300å¹´ | æ¬§å‡ é‡Œå¾—ç®—æ³• | å¥ å®šç®—æ³•åŸºç¡€ |
| é˜¿åŸºç±³å¾· | å…¬å…ƒå‰250å¹´ | æ•°å€¼é€¼è¿‘æ–¹æ³• | å»ºç«‹é€¼è¿‘ç†è®º |
| ç‰›é¡¿ | 17ä¸–çºª | å¾®ç§¯åˆ†ã€æ’å€¼æ³• | å»ºç«‹ç†è®ºåŸºç¡€ |
| æ¬§æ‹‰ | 18ä¸–çºª | æ¬§æ‹‰æ–¹æ³•ã€æ•°å€¼ç§¯åˆ† | å‘å±•æ•°å€¼æ–¹æ³• |
| é«˜æ–¯ | 19ä¸–çºª | é«˜æ–¯æ±‚ç§¯ã€æœ€å°äºŒä¹˜ | å®Œå–„æ•°å€¼ç†è®º |
| å†¯Â·è¯ºä¾æ›¼ | 20ä¸–çºª | ç°ä»£æ•°å€¼åˆ†æ | å»ºç«‹å­¦ç§‘ä½“ç³» |

## ğŸ” å®ä¾‹è¡¨å¾

### 1. ç»å…¸æ•°å€¼åˆ†æå®ä¾‹

#### æ‹‰æ ¼æœ—æ—¥æ’å€¼å®ä¾‹

```haskell
-- Haskell å®ç°
lagrangeInterpolation :: [(Double, Double)] -> Double -> Double
lagrangeInterpolation points x = sum [y * lagrangeBasis i points x | (i, (_, y)) <- zip [0..] points]

lagrangeBasis :: Int -> [(Double, Double)] -> Double -> Double
lagrangeBasis i points x = product [if j == i then 1 else (x - xj) / (xi - xj) | (j, (xj, _)) <- zip [0..] points]
  where xi = fst (points !! i)

-- å®ä¾‹ï¼šæ’å€¼ç‚¹ (0,1), (1,2), (2,4)
points = [(0, 1), (1, 2), (2, 4)]
interpolated = lagrangeInterpolation points 0.5
```

#### é«˜æ–¯æ±‚ç§¯å®ä¾‹

```rust
// Rust å®ç°
struct GaussianQuadrature {
    weights: Vec<f64>,
    nodes: Vec<f64>,
}

impl GaussianQuadrature {
    fn new(n: usize) -> Self {
        // ç”Ÿæˆnç‚¹é«˜æ–¯-å‹’è®©å¾·æ±‚ç§¯å…¬å¼
        let (nodes, weights) = Self::gauss_legendre(n);
        Self { weights, nodes }
    }
    
    fn integrate<F>(&self, f: F, a: f64, b: f64) -> f64 
    where F: Fn(f64) -> f64 {
        let scale = (b - a) / 2.0;
        let shift = (a + b) / 2.0;
        
        self.weights.iter()
            .zip(&self.nodes)
            .map(|(w, x)| w * f(scale * x + shift))
            .sum::<f64>() * scale
    }
    
    fn gauss_legendre(n: usize) -> (Vec<f64>, Vec<f64>) {
        // ç®€åŒ–çš„é«˜æ–¯-å‹’è®©å¾·èŠ‚ç‚¹å’Œæƒé‡è®¡ç®—
        match n {
            2 => (vec![-0.5773502691896257, 0.5773502691896257], 
                  vec![1.0, 1.0]),
            3 => (vec![-0.7745966692414834, 0.0, 0.7745966692414834],
                  vec![0.5555555555555556, 0.8888888888888888, 0.5555555555555556]),
            _ => panic!("Unsupported number of points")
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹
let quad = GaussianQuadrature::new(3);
let result = quad.integrate(|x| x * x, 0.0, 1.0);
println!("Integral of x^2 from 0 to 1: {}", result);
```

#### ç‰›é¡¿æ³•å®ä¾‹

```python
# Python å®ç°
import numpy as np

def newton_method(f, df, x0, tol=1e-6, max_iter=100):
    """ç‰›é¡¿æ³•æ±‚è§£éçº¿æ€§æ–¹ç¨‹"""
    x = x0
    for i in range(max_iter):
        fx = f(x)
        if abs(fx) < tol:
            return x, i + 1
        
        dfx = df(x)
        if abs(dfx) < 1e-10:
            raise ValueError("å¯¼æ•°ä¸ºé›¶ï¼Œç‰›é¡¿æ³•å¤±è´¥")
        
        x_new = x - fx / dfx
        if abs(x_new - x) < tol:
            return x_new, i + 1
        
        x = x_new
    
    raise ValueError("ç‰›é¡¿æ³•æœªæ”¶æ•›")

# ä½¿ç”¨ç¤ºä¾‹ï¼šæ±‚è§£ x^2 - 4 = 0
f = lambda x: x**2 - 4
df = lambda x: 2*x

root, iterations = newton_method(f, df, 1.0)
print(f"æ ¹: {root}, è¿­ä»£æ¬¡æ•°: {iterations}")
```

### 2. åº”ç”¨å®ä¾‹

#### ç§‘å­¦è®¡ç®—åº”ç”¨

```python
# Python å®ç° - å¸¸å¾®åˆ†æ–¹ç¨‹æ±‚è§£
import numpy as np
import matplotlib.pyplot as plt

class RungeKutta4:
    """å››é˜¶é¾™æ ¼-åº“å¡”æ–¹æ³•"""
    
    def __init__(self, f, t0, y0, h):
        self.f = f
        self.t = t0
        self.y = y0
        self.h = h
    
    def step(self):
        """æ‰§è¡Œä¸€æ­¥é¾™æ ¼-åº“å¡”æ–¹æ³•"""
        k1 = self.f(self.t, self.y)
        k2 = self.f(self.t + self.h/2, self.y + self.h*k1/2)
        k3 = self.f(self.t + self.h/2, self.y + self.h*k2/2)
        k4 = self.f(self.t + self.h, self.y + self.h*k3)
        
        self.y += self.h * (k1 + 2*k2 + 2*k3 + k4) / 6
        self.t += self.h
        return self.t, self.y
    
    def solve(self, t_end):
        """æ±‚è§£åˆ°æŒ‡å®šæ—¶é—´"""
        times = [self.t]
        values = [self.y]
        
        while self.t < t_end:
            t, y = self.step()
            times.append(t)
            values.append(y)
        
        return np.array(times), np.array(values)

# ä½¿ç”¨ç¤ºä¾‹ï¼šæ±‚è§£ y' = -y, y(0) = 1
def f(t, y):
    return -y

solver = RungeKutta4(f, 0, 1, 0.1)
times, values = solver.solve(5)

# ç»˜åˆ¶ç»“æœ
plt.plot(times, values, 'b-', label='Numerical')
plt.plot(times, np.exp(-times), 'r--', label='Exact')
plt.xlabel('Time')
plt.ylabel('y(t)')
plt.legend()
plt.grid(True)
plt.show()
```

#### é‡‘èè®¡ç®—åº”ç”¨

```python
# Python å®ç° - æœŸæƒå®šä»·
import numpy as np
from scipy.stats import norm

class BlackScholes:
    """å¸ƒè±å…‹-æ–¯ç§‘å°”æ–¯æœŸæƒå®šä»·æ¨¡å‹"""
    
    @staticmethod
    def call_price(S, K, T, r, sigma):
        """è®¡ç®—çœ‹æ¶¨æœŸæƒä»·æ ¼"""
        d1 = (np.log(S/K) + (r + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))
        d2 = d1 - sigma*np.sqrt(T)
        
        return S*norm.cdf(d1) - K*np.exp(-r*T)*norm.cdf(d2)
    
    @staticmethod
    def put_price(S, K, T, r, sigma):
        """è®¡ç®—çœ‹è·ŒæœŸæƒä»·æ ¼"""
        d1 = (np.log(S/K) + (r + 0.5*sigma**2)*T) / (sigma*np.sqrt(T))
        d2 = d1 - sigma*np.sqrt(T)
        
        return K*np.exp(-r*T)*norm.cdf(-d2) - S*norm.cdf(-d1)
    
    @staticmethod
    def implied_volatility(price, S, K, T, r, option_type='call'):
        """è®¡ç®—éšå«æ³¢åŠ¨ç‡"""
        def objective(sigma):
            if option_type == 'call':
                return BlackScholes.call_price(S, K, T, r, sigma) - price
            else:
                return BlackScholes.put_price(S, K, T, r, sigma) - price
        
        # ä½¿ç”¨ç‰›é¡¿æ³•æ±‚è§£
        sigma = 0.3  # åˆå§‹çŒœæµ‹
        for _ in range(100):
            f_val = objective(sigma)
            if abs(f_val) < 1e-6:
                return sigma
            
            # æ•°å€¼å¾®åˆ†
            h = 1e-6
            df_val = (objective(sigma + h) - objective(sigma - h)) / (2*h)
            sigma = sigma - f_val / df_val
        
        return sigma

# ä½¿ç”¨ç¤ºä¾‹
S = 100  # å½“å‰è‚¡ä»·
K = 100  # æ‰§è¡Œä»·æ ¼
T = 1.0  # åˆ°æœŸæ—¶é—´
r = 0.05  # æ— é£é™©åˆ©ç‡
sigma = 0.2  # æ³¢åŠ¨ç‡

call_price = BlackScholes.call_price(S, K, T, r, sigma)
put_price = BlackScholes.put_price(S, K, T, r, sigma)

print(f"çœ‹æ¶¨æœŸæƒä»·æ ¼: {call_price:.4f}")
print(f"çœ‹è·ŒæœŸæƒä»·æ ¼: {put_price:.4f}")

# è®¡ç®—éšå«æ³¢åŠ¨ç‡
implied_vol = BlackScholes.implied_volatility(call_price, S, K, T, r, 'call')
print(f"éšå«æ³¢åŠ¨ç‡: {implied_vol:.4f}")
```

## ğŸ§  æ€ç»´è¿‡ç¨‹è¡¨å¾

### 1. æ•°å€¼åˆ†æé—®é¢˜è§£å†³æµç¨‹

#### æ­¥éª¤1ï¼šé—®é¢˜åˆ†æ

```text
é—®é¢˜ â†’ è¯†åˆ«æ•°å€¼ç±»å‹ â†’ ç¡®å®šæ±‚è§£ç­–ç•¥ â†’ é€‰æ‹©åˆé€‚ç®—æ³•
```

**å…·ä½“æ€ç»´è¿‡ç¨‹**ï¼š

1. **è¯†åˆ«æ•°å€¼ç±»å‹**ï¼šæ’å€¼é—®é¢˜ã€ç§¯åˆ†é—®é¢˜ã€å¾®åˆ†é—®é¢˜ã€æ–¹ç¨‹æ±‚è§£
2. **ç¡®å®šæ±‚è§£ç­–ç•¥**ï¼šç›´æ¥è®¡ç®—ã€è¿­ä»£æ–¹æ³•ã€é€¼è¿‘æ–¹æ³•
3. **é€‰æ‹©åˆé€‚ç®—æ³•**ï¼šæ ¹æ®ç²¾åº¦è¦æ±‚ã€è®¡ç®—å¤æ‚åº¦ã€ç¨³å®šæ€§é€‰æ‹©

#### æ­¥éª¤2ï¼šç®—æ³•è®¾è®¡

```text
ç®—æ³•é€‰æ‹© â†’ å‚æ•°è®¾ç½® â†’ è¯¯å·®åˆ†æ â†’ ç¨³å®šæ€§æ£€æŸ¥
```

**å…·ä½“æ€ç»´è¿‡ç¨‹**ï¼š

1. **ç®—æ³•é€‰æ‹©**ï¼šæ ¹æ®é—®é¢˜ç‰¹ç‚¹é€‰æ‹©åˆé€‚ç®—æ³•
2. **å‚æ•°è®¾ç½®**ï¼šè®¾ç½®æ­¥é•¿ã€ç²¾åº¦ã€è¿­ä»£æ¬¡æ•°ç­‰å‚æ•°
3. **è¯¯å·®åˆ†æ**ï¼šåˆ†ææˆªæ–­è¯¯å·®ã€èˆå…¥è¯¯å·®
4. **ç¨³å®šæ€§æ£€æŸ¥**ï¼šç¡®ä¿ç®—æ³•æ•°å€¼ç¨³å®š

#### æ­¥éª¤3ï¼šç»“æœéªŒè¯

```text
æ•°å€¼ç»“æœ â†’ ç†è®ºéªŒè¯ â†’ å®ä¾‹éªŒè¯ â†’ è¯¯å·®ä¼°è®¡
```

**å…·ä½“æ€ç»´è¿‡ç¨‹**ï¼š

1. **æ•°å€¼ç»“æœ**ï¼šè·å¾—æ•°å€¼è§£
2. **ç†è®ºéªŒè¯**ï¼šä¸ç†è®ºç»“æœæ¯”è¾ƒ
3. **å®ä¾‹éªŒè¯**ï¼šç”¨å·²çŸ¥å®ä¾‹éªŒè¯
4. **è¯¯å·®ä¼°è®¡**ï¼šä¼°è®¡è®¡ç®—è¯¯å·®

### 2. è¯æ˜æ€ç»´è¿‡ç¨‹

#### æ‹‰æ ¼æœ—æ—¥æ’å€¼å”¯ä¸€æ€§è¯æ˜

```text
1. æ„é€ æ‹‰æ ¼æœ—æ—¥åŸºå‡½æ•°
2. è¯æ˜æ’å€¼æ€§è´¨
3. è¯æ˜å”¯ä¸€æ€§
4. åˆ†æè¯¯å·®
```

**è¯¦ç»†è¯æ˜æ­¥éª¤**ï¼š

**æ­¥éª¤1ï¼šæ„é€ æ‹‰æ ¼æœ—æ—¥åŸºå‡½æ•°**:

- å®šä¹‰ $\ell_i(x) = \prod_{j \neq i} \frac{x - x_j}{x_i - x_j}$
- è¯æ˜ $\ell_i(x_j) = \delta_{ij}$

**æ­¥éª¤2ï¼šè¯æ˜æ’å€¼æ€§è´¨**:

- æ„é€  $L_n(x) = \sum_{i=0}^n y_i \ell_i(x)$
- è¯æ˜ $L_n(x_i) = y_i$

**æ­¥éª¤3ï¼šè¯æ˜å”¯ä¸€æ€§**:

- å‡è®¾å­˜åœ¨ä¸¤ä¸ªä¸åŒçš„æ’å€¼å¤šé¡¹å¼
- è¯æ˜å®ƒä»¬çš„å·®ä¸ºé›¶å¤šé¡¹å¼
- å¾—å‡ºå”¯ä¸€æ€§ç»“è®º

**æ­¥éª¤4ï¼šåˆ†æè¯¯å·®**:

- ä½¿ç”¨ç½—å°”å®šç†
- å¾—åˆ°è¯¯å·®ä¼°è®¡å…¬å¼

#### ç‰›é¡¿æ³•æ”¶æ•›æ€§è¯æ˜

```text
1. æ³°å‹’å±•å¼€
2. æ„é€ è¿­ä»£æ ¼å¼
3. åˆ†ææ”¶æ•›æ¡ä»¶
4. ä¼°è®¡æ”¶æ•›é˜¶
```

**è¯¦ç»†è¯æ˜æ­¥éª¤**ï¼š

**æ­¥éª¤1ï¼šæ³°å‹’å±•å¼€**:

- åœ¨æ ¹é™„è¿‘è¿›è¡Œæ³°å‹’å±•å¼€
- å¾—åˆ°çº¿æ€§è¿‘ä¼¼

**æ­¥éª¤2ï¼šæ„é€ è¿­ä»£æ ¼å¼**:

- åŸºäºçº¿æ€§è¿‘ä¼¼æ„é€ è¿­ä»£
- å¾—åˆ°ç‰›é¡¿è¿­ä»£å…¬å¼

**æ­¥éª¤3ï¼šåˆ†ææ”¶æ•›æ¡ä»¶**:

- åˆ†æè¿­ä»£åºåˆ—çš„æ”¶æ•›æ€§
- å¾—åˆ°æ”¶æ•›çš„å……åˆ†æ¡ä»¶

**æ­¥éª¤4ï¼šä¼°è®¡æ”¶æ•›é˜¶**:

- åˆ†æè¯¯å·®çš„è¡°å‡é€Ÿåº¦
- è¯æ˜äºŒæ¬¡æ”¶æ•›æ€§

### 3. æ¦‚å¿µç†è§£æ­¥éª¤

#### ç†è§£æ•°å€¼ç¨³å®šæ€§

```text
1. è¯¯å·®æ¥æº
2. è¯¯å·®ä¼ æ’­
3. ç¨³å®šæ€§å®šä¹‰
4. ç¨³å®šæ€§åˆ†æ
```

**å…·ä½“ç†è§£è¿‡ç¨‹**ï¼š

**é˜¶æ®µ1ï¼šè¯¯å·®æ¥æº**:

- ç†è§£æˆªæ–­è¯¯å·®å’Œèˆå…¥è¯¯å·®
- æŒæ¡è¯¯å·®çš„åŸºæœ¬æ€§è´¨
- ç†è§£è¯¯å·®çš„æ¥æº

**é˜¶æ®µ2ï¼šè¯¯å·®ä¼ æ’­**:

- ç†è§£è¯¯å·®å¦‚ä½•ä¼ æ’­
- æŒæ¡è¯¯å·®ä¼ æ’­çš„è§„å¾‹
- ç†è§£è¯¯å·®ç´¯ç§¯æ•ˆåº”

**é˜¶æ®µ3ï¼šç¨³å®šæ€§å®šä¹‰**:

- ç†è§£æ•°å€¼ç¨³å®šæ€§çš„å®šä¹‰
- æŒæ¡ç¨³å®šæ€§çš„åˆ¤æ–­æ ‡å‡†
- ç†è§£ç¨³å®šæ€§çš„é‡è¦æ€§

**é˜¶æ®µ4ï¼šç¨³å®šæ€§åˆ†æ**:

- å­¦ä¹ ç¨³å®šæ€§åˆ†ææ–¹æ³•
- æŒæ¡ç¨³å®šæ€§æ”¹è¿›æŠ€æœ¯
- ç†è§£ç¨³å®šæ€§ä¸ç²¾åº¦çš„å…³ç³»

### 4. é—®é¢˜è§£å†³ç­–ç•¥

#### æ•°å€¼åˆ†æé—®é¢˜åˆ†ç±»

**ç±»å‹1ï¼šæ’å€¼é—®é¢˜**:

- ç­–ç•¥ï¼šé€‰æ‹©åˆé€‚çš„æ’å€¼æ–¹æ³•
- æ–¹æ³•ï¼šæ‹‰æ ¼æœ—æ—¥æ’å€¼ã€ç‰›é¡¿æ’å€¼ã€æ ·æ¡æ’å€¼
- å·¥å…·ï¼šåŸºå‡½æ•°ã€å·®å•†ã€æ ·æ¡å‡½æ•°

**ç±»å‹2ï¼šç§¯åˆ†é—®é¢˜**:

- ç­–ç•¥ï¼šé€‰æ‹©åˆé€‚çš„æ±‚ç§¯å…¬å¼
- æ–¹æ³•ï¼šç‰›é¡¿-ç§‘èŒ¨å…¬å¼ã€é«˜æ–¯æ±‚ç§¯ã€è‡ªé€‚åº”æ±‚ç§¯
- å·¥å…·ï¼šæ±‚ç§¯èŠ‚ç‚¹ã€æ±‚ç§¯æƒé‡ã€è¯¯å·®ä¼°è®¡

**ç±»å‹3ï¼šæ–¹ç¨‹æ±‚è§£**:

- ç­–ç•¥ï¼šé€‰æ‹©åˆé€‚çš„è¿­ä»£æ–¹æ³•
- æ–¹æ³•ï¼šäºŒåˆ†æ³•ã€ç‰›é¡¿æ³•ã€å‰²çº¿æ³•
- å·¥å…·ï¼šæ”¶æ•›æ€§åˆ†æã€è¯¯å·®ä¼°è®¡ã€åŠ é€ŸæŠ€æœ¯

#### å¸¸è§æ€ç»´è¯¯åŒº

**è¯¯åŒº1ï¼šå¿½ç•¥è¯¯å·®åˆ†æ**:

- é—®é¢˜ï¼šåªå…³æ³¨è®¡ç®—ç»“æœï¼Œå¿½ç•¥è¯¯å·®
- è§£å†³ï¼šè¿›è¡Œå®Œæ•´çš„è¯¯å·®åˆ†æ
- ä¾‹å­ï¼šä½¿ç”¨ä¸ç¨³å®šçš„ç®—æ³•

**è¯¯åŒº2ï¼šå‚æ•°é€‰æ‹©ä¸å½“**:

- é—®é¢˜ï¼šå‚æ•°é€‰æ‹©ä¸åˆç†
- è§£å†³ï¼šæ ¹æ®é—®é¢˜ç‰¹ç‚¹é€‰æ‹©å‚æ•°
- ä¾‹å­ï¼šæ­¥é•¿é€‰æ‹©è¿‡å¤§æˆ–è¿‡å°

**è¯¯åŒº3ï¼šç®—æ³•é€‰æ‹©é”™è¯¯**:

- é—®é¢˜ï¼šé€‰æ‹©ä¸åˆé€‚çš„ç®—æ³•
- è§£å†³ï¼šæ ¹æ®é—®é¢˜ç‰¹ç‚¹é€‰æ‹©ç®—æ³•
- ä¾‹å­ï¼šå¯¹ç—…æ€é—®é¢˜ä½¿ç”¨ç®€å•ç®—æ³•

### 5. ç®—æ³•æ€ç»´åˆ†æ

#### æ•°å€¼åˆ†æç®—æ³•è®¾è®¡

**ç®—æ³•1ï¼šè‡ªé€‚åº”ç§¯åˆ†**:

```python
def adaptive_integration(f, a, b, tol=1e-6):
    """è‡ªé€‚åº”ç§¯åˆ†ç®—æ³•"""
    def integrate_interval(a, b, fa, fb, fc):
        """ç§¯åˆ†å•ä¸ªåŒºé—´"""
        c = (a + b) / 2
        fc = f(c)
        
        # ä½¿ç”¨è¾›æ™®æ£®å…¬å¼
        integral = (b - a) * (fa + 4*fc + fb) / 6
        
        # æ£€æŸ¥ç²¾åº¦
        if abs(integral - (b - a) * (fa + fb) / 2) < tol:
            return integral
        else:
            # é€’å½’ç»†åˆ†
            return (integrate_interval(a, c, fa, fc, f((a+c)/2)) + 
                   integrate_interval(c, b, fc, fb, f((c+b)/2)))
    
    return integrate_interval(a, b, f(a), f(b), f((a+b)/2))
```

**ç®—æ³•2ï¼šè¿­ä»£æ³•æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„**:

```python
def jacobi_iteration(A, b, x0, tol=1e-6, max_iter=1000):
    """é›…å¯æ¯”è¿­ä»£æ³•"""
    n = len(b)
    x = x0.copy()
    
    for k in range(max_iter):
        x_new = x.copy()
        
        for i in range(n):
            sum_ax = sum(A[i][j] * x[j] for j in range(n) if j != i)
            x_new[i] = (b[i] - sum_ax) / A[i][i]
        
        # æ£€æŸ¥æ”¶æ•›
        if np.linalg.norm(x_new - x) < tol:
            return x_new, k + 1
        
        x = x_new
    
    raise ValueError("é›…å¯æ¯”è¿­ä»£æœªæ”¶æ•›")
```

## ğŸ”§ æŠ€æœ¯å®ç°è¡¨å¾

### 1. Lean 4 å½¢å¼åŒ–å®ç°

```lean
-- Lean 4 å®ç°
-- æ‹‰æ ¼æœ—æ—¥æ’å€¼
def lagrange_basis (i : â„•) (points : List (â„ Ã— â„)) (x : â„) : â„ :=
  product (map (Î» j, if j.1 = i then 1 else (x - j.2.1) / (points[i].1 - j.2.1)) 
           (enumerate points))

def lagrange_interpolation (points : List (â„ Ã— â„)) (x : â„) : â„ :=
  sum (map (Î» i, points[i].2 * lagrange_basis i points x) (range (length points)))

-- ç‰›é¡¿æ³•
def newton_method (f : â„ â†’ â„) (df : â„ â†’ â„) (x0 : â„) (tol : â„) : â„ :=
  let rec iterate (x : â„) (n : â„•) : â„ :=
    if n > 1000 then x
    else if abs (f x) < tol then x
    else iterate (x - f x / df x) (n + 1)
  iterate x0 0

-- é«˜æ–¯æ±‚ç§¯
def gaussian_quadrature (f : â„ â†’ â„) (a b : â„) (n : â„•) : â„ :=
  let scale := (b - a) / 2
  let shift := (a + b) / 2
  sum (map (Î» i, gauss_weights[n][i] * f (scale * gauss_nodes[n][i] + shift)) (range n)) * scale
```

### 2. Haskell å‡½æ•°å¼å®ç°

```haskell
-- Haskell å®ç°
-- æ‹‰æ ¼æœ—æ—¥æ’å€¼
lagrangeInterpolation :: [(Double, Double)] -> Double -> Double
lagrangeInterpolation points x = sum [y * lagrangeBasis i points x | (i, (_, y)) <- zip [0..] points]

lagrangeBasis :: Int -> [(Double, Double)] -> Double -> Double
lagrangeBasis i points x = product [if j == i then 1 else (x - xj) / (xi - xj) | (j, (xj, _)) <- zip [0..] points]
  where xi = fst (points !! i)

-- ç‰›é¡¿æ³•
newtonMethod :: (Double -> Double) -> (Double -> Double) -> Double -> Double -> Double
newtonMethod f df x0 tol = iterate 0 x0
  where
    iterate n x
      | n > 1000 = x
      | abs (f x) < tol = x
      | otherwise = iterate (n + 1) (x - f x / df x)

-- é¾™æ ¼-åº“å¡”æ–¹æ³•
rungeKutta4 :: (Double -> Double -> Double) -> Double -> Double -> Double -> [Double]
rungeKutta4 f t0 y0 h = y0 : rungeKutta4 f (t0 + h) y1 h
  where
    k1 = f t0 y0
    k2 = f (t0 + h/2) (y0 + h*k1/2)
    k3 = f (t0 + h/2) (y0 + h*k2/2)
    k4 = f (t0 + h) (y0 + h*k3)
    y1 = y0 + h * (k1 + 2*k2 + 2*k3 + k4) / 6

-- é«˜æ–¯æ±‚ç§¯
gaussianQuadrature :: (Double -> Double) -> Double -> Double -> Int -> Double
gaussianQuadrature f a b n = scale * sum [weights !! i * f (scale * nodes !! i + shift) | i <- [0..n-1]]
  where
    scale = (b - a) / 2
    shift = (a + b) / 2
    (nodes, weights) = gaussLegendre n
```

### 3. Python ç®—æ³•å®ç°

```python
# Python å®ç°
import numpy as np
from typing import Callable, List, Tuple

class NumericalAnalysis:
    """æ•°å€¼åˆ†æç®—æ³•å®ç°"""
    
    @staticmethod
    def lagrange_interpolation(points: List[Tuple[float, float]], x: float) -> float:
        """æ‹‰æ ¼æœ—æ—¥æ’å€¼"""
        result = 0.0
        for i, (xi, yi) in enumerate(points):
            term = yi
            for j, (xj, _) in enumerate(points):
                if i != j:
                    term *= (x - xj) / (xi - xj)
            result += term
        return result
    
    @staticmethod
    def newton_method(f: Callable[[float], float], 
                     df: Callable[[float], float], 
                     x0: float, 
                     tol: float = 1e-6, 
                     max_iter: int = 100) -> Tuple[float, int]:
        """ç‰›é¡¿æ³•"""
        x = x0
        for i in range(max_iter):
            fx = f(x)
            if abs(fx) < tol:
                return x, i + 1
            
            dfx = df(x)
            if abs(dfx) < 1e-10:
                raise ValueError("å¯¼æ•°ä¸ºé›¶ï¼Œç‰›é¡¿æ³•å¤±è´¥")
            
            x_new = x - fx / dfx
            if abs(x_new - x) < tol:
                return x_new, i + 1
            
            x = x_new
        
        raise ValueError("ç‰›é¡¿æ³•æœªæ”¶æ•›")
    
    @staticmethod
    def runge_kutta4(f: Callable[[float, float], float], 
                     t0: float, y0: float, h: float, 
                     t_end: float) -> Tuple[List[float], List[float]]:
        """å››é˜¶é¾™æ ¼-åº“å¡”æ–¹æ³•"""
        times = [t0]
        values = [y0]
        t = t0
        y = y0
        
        while t < t_end:
            k1 = f(t, y)
            k2 = f(t + h/2, y + h*k1/2)
            k3 = f(t + h/2, y + h*k2/2)
            k4 = f(t + h, y + h*k3)
            
            y += h * (k1 + 2*k2 + 2*k3 + k4) / 6
            t += h
            
            times.append(t)
            values.append(y)
        
        return times, values
    
    @staticmethod
    def gaussian_quadrature(f: Callable[[float], float], 
                           a: float, b: float, n: int = 3) -> float:
        """é«˜æ–¯æ±‚ç§¯"""
        # é«˜æ–¯-å‹’è®©å¾·èŠ‚ç‚¹å’Œæƒé‡
        if n == 2:
            nodes = [-0.5773502691896257, 0.5773502691896257]
            weights = [1.0, 1.0]
        elif n == 3:
            nodes = [-0.7745966692414834, 0.0, 0.7745966692414834]
            weights = [0.5555555555555556, 0.8888888888888888, 0.5555555555555556]
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„èŠ‚ç‚¹æ•°: {n}")
        
        scale = (b - a) / 2
        shift = (a + b) / 2
        
        result = 0.0
        for i in range(n):
            x = scale * nodes[i] + shift
            result += weights[i] * f(x)
        
        return result * scale
    
    @staticmethod
    def jacobi_iteration(A: np.ndarray, b: np.ndarray, 
                         x0: np.ndarray, tol: float = 1e-6, 
                         max_iter: int = 1000) -> Tuple[np.ndarray, int]:
        """é›…å¯æ¯”è¿­ä»£æ³•"""
        n = len(b)
        x = x0.copy()
        
        for k in range(max_iter):
            x_new = x.copy()
            
            for i in range(n):
                sum_ax = sum(A[i, j] * x[j] for j in range(n) if j != i)
                x_new[i] = (b[i] - sum_ax) / A[i, i]
            
            if np.linalg.norm(x_new - x) < tol:
                return x_new, k + 1
            
            x = x_new
        
        raise ValueError("é›…å¯æ¯”è¿­ä»£æœªæ”¶æ•›")
    
    @staticmethod
    def adaptive_integration(f: Callable[[float], float], 
                           a: float, b: float, tol: float = 1e-6) -> float:
        """è‡ªé€‚åº”ç§¯åˆ†"""
        def integrate_interval(a: float, b: float, fa: float, fb: float) -> float:
            c = (a + b) / 2
            fc = f(c)
            
            # è¾›æ™®æ£®å…¬å¼
            integral = (b - a) * (fa + 4*fc + fb) / 6
            
            # æ£€æŸ¥ç²¾åº¦
            if abs(integral - (b - a) * (fa + fb) / 2) < tol:
                return integral
            else:
                # é€’å½’ç»†åˆ†
                return (integrate_interval(a, c, fa, fc) + 
                       integrate_interval(c, b, fc, fb))
        
        return integrate_interval(a, b, f(a), f(b))

# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    na = NumericalAnalysis()
    
    # æ‹‰æ ¼æœ—æ—¥æ’å€¼
    points = [(0, 1), (1, 2), (2, 4)]
    result = na.lagrange_interpolation(points, 0.5)
    print(f"æ’å€¼ç»“æœ: {result}")
    
    # ç‰›é¡¿æ³•
    f = lambda x: x**2 - 4
    df = lambda x: 2*x
    root, iterations = na.newton_method(f, df, 1.0)
    print(f"æ ¹: {root}, è¿­ä»£æ¬¡æ•°: {iterations}")
    
    # é«˜æ–¯æ±‚ç§¯
    result = na.gaussian_quadrature(lambda x: x**2, 0, 1)
    print(f"ç§¯åˆ†ç»“æœ: {result}")
```

## ğŸ“ˆ åº”ç”¨åœºæ™¯

### 1. ç§‘å­¦è®¡ç®—åº”ç”¨

#### å¾®åˆ†æ–¹ç¨‹æ±‚è§£

```python
# å¸¸å¾®åˆ†æ–¹ç¨‹æ±‚è§£å™¨
class ODESolver:
    """å¸¸å¾®åˆ†æ–¹ç¨‹æ±‚è§£å™¨"""
    
    def __init__(self, f, t0, y0, h):
        self.f = f
        self.t = t0
        self.y = y0
        self.h = h
    
    def euler_method(self, t_end):
        """æ¬§æ‹‰æ–¹æ³•"""
        times = [self.t]
        values = [self.y]
        
        while self.t < t_end:
            self.y += self.h * self.f(self.t, self.y)
            self.t += self.h
            times.append(self.t)
            values.append(self.y)
        
        return times, values
    
    def rk4_method(self, t_end):
        """å››é˜¶é¾™æ ¼-åº“å¡”æ–¹æ³•"""
        times = [self.t]
        values = [self.y]
        
        while self.t < t_end:
            k1 = self.f(self.t, self.y)
            k2 = self.f(self.t + self.h/2, self.y + self.h*k1/2)
            k3 = self.f(self.t + self.h/2, self.y + self.h*k2/2)
            k4 = self.f(self.t + self.h, self.y + self.h*k3)
            
            self.y += self.h * (k1 + 2*k2 + 2*k3 + k4) / 6
            self.t += self.h
            times.append(self.t)
            values.append(self.y)
        
        return times, values

# ä½¿ç”¨ç¤ºä¾‹ï¼šæ±‚è§£ y' = -y, y(0) = 1
def f(t, y):
    return -y

solver = ODESolver(f, 0, 1, 0.1)
times_euler, values_euler = solver.euler_method(5)
times_rk4, values_rk4 = solver.rk4_method(5)

# æ¯”è¾ƒç²¾åº¦
exact = np.exp(-np.array(times_rk4))
error_euler = np.abs(values_euler - np.exp(-np.array(times_euler)))
error_rk4 = np.abs(values_rk4 - exact)

print(f"æ¬§æ‹‰æ–¹æ³•æœ€å¤§è¯¯å·®: {np.max(error_euler):.6f}")
print(f"RK4æ–¹æ³•æœ€å¤§è¯¯å·®: {np.max(error_rk4):.6f}")
```

### 2. å·¥ç¨‹è®¡ç®—åº”ç”¨

#### æœ‰é™å…ƒæ–¹æ³•

```python
# ä¸€ç»´æœ‰é™å…ƒæ–¹æ³•
class FiniteElement1D:
    """ä¸€ç»´æœ‰é™å…ƒæ–¹æ³•"""
    
    def __init__(self, a, b, n_elements):
        self.a = a
        self.b = b
        self.n_elements = n_elements
        self.h = (b - a) / n_elements
        self.nodes = np.linspace(a, b, n_elements + 1)
    
    def assemble_system(self, f):
        """ç»„è£…çº¿æ€§ç³»ç»Ÿ"""
        n_nodes = len(self.nodes)
        A = np.zeros((n_nodes, n_nodes))
        b = np.zeros(n_nodes)
        
        # ç»„è£…åˆšåº¦çŸ©é˜µå’Œè½½è·å‘é‡
        for i in range(self.n_elements):
            x1, x2 = self.nodes[i], self.nodes[i+1]
            h_e = x2 - x1
            
            # å±€éƒ¨åˆšåº¦çŸ©é˜µ
            A_local = np.array([[1, -1], [-1, 1]]) / h_e
            
            # å±€éƒ¨è½½è·å‘é‡
            b_local = np.array([f(x1), f(x2)]) * h_e / 2
            
            # ç»„è£…åˆ°å…¨å±€çŸ©é˜µ
            A[i:i+2, i:i+2] += A_local
            b[i:i+2] += b_local
        
        # è¾¹ç•Œæ¡ä»¶
        A[0, :] = 0
        A[0, 0] = 1
        b[0] = 0
        
        A[-1, :] = 0
        A[-1, -1] = 1
        b[-1] = 0
        
        return A, b
    
    def solve(self, f):
        """æ±‚è§£æœ‰é™å…ƒé—®é¢˜"""
        A, b = self.assemble_system(f)
        u = np.linalg.solve(A, b)
        return self.nodes, u

# ä½¿ç”¨ç¤ºä¾‹
fem = FiniteElement1D(0, 1, 10)
def f(x):
    return 1  # å³ç«¯é¡¹

nodes, solution = fem.solve(f)
print("æœ‰é™å…ƒè§£:", solution)
```

### 3. é‡‘èè®¡ç®—åº”ç”¨

#### è’™ç‰¹å¡æ´›æ–¹æ³•

```python
# è’™ç‰¹å¡æ´›ç§¯åˆ†
class MonteCarlo:
    """è’™ç‰¹å¡æ´›æ–¹æ³•"""
    
    @staticmethod
    def integrate(f, a, b, n_samples=10000):
        """è’™ç‰¹å¡æ´›ç§¯åˆ†"""
        samples = np.random.uniform(a, b, n_samples)
        values = f(samples)
        return (b - a) * np.mean(values)
    
    @staticmethod
    def option_pricing(S0, K, T, r, sigma, n_paths=10000, n_steps=100):
        """æœŸæƒå®šä»·"""
        dt = T / n_steps
        paths = np.zeros((n_paths, n_steps + 1))
        paths[:, 0] = S0
        
        for i in range(n_steps):
            z = np.random.normal(0, 1, n_paths)
            paths[:, i+1] = paths[:, i] * np.exp((r - 0.5*sigma**2)*dt + sigma*np.sqrt(dt)*z)
        
        # è®¡ç®—æœŸæƒä»·æ ¼
        call_payoff = np.maximum(paths[:, -1] - K, 0)
        put_payoff = np.maximum(K - paths[:, -1], 0)
        
        call_price = np.exp(-r*T) * np.mean(call_payoff)
        put_price = np.exp(-r*T) * np.mean(put_payoff)
        
        return call_price, put_price

# ä½¿ç”¨ç¤ºä¾‹
mc = MonteCarlo()
call_price, put_price = mc.option_pricing(100, 100, 1, 0.05, 0.2)
print(f"çœ‹æ¶¨æœŸæƒä»·æ ¼: {call_price:.4f}")
print(f"çœ‹è·ŒæœŸæƒä»·æ ¼: {put_price:.4f}")
```

## ğŸ“Š æ€»ç»“ä¸å±•æœ›

### ä¸»è¦æˆå°±

1. **ç†è®ºåŸºç¡€å®Œå–„**ï¼šå»ºç«‹äº†å®Œæ•´çš„æ•°å€¼åˆ†æç†è®ºä½“ç³»
2. **ç®—æ³•å®ç°ä¸°å¯Œ**ï¼šæä¾›äº†å¤šç§ç¼–ç¨‹è¯­è¨€çš„å®ç°
3. **åº”ç”¨åœºæ™¯å¹¿æ³›**ï¼šåœ¨ç§‘å­¦è®¡ç®—ã€å·¥ç¨‹è®¡ç®—ã€é‡‘èè®¡ç®—ç­‰é¢†åŸŸæœ‰é‡è¦åº”ç”¨
4. **å†å²å‘å±•æ¸…æ™°**ï¼šæ¢³ç†äº†ä»å¤ä»£åˆ°ç°ä»£çš„å‘å±•è„‰ç»œ

### å‘å±•ç°çŠ¶

1. **ç†è®ºæˆç†Ÿ**ï¼šæ•°å€¼åˆ†æçš„åŸºæœ¬ç†è®ºå·²ç»ç›¸å½“æˆç†Ÿ
2. **åº”ç”¨æ´»è·ƒ**ï¼šåœ¨ç§‘å­¦è®¡ç®—å’Œå·¥ç¨‹è®¡ç®—ä¸­åº”ç”¨å¹¿æ³›
3. **ç®—æ³•ä¼˜åŒ–**ï¼šä¸æ–­æœ‰æ–°çš„ç®—æ³•å’Œä¼˜åŒ–æ–¹æ³•å‡ºç°
4. **æ•™è‚²æ™®åŠ**ï¼šæˆä¸ºæ•°å­¦å’Œå·¥ç¨‹æ•™è‚²çš„é‡è¦å†…å®¹

### æœªæ¥æ–¹å‘

1. **ç®—æ³•ä¼˜åŒ–**ï¼šç»§ç»­ä¼˜åŒ–ç°æœ‰ç®—æ³•çš„æ•ˆç‡
2. **æ–°åº”ç”¨é¢†åŸŸ**ï¼šæ¢ç´¢åœ¨äººå·¥æ™ºèƒ½ã€å¤§æ•°æ®ç­‰æ–°é¢†åŸŸçš„åº”ç”¨
3. **æ•™è‚²åˆ›æ–°**ï¼šå¼€å‘æ›´å¥½çš„æ•™å­¦æ–¹æ³•å’Œå·¥å…·
4. **ç†è®ºç ”ç©¶**ï¼šæ·±å…¥ç ”ç©¶ä¸å…¶ä»–æ•°å­¦åˆ†æ”¯çš„è”ç³»

---

**æ•°å€¼åˆ†æå¢å¼ºç‰ˆå®Œæˆ** âœ…  
**å¤šè¡¨å¾å®Œå–„åº¦**: 90%  
**æŠ€æœ¯å®ç°**: Lean 4ã€Haskellã€Python  
**åº”ç”¨å®ä¾‹**: ç§‘å­¦è®¡ç®—ã€å·¥ç¨‹è®¡ç®—ã€é‡‘èè®¡ç®—  
**æœ€åæ›´æ–°**: 2025å¹´8æœˆ2æ—¥

## äº¤äº’ä¸è¡¥å……èµ„æº / Interactive & Supplementary Resources

### äº¤äº’å¼å›¾è¡¨å¢å¼º

- [æ•°å€¼æ–¹æ³•å¯è§†åŒ–](äº¤äº’å¼å›¾è¡¨å¢å¼º-2025å¹´1æœˆ.md#æ•°å€¼æ–¹æ³•å¯è§†åŒ–å™¨)
- [æ”¶æ•›æ€§åˆ†æå·¥å…·](äº¤äº’å¼å›¾è¡¨å¢å¼º-2025å¹´1æœˆ.md#æ”¶æ•›æ€§åˆ†æå™¨)
- [è¯¯å·®åˆ†æå¯è§†åŒ–](äº¤äº’å¼å›¾è¡¨å¢å¼º-2025å¹´1æœˆ.md#è¯¯å·®åˆ†æå™¨)

### å®šç†è¯æ˜è¡¥å……

- [æ‹‰æ ¼æœ—æ—¥æ’å€¼å”¯ä¸€æ€§å®šç†](å®šç†è¯æ˜è¡¥å……-2025å¹´1æœˆ.md#æ‹‰æ ¼æœ—æ—¥æ’å€¼å”¯ä¸€æ€§å®šç†)
- [ç‰›é¡¿æ³•æ”¶æ•›æ€§å®šç†](å®šç†è¯æ˜è¡¥å……-2025å¹´1æœˆ.md#ç‰›é¡¿æ³•æ”¶æ•›æ€§å®šç†)
- [é«˜æ–¯æ±‚ç§¯ç²¾åº¦å®šç†](å®šç†è¯æ˜è¡¥å……-2025å¹´1æœˆ.md#é«˜æ–¯æ±‚ç§¯ç²¾åº¦å®šç†)

### åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……

- [æ•°å€¼ä¸ç¨³å®šæ€§åä¾‹](åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……-2025å¹´1æœˆ.md#æ•°å€¼ä¸ç¨³å®šæ€§åä¾‹)
- [ç—…æ€é—®é¢˜å®ä¾‹](åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……-2025å¹´1æœˆ.md#ç—…æ€é—®é¢˜å®ä¾‹)
- [æ”¶æ•›å¤±è´¥æ¡ˆä¾‹](åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……-2025å¹´1æœˆ.md#æ”¶æ•›å¤±è´¥æ¡ˆä¾‹)

### å†å²èƒŒæ™¯è¡¥å……

- [æ•°å€¼åˆ†æå‘å±•å²](å†å²èƒŒæ™¯è¡¥å……-2025å¹´1æœˆ.md#æ•°å€¼åˆ†æå‘å±•å²)
- [é‡è¦æ•°å­¦å®¶è´¡çŒ®](å†å²èƒŒæ™¯è¡¥å……-2025å¹´1æœˆ.md#æ•°å€¼åˆ†æé‡è¦äººç‰©)
- [è®¡ç®—æœºæ—¶ä»£å½±å“](å†å²èƒŒæ™¯è¡¥å……-2025å¹´1æœˆ.md#è®¡ç®—æœºæ—¶ä»£æ•°å€¼åˆ†æ)
