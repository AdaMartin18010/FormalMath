# 欧几里得几何应用案例 - 深度扩展版 / Euclidean Geometry Applications - Deep Extension

## 概述 / Overview

本文档提供了欧几里得几何在各个领域的深度应用案例，包括计算机图形学、机器人学、计算机视觉、建筑设计等跨学科应用。

## 1. 计算机图形学应用 / Computer Graphics Applications

### 1.1 3D建模与渲染 / 3D Modeling and Rendering

**应用背景**：3D建模需要精确的几何变换和空间关系处理。

**理论基础**：欧几里得几何的变换理论和投影几何。

**实现方案**：

```python
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

class GeometricModeler:
    """几何建模器"""

    def __init__(self):
        self.vertices = []
        self.faces = []
        self.transformations = []

    def add_vertex(self, x, y, z):
        """添加顶点"""
        self.vertices.append([x, y, z])

    def add_face(self, vertex_indices):
        """添加面"""
        self.faces.append(vertex_indices)

    def apply_transformation(self, transformation_matrix):
        """应用变换"""
        vertices_array = np.array(self.vertices)
        transformed_vertices = np.dot(vertices_array, transformation_matrix[:3, :3].T) + transformation_matrix[:3, 3]
        self.vertices = transformed_vertices.tolist()

    def render(self):
        """渲染模型"""
        fig = plt.figure(figsize=(10, 8))
        ax = fig.add_subplot(111, projection='3d')

        for face in self.faces:
            face_vertices = [self.vertices[i] for i in face]
            x = [v[0] for v in face_vertices]
            y = [v[1] for v in face_vertices]
            z = [v[2] for v in face_vertices]
            ax.plot_trisurf(x, y, z, alpha=0.7)

        ax.set_xlabel('X')
        ax.set_ylabel('Y')
        ax.set_zlabel('Z')
        plt.show()

# 创建立方体
modeler = GeometricModeler()

# 添加立方体顶点
vertices = [
    [0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0],
    [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]
]

for vertex in vertices:
    modeler.add_vertex(*vertex)

# 添加立方体面
faces = [
    [0, 1, 2, 3], [4, 5, 6, 7], [0, 1, 5, 4],
    [2, 3, 7, 6], [0, 3, 7, 4], [1, 2, 6, 5]
]

for face in faces:
    modeler.add_face(face)

# 应用旋转变换
rotation_matrix = np.array([
    [np.cos(np.pi/4), -np.sin(np.pi/4), 0, 0],
    [np.sin(np.pi/4), np.cos(np.pi/4), 0, 0],
    [0, 0, 1, 0],
    [0, 0, 0, 1]
])

modeler.apply_transformation(rotation_matrix)
modeler.render()
```

### 1.2 光照计算 / Lighting Calculations

**应用背景**：真实感渲染需要精确的光照模型和几何计算。

**理论基础**：向量代数、反射定律、折射定律。

**实现方案**：

```python
class LightingEngine:
    """光照引擎"""

    def __init__(self):
        self.light_sources = []
        self.materials = {}

    def add_light_source(self, position, intensity, color):
        """添加光源"""
        self.light_sources.append({
            'position': np.array(position),
            'intensity': intensity,
            'color': np.array(color)
        })

    def add_material(self, name, ambient, diffuse, specular, shininess):
        """添加材质"""
        self.materials[name] = {
            'ambient': np.array(ambient),
            'diffuse': np.array(diffuse),
            'specular': np.array(specular),
            'shininess': shininess
        }

    def calculate_lighting(self, point, normal, material_name, view_direction):
        """计算光照"""
        material = self.materials[material_name]
        total_color = np.zeros(3)

        for light in self.light_sources:
            # 计算光线方向
            light_direction = light['position'] - point
            light_distance = np.linalg.norm(light_direction)
            light_direction = light_direction / light_distance

            # 环境光
            ambient = material['ambient'] * light['color']

            # 漫反射
            diffuse_intensity = max(0, np.dot(normal, light_direction))
            diffuse = material['diffuse'] * light['color'] * diffuse_intensity

            # 镜面反射
            reflection = 2 * np.dot(normal, light_direction) * normal - light_direction
            specular_intensity = max(0, np.dot(view_direction, reflection)) ** material['shininess']
            specular = material['specular'] * light['color'] * specular_intensity

            # 衰减
            attenuation = 1 / (1 + 0.1 * light_distance + 0.01 * light_distance**2)

            total_color += (ambient + diffuse + specular) * attenuation * light['intensity']

        return np.clip(total_color, 0, 1)

# 使用示例
lighting = LightingEngine()

# 添加光源
lighting.add_light_source([5, 5, 5], 1.0, [1, 1, 1])

# 添加材质
lighting.add_material('metal', [0.1, 0.1, 0.1], [0.7, 0.7, 0.7], [1.0, 1.0, 1.0], 100)

# 计算光照
point = np.array([0, 0, 0])
normal = np.array([0, 0, 1])
view_dir = np.array([0, 0, -1])

color = lighting.calculate_lighting(point, normal, 'metal', view_dir)
print(f"计算得到的颜色: {color}")
```

### 1.3 碰撞检测 / Collision Detection

**应用背景**：游戏和仿真需要高效的碰撞检测算法。

**理论基础**：几何相交理论、分离轴定理。

**实现方案**：

```python
class CollisionDetector:
    """碰撞检测器"""

    def __init__(self):
        pass

    def sphere_sphere_collision(self, sphere1, sphere2):
        """球体-球体碰撞检测"""
        center1, radius1 = sphere1
        center2, radius2 = sphere2

        distance = np.linalg.norm(center1 - center2)
        return distance <= radius1 + radius2

    def aabb_collision(self, box1, box2):
        """轴对齐包围盒碰撞检测"""
        min1, max1 = box1
        min2, max2 = box2

        return (min1[0] <= max2[0] and max1[0] >= min2[0] and
                min1[1] <= max2[1] and max1[1] >= min2[1] and
                min1[2] <= max2[2] and max1[2] >= min2[2])

    def ray_triangle_intersection(self, ray_origin, ray_direction, triangle):
        """射线-三角形相交检测"""
        v0, v1, v2 = triangle

        # 计算三角形法向量
        edge1 = v1 - v0
        edge2 = v2 - v0
        normal = np.cross(edge1, edge2)

        # 计算行列式
        det = np.dot(ray_direction, normal)

        if abs(det) < 1e-6:
            return None  # 平行

        # 计算重心坐标
        t = np.dot(v0 - ray_origin, normal) / det
        if t < 0:
            return None  # 在射线后方

        intersection = ray_origin + t * ray_direction

        # 检查是否在三角形内
        edge0 = v0 - intersection
        edge1 = v1 - intersection
        edge2 = v2 - intersection

        c0 = np.cross(edge1, edge2)
        c1 = np.cross(edge2, edge0)
        c2 = np.cross(edge0, edge1)

        if (np.dot(c0, normal) >= 0 and
            np.dot(c1, normal) >= 0 and
            np.dot(c2, normal) >= 0):
            return intersection

        return None

# 使用示例
detector = CollisionDetector()

# 球体碰撞检测
sphere1 = (np.array([0, 0, 0]), 1.0)
sphere2 = (np.array([1.5, 0, 0]), 1.0)
collision = detector.sphere_sphere_collision(sphere1, sphere2)
print(f"球体碰撞: {collision}")

# 射线-三角形相交检测
ray_origin = np.array([0, 0, 0])
ray_direction = np.array([0, 0, 1])
triangle = [
    np.array([-1, -1, 2]),
    np.array([1, -1, 2]),
    np.array([0, 1, 2])
]

intersection = detector.ray_triangle_intersection(ray_origin, ray_direction, triangle)
print(f"射线相交点: {intersection}")
```

## 2. 机器人学应用 / Robotics Applications

### 2.1 运动学分析 / Kinematic Analysis

**应用背景**：机器人控制需要精确的运动学模型。

**理论基础**：DH参数、齐次变换矩阵。

**实现方案**：

```python
class RobotKinematics:
    """机器人运动学"""

    def __init__(self):
        self.joints = []
        self.dh_params = []

    def add_joint(self, joint_type, dh_params):
        """添加关节"""
        self.joints.append(joint_type)  # 'revolute' or 'prismatic'
        self.dh_params.append(dh_params)  # [a, alpha, d, theta]

    def dh_transform(self, a, alpha, d, theta):
        """DH变换矩阵"""
        ct = np.cos(theta)
        st = np.sin(theta)
        ca = np.cos(alpha)
        sa = np.sin(alpha)

        return np.array([
            [ct, -st*ca, st*sa, a*ct],
            [st, ct*ca, -ct*sa, a*st],
            [0, sa, ca, d],
            [0, 0, 0, 1]
        ])

    def forward_kinematics(self, joint_angles):
        """正向运动学"""
        if len(joint_angles) != len(self.joints):
            raise ValueError("关节角度数量不匹配")

        T = np.eye(4)

        for i, (joint_type, dh_params) in enumerate(zip(self.joints, self.dh_params)):
            a, alpha, d, theta = dh_params

            if joint_type == 'revolute':
                theta += joint_angles[i]
            elif joint_type == 'prismatic':
                d += joint_angles[i]

            T_i = self.dh_transform(a, alpha, d, theta)
            T = T @ T_i

        return T

    def jacobian_matrix(self, joint_angles):
        """雅可比矩阵"""
        epsilon = 1e-6
        n_joints = len(joint_angles)
        J = np.zeros((6, n_joints))

        T_base = self.forward_kinematics(joint_angles)
        p_base = T_base[:3, 3]

        for i in range(n_joints):
            # 数值微分计算雅可比矩阵
            angles_plus = joint_angles.copy()
            angles_plus[i] += epsilon

            T_plus = self.forward_kinematics(angles_plus)
            p_plus = T_plus[:3, 3]

            # 线性速度
            J[:3, i] = (p_plus - p_base) / epsilon

            # 角速度（简化计算）
            R_base = T_base[:3, :3]
            R_plus = T_plus[:3, :3]
            dR = (R_plus - R_base) / epsilon

            # 从旋转矩阵提取角速度
            omega = np.array([dR[2, 1], dR[0, 2], dR[1, 0]])
            J[3:, i] = omega

        return J

# 创建6自由度机械臂
robot = RobotKinematics()

# 添加关节（UR5参数）
dh_params = [
    [0, np.pi/2, 0.1625, 0],      # 关节1
    [-0.425, 0, 0, 0],            # 关节2
    [-0.3922, 0, 0, 0],           # 关节3
    [0, np.pi/2, 0.1333, 0],      # 关节4
    [0, -np.pi/2, 0.0997, 0],     # 关节5
    [0, 0, 0.0996, 0]             # 关节6
]

for params in dh_params:
    robot.add_joint('revolute', params)

# 计算正向运动学
joint_angles = [0, -np.pi/2, 0, 0, 0, 0]
T = robot.forward_kinematics(joint_angles)
print(f"末端位姿矩阵:\n{T}")

# 计算雅可比矩阵
J = robot.jacobian_matrix(joint_angles)
print(f"雅可比矩阵:\n{J}")
```

---

**参考文献 / References**:

1. Foley, J. D., et al. (1995). *Computer Graphics: Principles and Practice*. Addison-Wesley.
2. Siciliano, B., & Khatib, O. (2016). *Springer Handbook of Robotics*. Springer.
