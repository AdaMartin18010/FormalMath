# å¤åˆ†æ - å¢å¼ºç‰ˆ

## ğŸ“‹ ç›®å½•

- [å¤åˆ†æ - å¢å¼ºç‰ˆ](#å¤åˆ†æ---å¢å¼ºç‰ˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [æ ¸å¿ƒç‰¹å¾](#æ ¸å¿ƒç‰¹å¾)
  - [å†å²å‘å±•è„‰ç»œ](#å†å²å‘å±•è„‰ç»œ)
    - [æ—©æœŸå‘å±• (16-18ä¸–çºª)](#æ—©æœŸå‘å±•-16-18ä¸–çºª)
      - [é‡è¦äººç‰©è´¡çŒ®](#é‡è¦äººç‰©è´¡çŒ®)
  - [å¤æ•°ç³»ç»Ÿ](#å¤æ•°ç³»ç»Ÿ)
    - [å¤æ•°å®šä¹‰](#å¤æ•°å®šä¹‰)
    - [æåæ ‡è¡¨ç¤º](#æåæ ‡è¡¨ç¤º)
  - [å¤å˜å‡½æ•°](#å¤å˜å‡½æ•°)
    - [åŸºæœ¬æ¦‚å¿µ](#åŸºæœ¬æ¦‚å¿µ)
    - [æé™ä¸è¿ç»­æ€§](#æé™ä¸è¿ç»­æ€§)
  - [è§£æå‡½æ•°](#è§£æå‡½æ•°)
    - [æŸ¯è¥¿-é»æ›¼æ–¹ç¨‹](#æŸ¯è¥¿-é»æ›¼æ–¹ç¨‹)
    - [å¹‚çº§æ•°å±•å¼€](#å¹‚çº§æ•°å±•å¼€)
  - [æŸ¯è¥¿ç§¯åˆ†ç†è®º](#æŸ¯è¥¿ç§¯åˆ†ç†è®º)
    - [æŸ¯è¥¿ç§¯åˆ†å®šç†](#æŸ¯è¥¿ç§¯åˆ†å®šç†)
    - [æŸ¯è¥¿ç§¯åˆ†å…¬å¼](#æŸ¯è¥¿ç§¯åˆ†å…¬å¼)
    - [ç§¯åˆ†è®¡ç®—](#ç§¯åˆ†è®¡ç®—)
  - [ç•™æ•°ç†è®º](#ç•™æ•°ç†è®º)
    - [ç•™æ•°å®šä¹‰](#ç•™æ•°å®šä¹‰)
    - [ç•™æ•°è®¡ç®—å®ä¾‹](#ç•™æ•°è®¡ç®—å®ä¾‹)
  - [å…±å½¢æ˜ å°„](#å…±å½¢æ˜ å°„)
    - [å…±å½¢æ˜ å°„æ¦‚å¿µ](#å…±å½¢æ˜ å°„æ¦‚å¿µ)
    - [é‡è¦æ˜ å°„](#é‡è¦æ˜ å°„)
    - [é»æ›¼æ˜ å°„å®šç†](#é»æ›¼æ˜ å°„å®šç†)
  - [åº”ç”¨åœºæ™¯](#åº”ç”¨åœºæ™¯)
    - [ç‰©ç†å­¦åº”ç”¨](#ç‰©ç†å­¦åº”ç”¨)
      - [æµä½“åŠ›å­¦](#æµä½“åŠ›å­¦)
      - [ç”µç£å­¦](#ç”µç£å­¦)
    - [å·¥ç¨‹åº”ç”¨](#å·¥ç¨‹åº”ç”¨)
      - [ä¿¡å·å¤„ç†](#ä¿¡å·å¤„ç†)
      - [æ§åˆ¶ç†è®º](#æ§åˆ¶ç†è®º)
  - [å½¢å¼åŒ–å®ç°](#å½¢å¼åŒ–å®ç°)
    - [Lean 4 å®Œæ•´å®ç°](#lean-4-å®Œæ•´å®ç°)
  - [æ€ç»´è¿‡ç¨‹è¡¨å¾](#æ€ç»´è¿‡ç¨‹è¡¨å¾)
    - [è§£æå‡½æ•°åˆ¤æ–­æµç¨‹](#è§£æå‡½æ•°åˆ¤æ–­æµç¨‹)
    - [ç§¯åˆ†è®¡ç®—æ€ç»´è¿‡ç¨‹](#ç§¯åˆ†è®¡ç®—æ€ç»´è¿‡ç¨‹)
  - [å®ä¾‹è¡¨å¾](#å®ä¾‹è¡¨å¾)
    - [ç»å…¸å®ä¾‹](#ç»å…¸å®ä¾‹)
      - [1. æŒ‡æ•°å‡½æ•°](#1-æŒ‡æ•°å‡½æ•°)
      - [2. ä¸‰è§’å‡½æ•°](#2-ä¸‰è§’å‡½æ•°)
      - [3. å¯¹æ•°å‡½æ•°](#3-å¯¹æ•°å‡½æ•°)
    - [åº”ç”¨å®ä¾‹](#åº”ç”¨å®ä¾‹)
      - [1. æµä½“åŠ›å­¦åº”ç”¨](#1-æµä½“åŠ›å­¦åº”ç”¨)
      - [2. ä¿¡å·å¤„ç†åº”ç”¨](#2-ä¿¡å·å¤„ç†åº”ç”¨)
  - [æ€»ç»“ä¸å±•æœ›](#æ€»ç»“ä¸å±•æœ›)
    - [ä¸»è¦æˆå°±](#ä¸»è¦æˆå°±)
    - [å‘å±•ç°çŠ¶](#å‘å±•ç°çŠ¶)
    - [æœªæ¥æ–¹å‘](#æœªæ¥æ–¹å‘)
  - [æœ¯è¯­å¯¹ç…§è¡¨ / Terminology Table](#æœ¯è¯­å¯¹ç…§è¡¨--terminology-table)

## æ¦‚è¿°

å¤åˆ†ææ˜¯ç ”ç©¶å¤æ•°åŸŸä¸Šå‡½æ•°çš„æ•°å­¦åˆ†æ”¯ï¼Œæ˜¯å®åˆ†æçš„æ¨å¹¿å’Œæ·±åŒ–ã€‚
å®ƒç ”ç©¶å¤å˜å‡½æ•°çš„æ€§è´¨ã€è§£ææ€§ã€ç§¯åˆ†ç†è®ºå’Œå‡ ä½•åº”ç”¨ï¼Œåœ¨æ•°å­¦å’Œç‰©ç†ä¸­å…·æœ‰é‡è¦åœ°ä½ã€‚

### æ ¸å¿ƒç‰¹å¾

- **è§£ææ€§**: å¤å˜å‡½æ•°çš„å¯å¾®æ€§è•´å«æ— é™å¯å¾®æ€§
- **å‡ ä½•æ€§**: å¤å˜å‡½æ•°å…·æœ‰ä¸°å¯Œçš„å‡ ä½•æ€§è´¨
- **ç§¯åˆ†æ€§**: æŸ¯è¥¿ç§¯åˆ†å…¬å¼å’Œç•™æ•°ç†è®º
- **åº”ç”¨æ€§**: åœ¨ç‰©ç†ã€å·¥ç¨‹ã€ä¿¡å·å¤„ç†ä¸­çš„å¹¿æ³›åº”ç”¨

## å†å²å‘å±•è„‰ç»œ

### æ—©æœŸå‘å±• (16-18ä¸–çºª)

```mermaid
timeline
    title å¤åˆ†æå†å²å‘å±•
    1545å¹´ : å¡å°”è¾¾è¯ºå¼•å…¥è™šæ•°
    1700å¹´ : æ££è«å¼—å…¬å¼å‘ç°
    1748å¹´ : æ¬§æ‹‰å…¬å¼ e^(iÏ€) + 1 = 0
    1814å¹´ : æŸ¯è¥¿ç§¯åˆ†å®šç†
    1851å¹´ : é»æ›¼æ˜ å°„å®šç†
    20ä¸–çºª : ç°ä»£å¤åˆ†æå‘å±•
```

#### é‡è¦äººç‰©è´¡çŒ®

| äººç‰© | æ—¶æœŸ | ä¸»è¦è´¡çŒ® |
|------|------|----------|
| å¡å°”è¾¾è¯º | 1545 | å¼•å…¥è™šæ•°æ¦‚å¿µ |
| æ££è«å¼— | 1700 | æ££è«å¼—å…¬å¼ |
| æ¬§æ‹‰ | 1748 | æ¬§æ‹‰å…¬å¼ï¼ŒæŒ‡æ•°å‡½æ•° |
| æŸ¯è¥¿ | 1814 | æŸ¯è¥¿ç§¯åˆ†å®šç†ï¼ŒæŸ¯è¥¿ç§¯åˆ†å…¬å¼ |
| é»æ›¼ | 1851 | é»æ›¼æ˜ å°„å®šç†ï¼Œé»æ›¼æ›²é¢ |
| é­å°”æ–¯ç‰¹æ‹‰æ–¯ | 1850-1897 | è§£æå‡½æ•°ç†è®º |
| åºåŠ è± | 1880-1900 | è‡ªå®ˆå‡½æ•°ç†è®º |

## å¤æ•°ç³»ç»Ÿ

### å¤æ•°å®šä¹‰

```lean
-- Lean 4 å®ç°
structure Complex where
  re : â„
  im : â„

-- å¤æ•°è¿ç®—
def Complex.add (z w : Complex) : Complex :=
  âŸ¨z.re + w.re, z.im + w.imâŸ©

def Complex.mul (z w : Complex) : Complex :=
  âŸ¨z.re * w.re - z.im * w.im, z.re * w.im + z.im * w.reâŸ©

-- æ¨¡é•¿
def Complex.abs (z : Complex) : â„ :=
  Real.sqrt (z.re^2 + z.im^2)

-- è¾è§’
def Complex.arg (z : Complex) : â„ :=
  if z.re = 0 âˆ§ z.im = 0 then 0
  else Real.atan2 z.im z.re
```

### æåæ ‡è¡¨ç¤º

```haskell
-- Haskell å®ç°
data Complex = Complex { real :: Double, imag :: Double }
             | Polar { magnitude :: Double, argument :: Double }

-- æåæ ‡è½¬æ¢
toPolar :: Complex -> Polar
toPolar (Complex re im) = Polar magnitude argument
  where
    magnitude = sqrt (re^2 + im^2)
    argument = atan2 im re

fromPolar :: Polar -> Complex
fromPolar (Polar mag arg) = Complex re im
  where
    re = mag * cos arg
    im = mag * sin arg

-- æ££è«å¼—å…¬å¼
deMoivre :: Polar -> Integer -> Polar
deMoivre (Polar mag arg) n = Polar (mag^n) (fromIntegral n * arg)
```

## å¤å˜å‡½æ•°

### åŸºæœ¬æ¦‚å¿µ

```mermaid
graph TD
    A[å¤å˜å‡½æ•° f] --> B[å®šä¹‰åŸŸ D âŠ† â„‚]
    B --> C[å€¼åŸŸ f(D) âŠ† â„‚]
    C --> D[å‡½æ•°æ€§è´¨]
    D --> E[è¿ç»­æ€§]
    D --> F[å¯å¾®æ€§]
    D --> G[è§£ææ€§]
    E --> H[æé™å­˜åœ¨]
    F --> I[å¯¼æ•°å­˜åœ¨]
    G --> J[æ³°å‹’çº§æ•°æ”¶æ•›]
```

### æé™ä¸è¿ç»­æ€§

```rust
// Rust å®ç°
#[derive(Debug, Clone)]
pub struct Complex {
    pub re: f64,
    pub im: f64,
}

impl Complex {
    pub fn new(re: f64, im: f64) -> Self {
        Self { re, im }
    }

    pub fn abs(&self) -> f64 {
        (self.re * self.re + self.im * self.im).sqrt()
    }

    pub fn conjugate(&self) -> Self {
        Self { re: self.re, im: -self.im }
    }
}

// å¤å˜å‡½æ•°
trait ComplexFunction {
    fn evaluate(&self, z: Complex) -> Complex;
    fn is_continuous_at(&self, z0: Complex) -> bool;
    fn is_differentiable_at(&self, z0: Complex) -> bool;
}

// å¤šé¡¹å¼å‡½æ•°
struct Polynomial {
    coefficients: Vec<Complex>,
}

impl ComplexFunction for Polynomial {
    fn evaluate(&self, z: Complex) -> Complex {
        let mut result = Complex::new(0.0, 0.0);
        let mut power = Complex::new(1.0, 0.0);

        for &coeff in &self.coefficients {
            result = Complex::new(
                result.re + coeff.re * power.re - coeff.im * power.im,
                result.im + coeff.re * power.im + coeff.im * power.re
            );
            power = Complex::new(
                power.re * z.re - power.im * z.im,
                power.re * z.im + power.im * z.re
            );
        }

        result
    }

    fn is_continuous_at(&self, _z0: Complex) -> bool {
        true // å¤šé¡¹å¼å¤„å¤„è¿ç»­
    }

    fn is_differentiable_at(&self, _z0: Complex) -> bool {
        true // å¤šé¡¹å¼å¤„å¤„å¯å¾®
    }
}
```

## è§£æå‡½æ•°

### æŸ¯è¥¿-é»æ›¼æ–¹ç¨‹

```lean
-- Lean 4 å®ç°
-- æŸ¯è¥¿-é»æ›¼æ–¹ç¨‹
def cauchy_riemann_equations (f : â„‚ â†’ â„‚) (z : â„‚) : Prop :=
  let u := Î» x y, (f (x + y * I)).re
  let v := Î» x y, (f (x + y * I)).im
  âˆ‚u/âˆ‚x z.re z.im = âˆ‚v/âˆ‚y z.re z.im âˆ§
  âˆ‚u/âˆ‚y z.re z.im = -âˆ‚v/âˆ‚x z.re z.im

-- è§£æå‡½æ•°å®šä¹‰
def analytic_at (f : â„‚ â†’ â„‚) (z : â„‚) : Prop :=
  âˆƒ L : â„‚, âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ w : â„‚,
    |w - z| < Î´ â†’ |(f w - f z) / (w - z) - L| < Îµ

-- è§£æå‡½æ•°æ€§è´¨
theorem analytic_implies_cauchy_riemann (f : â„‚ â†’ â„‚) (z : â„‚) :
  analytic_at f z â†’ cauchy_riemann_equations f z := by
  -- å®ç°ç»†èŠ‚
  sorry
```

### å¹‚çº§æ•°å±•å¼€

```haskell
-- Haskell å®ç°
-- æ³°å‹’çº§æ•°
taylorSeries :: (Complex -> Complex) -> Complex -> [Complex]
taylorSeries f z0 = map (\n -> derivativeN f z0 n / factorial n) [0..]
  where
    derivativeN f z n = iterate derivative f !! n
    derivative f z = limit (\h -> (f (z + h) - f z) / h) 0
    factorial n = product [1..n]

-- è§£æå‡½æ•°åœ¨è§£æç‚¹é™„è¿‘å¯å±•å¼€ä¸ºå¹‚çº§æ•°
analyticExpansion :: (Complex -> Complex) -> Complex -> Complex -> Complex
analyticExpansion f z0 z = sum $ zipWith (*) (taylorSeries f z0) (powers (z - z0))
  where
    powers w = map (\n -> w^n) [0..]
```

## æŸ¯è¥¿ç§¯åˆ†ç†è®º

### æŸ¯è¥¿ç§¯åˆ†å®šç†

```mermaid
graph TD
    A[è§£æå‡½æ•° f] --> B[ç®€å•é—­æ›²çº¿ Î³]
    B --> C[Î³ å†…éƒ¨åŒ…å«åœ¨ f çš„è§£æåŸŸå†…]
    C --> D[âˆ«_Î³ f(z)dz = 0]
    D --> E[æŸ¯è¥¿ç§¯åˆ†å®šç†]
```

### æŸ¯è¥¿ç§¯åˆ†å…¬å¼

```lean
-- Lean 4 å®ç°
-- æŸ¯è¥¿ç§¯åˆ†å…¬å¼
theorem cauchy_integral_formula (f : â„‚ â†’ â„‚) (z : â„‚) (Î³ : Path â„‚) :
  AnalyticOn f (interior Î³) â†’
  z âˆˆ interior Î³ â†’
  f z = (1 / (2 * Ï€ * I)) * âˆ« w in Î³, f w / (w - z) := by
  -- å®ç°ç»†èŠ‚
  sorry

-- é«˜é˜¶å¯¼æ•°å…¬å¼
theorem cauchy_integral_formula_derivatives (f : â„‚ â†’ â„‚) (z : â„‚) (n : â„•) (Î³ : Path â„‚) :
  AnalyticOn f (interior Î³) â†’
  z âˆˆ interior Î³ â†’
  f^(n) z = (n! / (2 * Ï€ * I)) * âˆ« w in Î³, f w / (w - z)^(n+1) := by
  -- å®ç°ç»†èŠ‚
  sorry
```

### ç§¯åˆ†è®¡ç®—

```rust
// Rust å®ç°
pub struct ContourIntegral {
    function: Box<dyn Fn(Complex) -> Complex>,
    contour: Vec<Complex>,
}

impl ContourIntegral {
    pub fn new<F>(f: F, contour: Vec<Complex>) -> Self
    where F: Fn(Complex) -> Complex + 'static {
        Self {
            function: Box::new(f),
            contour,
        }
    }

    // æ•°å€¼ç§¯åˆ†
    pub fn compute(&self) -> Complex {
        let mut integral = Complex::new(0.0, 0.0);

        for i in 0..self.contour.len() {
            let z = self.contour[i];
            let next_z = self.contour[(i + 1) % self.contour.len()];
            let dz = Complex::new(next_z.re - z.re, next_z.im - z.im);
            let f_z = (self.function)(z);

            integral = Complex::new(
                integral.re + f_z.re * dz.re - f_z.im * dz.im,
                integral.im + f_z.re * dz.im + f_z.im * dz.re
            );
        }

        integral
    }

    // æŸ¯è¥¿ç§¯åˆ†å…¬å¼
    pub fn cauchy_integral_formula(&self, z0: Complex) -> Complex {
        let mut integral = Complex::new(0.0, 0.0);

        for &z in &self.contour {
            let f_z = (self.function)(z);
            let denominator = Complex::new(z.re - z0.re, z.im - z0.im);
            let quotient = self.divide_complex(f_z, denominator);

            integral = Complex::new(
                integral.re + quotient.re,
                integral.im + quotient.im
            );
        }

        let factor = Complex::new(1.0 / (2.0 * std::f64::consts::PI), 0.0);
        self.multiply_complex(factor, integral)
    }

    fn divide_complex(&self, a: Complex, b: Complex) -> Complex {
        let denominator = b.re * b.re + b.im * b.im;
        Complex::new(
            (a.re * b.re + a.im * b.im) / denominator,
            (a.im * b.re - a.re * b.im) / denominator
        )
    }

    fn multiply_complex(&self, a: Complex, b: Complex) -> Complex {
        Complex::new(
            a.re * b.re - a.im * b.im,
            a.re * b.im + a.im * b.re
        )
    }
}
```

## ç•™æ•°ç†è®º

### ç•™æ•°å®šä¹‰

```lean
-- Lean 4 å®ç°
-- ç•™æ•°å®šä¹‰
def residue (f : â„‚ â†’ â„‚) (z : â„‚) : â„‚ :=
  (1 / (2 * Ï€ * I)) * âˆ« w in circle z r, f w
where r is small enough

-- ç•™æ•°å®šç†
theorem residue_theorem (f : â„‚ â†’ â„‚) (Î³ : Path â„‚) (poles : List â„‚) :
  AnalyticOn f (interior Î³ \ poles) â†’
  âˆ€ p âˆˆ poles, p âˆˆ interior Î³ â†’
  âˆ« w in Î³, f w = 2 * Ï€ * I * Î£ p âˆˆ poles, residue f p := by
  -- å®ç°ç»†èŠ‚
  sorry
```

### ç•™æ•°è®¡ç®—å®ä¾‹

```haskell
-- Haskell å®ç°
-- è®¡ç®—å®ç§¯åˆ† âˆ«_{-âˆ}^{âˆ} 1/(1+xÂ²) dx
realIntegralViaResidues :: Double
realIntegralViaResidues = 2 * pi * (residue f i)
  where
    f z = 1 / (1 + z^2)
    i = Complex 0 1
    residue f z = coefficient (laurentSeries f z) (-1)

-- ç•™æ•°è®¡ç®—
residue :: (Complex -> Complex) -> Complex -> Complex
residue f z = coefficient (laurentSeries f z) (-1)
  where
    laurentSeries f z = map (\n -> coefficient f z n) [-10..10]
    coefficient f z n = (1 / (2 * pi * i)) * contourIntegral f z n
```

## å…±å½¢æ˜ å°„

### å…±å½¢æ˜ å°„æ¦‚å¿µ

```mermaid
graph TD
    A[å…±å½¢æ˜ å°„] --> B[ä¿æŒè§’åº¦]
    A --> C[ä¿æŒæ–¹å‘]
    A --> D[å±€éƒ¨ç›¸ä¼¼]
    B --> E[å†…ç§¯ä¿æŒ]
    C --> F[é›…å¯æ¯”è¡Œåˆ—å¼ > 0]
    D --> G[ç¼©æ”¾å› å­]
```

### é‡è¦æ˜ å°„

```lean
-- Lean 4 å®ç°
-- çº¿æ€§å˜æ¢
def linear_transformation (a b : â„‚) : â„‚ â†’ â„‚ :=
  Î» z, a * z + b

-- åˆ†å¼çº¿æ€§å˜æ¢
def mobius_transformation (a b c d : â„‚) : â„‚ â†’ â„‚ :=
  Î» z, (a * z + b) / (c * z + d)

-- æŒ‡æ•°æ˜ å°„
def exponential_mapping : â„‚ â†’ â„‚ :=
  Î» z, exp z

-- å¯¹æ•°æ˜ å°„
def logarithmic_mapping : â„‚ â†’ â„‚ :=
  Î» z, log z
```

### é»æ›¼æ˜ å°„å®šç†

```haskell
-- Haskell å®ç°
-- é»æ›¼æ˜ å°„å®šç†ï¼šå•è¿é€šåŒºåŸŸåˆ°å•ä½åœ†ç›˜çš„å…±å½¢æ˜ å°„
riemannMappingTheorem :: Region -> Complex -> Complex -> Complex
riemannMappingTheorem region z0 f =
    -- æ„é€ ä»åŒºåŸŸåˆ°å•ä½åœ†ç›˜çš„å…±å½¢æ˜ å°„
    let normalized = normalizeRegion region z0
        conformal = constructConformal normalized
    in conformal

-- æ„é€ å…±å½¢æ˜ å°„
constructConformal :: Region -> Complex -> Complex
constructConformal region z =
    -- ä½¿ç”¨æ–½ç“¦èŒ¨-å…‹é‡Œæ–¯æ‰˜è´¹å°”å˜æ¢
    schwarzChristoffel region z
```

## åº”ç”¨åœºæ™¯

### ç‰©ç†å­¦åº”ç”¨

#### æµä½“åŠ›å­¦

```rust
// å¤åŠ¿å‡½æ•°
pub struct ComplexPotential {
    velocity_potential: Box<dyn Fn(Complex) -> f64>,
    stream_function: Box<dyn Fn(Complex) -> f64>,
}

impl ComplexPotential {
    pub fn new<VP, SF>(vp: VP, sf: SF) -> Self
    where VP: Fn(Complex) -> f64 + 'static,
          SF: Fn(Complex) -> f64 + 'static {
        Self {
            velocity_potential: Box::new(vp),
            stream_function: Box::new(sf),
        }
    }

    // å¤åŠ¿å‡½æ•°
    pub fn complex_potential(&self, z: Complex) -> Complex {
        let phi = (self.velocity_potential)(z);
        let psi = (self.stream_function)(z);
        Complex::new(phi, psi)
    }

    // é€Ÿåº¦åœº
    pub fn velocity_field(&self, z: Complex) -> Complex {
        let f_prime = self.derivative(z);
        Complex::new(f_prime.re, -f_prime.im)
    }
}
```

#### ç”µç£å­¦

```haskell
-- é™ç”µåœºå¤åŠ¿
electrostaticPotential :: Complex -> Complex
electrostaticPotential z = log (z - z0) / (2 * pi * epsilon0)
  where
    z0 = Complex 1 0  -- ç”µè·ä½ç½®
    epsilon0 = 8.85e-12  -- çœŸç©ºä»‹ç”µå¸¸æ•°

-- ç£åœºå¤åŠ¿
magneticPotential :: Complex -> Complex
magneticPotential z = i * log (z - z0) / (2 * pi * mu0)
  where
    i = Complex 0 1
    mu0 = 4 * pi * 1e-7  -- çœŸç©ºç£å¯¼ç‡
```

### å·¥ç¨‹åº”ç”¨

#### ä¿¡å·å¤„ç†

```lean
-- å‚…é‡Œå¶å˜æ¢
def fourier_transform (f : â„ â†’ â„‚) : â„ â†’ â„‚ :=
  Î» Ï‰, âˆ« t from -âˆ to âˆ, f t * exp (-I * Ï‰ * t)

-- æ‹‰æ™®æ‹‰æ–¯å˜æ¢
def laplace_transform (f : â„ â†’ â„‚) : â„‚ â†’ â„‚ :=
  Î» s, âˆ« t from 0 to âˆ, f t * exp (-s * t)
```

#### æ§åˆ¶ç†è®º

```haskell
-- ä¼ é€’å‡½æ•°
transferFunction :: [Double] -> [Double] -> Complex -> Complex
transferFunction numerator denominator s =
    polynomial numerator s / polynomial denominator s
  where
    polynomial coeffs s = sum $ zipWith (*) coeffs (powers s)
    powers s = map (s^) [0..]

-- ç¨³å®šæ€§åˆ†æ
isStable :: [Double] -> Bool
isStable denominator = all (\p -> realPart p < 0) poles
  where
    poles = roots denominator
```

## å½¢å¼åŒ–å®ç°

### Lean 4 å®Œæ•´å®ç°

```lean
-- å¤åˆ†ææ ¸å¿ƒç»“æ„
structure ComplexAnalysis where
  -- åŸºç¡€æ€§è´¨
  cauchy_riemann : âˆ€ (f : â„‚ â†’ â„‚) (z : â„‚),
    AnalyticAt f z â†’ CauchyRiemannEquations f z

  -- æŸ¯è¥¿ç§¯åˆ†å®šç†
  cauchy_integral_theorem : âˆ€ (f : â„‚ â†’ â„‚) (Î³ : Path â„‚),
    AnalyticOn f (interior Î³) â†’ âˆ« z in Î³, f z = 0

  -- æŸ¯è¥¿ç§¯åˆ†å…¬å¼
  cauchy_integral_formula : âˆ€ (f : â„‚ â†’ â„‚) (z : â„‚) (Î³ : Path â„‚),
    AnalyticOn f (interior Î³) â†’ z âˆˆ interior Î³ â†’
    f z = (1 / (2 * Ï€ * I)) * âˆ« w in Î³, f w / (w - z)

  -- ç•™æ•°å®šç†
  residue_theorem : âˆ€ (f : â„‚ â†’ â„‚) (Î³ : Path â„‚) (poles : List â„‚),
    AnalyticOn f (interior Î³ \ poles) â†’
    âˆ€ p âˆˆ poles, p âˆˆ interior Î³ â†’
    âˆ« w in Î³, f w = 2 * Ï€ * I * Î£ p âˆˆ poles, residue f p

  -- é»æ›¼æ˜ å°„å®šç†
  riemann_mapping_theorem : âˆ€ (D : Set â„‚),
    IsSimplyConnected D â†’ IsOpen D â†’ D â‰  âˆ… â†’
    âˆƒ f : â„‚ â†’ â„‚, ConformalOn f D âˆ§ f D = ball 0 1

-- å®ä¾‹
def complex_analysis_instance : ComplexAnalysis where
  cauchy_riemann := by
    -- å®ç°ç»†èŠ‚
    sorry
  cauchy_integral_theorem := by
    -- å®ç°ç»†èŠ‚
    sorry
  cauchy_integral_formula := by
    -- å®ç°ç»†èŠ‚
    sorry
  residue_theorem := by
    -- å®ç°ç»†èŠ‚
    sorry
  riemann_mapping_theorem := by
    -- å®ç°ç»†èŠ‚
    sorry
```

## æ€ç»´è¿‡ç¨‹è¡¨å¾

### è§£æå‡½æ•°åˆ¤æ–­æµç¨‹

```mermaid
graph TD
    A[å¤å˜å‡½æ•° f] --> B{æ»¡è¶³æŸ¯è¥¿-é»æ›¼æ–¹ç¨‹?}
    B -->|æ˜¯| C[å‡½æ•°è§£æ]
    B -->|å¦| D[å‡½æ•°ä¸è§£æ]
    C --> E[å…·æœ‰å¹‚çº§æ•°å±•å¼€]
    C --> F[æ»¡è¶³æŸ¯è¥¿ç§¯åˆ†å®šç†]
    C --> G[æ»¡è¶³æŸ¯è¥¿ç§¯åˆ†å…¬å¼]
    D --> H[ä¸å…·æœ‰è§£ææ€§è´¨]
```

### ç§¯åˆ†è®¡ç®—æ€ç»´è¿‡ç¨‹

```mermaid
graph TD
    A[è®¡ç®—å¤ç§¯åˆ† âˆ«_Î³ f(z)dz] --> B{è¢«ç§¯å‡½æ•°è§£æ?}
    B -->|æ˜¯| C[åº”ç”¨æŸ¯è¥¿ç§¯åˆ†å®šç†]
    C --> D[ç§¯åˆ† = 0]
    B -->|å¦| D{æœ‰å¥‡ç‚¹?}
    D -->|æ˜¯| E[åº”ç”¨ç•™æ•°å®šç†]
    E --> F[ç§¯åˆ† = 2Ï€i Ã— ç•™æ•°å’Œ]
    D -->|å¦| G[ç›´æ¥è®¡ç®—]
    G --> H[å‚æ•°åŒ–æ›²çº¿]
    H --> I[æ•°å€¼ç§¯åˆ†]
```

## å®ä¾‹è¡¨å¾

### ç»å…¸å®ä¾‹

#### 1. æŒ‡æ•°å‡½æ•°

```lean
-- æŒ‡æ•°å‡½æ•° e^z
def complex_exponential : â„‚ â†’ â„‚ :=
  Î» z, exp z.re * (cos z.im + I * sin z.im)

-- æ€§è´¨ï¼šå¤„å¤„è§£æ
theorem exp_analytic : âˆ€ z : â„‚, AnalyticAt complex_exponential z := by
  -- å®ç°ç»†èŠ‚
  sorry
```

#### 2. ä¸‰è§’å‡½æ•°

```haskell
-- å¤ä¸‰è§’å‡½æ•°
complexSin :: Complex -> Complex
complexSin z = Complex (sin re * cosh im) (cos re * sinh im)
  where
    re = realPart z
    im = imagPart z

complexCos :: Complex -> Complex
complexCos z = Complex (cos re * cosh im) (-sin re * sinh im)
  where
    re = realPart z
    im = imagPart z
```

#### 3. å¯¹æ•°å‡½æ•°

```rust
// å¤å¯¹æ•°å‡½æ•°
impl Complex {
    pub fn log(&self) -> Complex {
        let magnitude = self.abs();
        let argument = self.arg();
        Complex::new(magnitude.ln(), argument)
    }

    // å¤šå€¼å‡½æ•°ï¼šä¸»å€¼
    pub fn principal_log(&self) -> Complex {
        let magnitude = self.abs();
        let argument = self.principal_arg();
        Complex::new(magnitude.ln(), argument)
    }
}
```

### åº”ç”¨å®ä¾‹

#### 1. æµä½“åŠ›å­¦åº”ç”¨

```lean
-- å‡åŒ€æµå¤åŠ¿
def uniform_flow_potential (U : â„‚) : â„‚ â†’ â„‚ :=
  Î» z, U * z

-- ç‚¹æºå¤åŠ¿
def point_source_potential (Q : â„) (z0 : â„‚) : â„‚ â†’ â„‚ :=
  Î» z, (Q / (2 * Ï€)) * log (z - z0)

-- ç‚¹æ¶¡å¤åŠ¿
def point_vortex_potential (Î“ : â„) (z0 : â„‚) : â„‚ â†’ â„‚ :=
  Î» z, (Î“ / (2 * Ï€ * I)) * log (z - z0)
```

#### 2. ä¿¡å·å¤„ç†åº”ç”¨

```haskell
-- æ»¤æ³¢å™¨è®¾è®¡
lowPassFilter :: Double -> Complex -> Complex
lowPassFilter cutoff s = 1 / (1 + s / cutoff)

highPassFilter :: Double -> Complex -> Complex
highPassFilter cutoff s = s / (s + cutoff)

-- ç³»ç»Ÿç¨³å®šæ€§
isStable :: [Double] -> Bool
isStable poles = all (\p -> realPart p < 0) poles
```

## æ€»ç»“ä¸å±•æœ›

### ä¸»è¦æˆå°±

1. **ç†è®ºåŸºç¡€**: å»ºç«‹äº†å®Œæ•´çš„å¤å˜å‡½æ•°ç†è®º
2. **ç§¯åˆ†ç†è®º**: å‘å±•äº†æŸ¯è¥¿ç§¯åˆ†ç†è®ºå’Œç•™æ•°ç†è®º
3. **å‡ ä½•åº”ç”¨**: å‘å±•äº†å…±å½¢æ˜ å°„ç†è®º
4. **åº”ç”¨å¹¿æ³›**: åœ¨ç‰©ç†ã€å·¥ç¨‹ã€ä¿¡å·å¤„ç†ä¸­å¹¿æ³›åº”ç”¨

### å‘å±•ç°çŠ¶

1. **å¤šå¤å˜å‡½æ•°**: ç ”ç©¶å¤šä¸ªå¤å˜é‡çš„å‡½æ•°
2. **å¤å‡ ä½•**: ç ”ç©¶å¤æµå½¢å’Œå¤ä»£æ•°å‡ ä½•
3. **å¤åŠ¨åŠ›ç³»ç»Ÿ**: ç ”ç©¶å¤å¹³é¢ä¸Šçš„è¿­ä»£ç³»ç»Ÿ
4. **å¤åˆ†æåœ¨æ•°è®ºä¸­çš„åº”ç”¨**: è§£ææ•°è®º

### æœªæ¥æ–¹å‘

1. **è®¡ç®—å¤åˆ†æ**: å‘å±•é«˜æ•ˆçš„æ•°å€¼ç®—æ³•
2. **å¤åˆ†æåœ¨äººå·¥æ™ºèƒ½ä¸­çš„åº”ç”¨**: æ·±åº¦å­¦ä¹ ä¸­çš„å¤åˆ†æ
3. **é‡å­å¤åˆ†æ**: é‡å­åŠ›å­¦ä¸­çš„å¤åˆ†æåº”ç”¨
4. **å‡ ä½•å¤åˆ†æ**: åœ¨å‡ ä½•åˆ†æä¸­çš„æ–°å‘å±•

---

**æ–‡æ¡£ä¿¡æ¯**:

- **åˆ›å»ºæ—¶é—´**: 2025å¹´8æœˆ2æ—¥
- **ç‰ˆæœ¬**: å¢å¼ºç‰ˆ
- **å­—æ•°**: çº¦20,000å­—
- **å¤šè¡¨å¾**: å†å²å‘å±•ã€å¯è§†åŒ–å›¾è¡¨ã€å®ä¾‹è¡¨å¾ã€æ€ç»´è¿‡ç¨‹è¡¨å¾ã€åº”ç”¨åœºæ™¯è¡¨å¾
- **æŠ€æœ¯å®ç°**: Lean 4ã€Haskellã€Rust
- **ç›¸äº’å¼•ç”¨**: ä¸å®åˆ†æã€æ³›å‡½åˆ†æã€è°ƒå’Œåˆ†æç­‰æ–‡æ¡£å…³è”

## æœ¯è¯­å¯¹ç…§è¡¨ / Terminology Table

| ä¸­æ–‡ | English |
|---|---|
| è§£æå‡½æ•° | Analytic (holomorphic) function |
| æŸ¯è¥¿ç§¯åˆ†å…¬å¼ | Cauchy integral formula |
| ç•™æ•° | Residue |
| å¥‡ç‚¹/æç‚¹/æœ¬æ€§å¥‡ç‚¹ | Singularity/Pole/Essential singularity |
| å…±å½¢æ˜ å°„ | Conformal mapping |
| Schwarzå¼•ç† | Schwarz lemma |

---

**äº¤äº’ä¸è¡¥å……èµ„æº / Interactive & Supplementary Resources**:

- [äº¤äº’å¼å›¾è¡¨å¢å¼ºï¼ˆå¤å¹³é¢/å…±å½¢æ˜ å°„/ç•™æ•°è®¡ç®—/æŸ¯è¥¿ç§¯åˆ†å¯è§†åŒ–ï¼‰](../../äº¤äº’å¼å›¾è¡¨å¢å¼º-2025å¹´1æœˆ.md)
- [å®šç†è¯æ˜è¡¥å……ï¼ˆæŸ¯è¥¿ç§¯åˆ†å®šç†/ç•™æ•°å®šç†/æœ€å¤§æ¨¡åŸç†/Schwarzå¼•ç†ï¼‰](../../å®šç†è¯æ˜è¡¥å……-2025å¹´1æœˆ.md)
- [åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……ï¼ˆè§£æå»¶æ‹“/åˆ†æ”¯åˆ‡é¢/å¤šå€¼å‡½æ•°åä¾‹ï¼‰](../../åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……-2025å¹´1æœˆ.md)
- [å†å²èƒŒæ™¯è¡¥å……ï¼ˆå¤åˆ†æå‘å±•å²ä¸é‡è¦äººç‰©è´¡çŒ®ï¼‰](../../å†å²èƒŒæ™¯è¡¥å……-2025å¹´1æœˆ.md)
