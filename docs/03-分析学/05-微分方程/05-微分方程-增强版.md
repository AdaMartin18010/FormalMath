# å¾®åˆ†æ–¹ç¨‹ - å¢å¼ºç‰ˆ

## ğŸ“‹ ç›®å½•

- [å¾®åˆ†æ–¹ç¨‹ - å¢å¼ºç‰ˆ](#å¾®åˆ†æ–¹ç¨‹---å¢å¼ºç‰ˆ)
  - [ğŸ“‹ ç›®å½•](#-ç›®å½•)
  - [æ¦‚è¿°](#æ¦‚è¿°)
    - [æ ¸å¿ƒç‰¹å¾](#æ ¸å¿ƒç‰¹å¾)
  - [å†å²å‘å±•è„‰ç»œ](#å†å²å‘å±•è„‰ç»œ)
    - [æ—©æœŸå‘å±• (17-18ä¸–çºª)](#æ—©æœŸå‘å±•-17-18ä¸–çºª)
      - [é‡è¦äººç‰©è´¡çŒ®](#é‡è¦äººç‰©è´¡çŒ®)
    - [ç°ä»£å‘å±• (19-20ä¸–çºª)](#ç°ä»£å‘å±•-19-20ä¸–çºª)
      - [å†å²æˆå°±](#å†å²æˆå°±)
  - [å¸¸å¾®åˆ†æ–¹ç¨‹](#å¸¸å¾®åˆ†æ–¹ç¨‹)
    - [åŸºæœ¬æ¦‚å¿µ](#åŸºæœ¬æ¦‚å¿µ)
    - [ä¸€é˜¶æ–¹ç¨‹](#ä¸€é˜¶æ–¹ç¨‹)
    - [é«˜é˜¶æ–¹ç¨‹](#é«˜é˜¶æ–¹ç¨‹)
  - [åå¾®åˆ†æ–¹ç¨‹](#åå¾®åˆ†æ–¹ç¨‹)
    - [åŸºæœ¬ç±»å‹](#åŸºæœ¬ç±»å‹)
    - [æ¤­åœ†æ–¹ç¨‹](#æ¤­åœ†æ–¹ç¨‹)
    - [æŠ›ç‰©æ–¹ç¨‹](#æŠ›ç‰©æ–¹ç¨‹)
    - [åŒæ›²æ–¹ç¨‹](#åŒæ›²æ–¹ç¨‹)
  - [åŠ¨åŠ›ç³»ç»Ÿ](#åŠ¨åŠ›ç³»ç»Ÿ)
    - [åŠ¨åŠ›ç³»ç»Ÿæ¦‚å¿µ](#åŠ¨åŠ›ç³»ç»Ÿæ¦‚å¿µ)
    - [çº¿æ€§ç³»ç»Ÿ](#çº¿æ€§ç³»ç»Ÿ)
    - [éçº¿æ€§ç³»ç»Ÿ](#éçº¿æ€§ç³»ç»Ÿ)
  - [æ•°å€¼æ–¹æ³•](#æ•°å€¼æ–¹æ³•)
    - [å¸¸å¾®åˆ†æ–¹ç¨‹æ•°å€¼æ–¹æ³•](#å¸¸å¾®åˆ†æ–¹ç¨‹æ•°å€¼æ–¹æ³•)
    - [åå¾®åˆ†æ–¹ç¨‹æ•°å€¼æ–¹æ³•](#åå¾®åˆ†æ–¹ç¨‹æ•°å€¼æ–¹æ³•)
  - [åº”ç”¨åœºæ™¯](#åº”ç”¨åœºæ™¯)
    - [ç‰©ç†å­¦åº”ç”¨](#ç‰©ç†å­¦åº”ç”¨)
      - [ç»å…¸åŠ›å­¦](#ç»å…¸åŠ›å­¦)
      - [é‡å­åŠ›å­¦](#é‡å­åŠ›å­¦)
    - [ç”Ÿç‰©å­¦åº”ç”¨](#ç”Ÿç‰©å­¦åº”ç”¨)
      - [ç§ç¾¤åŠ¨åŠ›å­¦](#ç§ç¾¤åŠ¨åŠ›å­¦)
    - [ç»æµå­¦åº”ç”¨](#ç»æµå­¦åº”ç”¨)
      - [ç»æµå¢é•¿æ¨¡å‹](#ç»æµå¢é•¿æ¨¡å‹)
  - [å½¢å¼åŒ–å®ç°](#å½¢å¼åŒ–å®ç°)
    - [Lean 4 å®Œæ•´å®ç°](#lean-4-å®Œæ•´å®ç°)
  - [æ€ç»´è¿‡ç¨‹è¡¨å¾](#æ€ç»´è¿‡ç¨‹è¡¨å¾)
    - [å¾®åˆ†æ–¹ç¨‹æ±‚è§£æ€ç»´è¿‡ç¨‹](#å¾®åˆ†æ–¹ç¨‹æ±‚è§£æ€ç»´è¿‡ç¨‹)
    - [æ•°å€¼æ–¹æ³•é€‰æ‹©æ€ç»´è¿‡ç¨‹](#æ•°å€¼æ–¹æ³•é€‰æ‹©æ€ç»´è¿‡ç¨‹)
  - [å®ä¾‹è¡¨å¾](#å®ä¾‹è¡¨å¾)
    - [ç»å…¸å®ä¾‹](#ç»å…¸å®ä¾‹)
      - [1. ç®€è°è¿åŠ¨](#1-ç®€è°è¿åŠ¨)
      - [2. çƒ­ä¼ å¯¼æ–¹ç¨‹](#2-çƒ­ä¼ å¯¼æ–¹ç¨‹)
      - [3. æ´›ä¼¦å…¹ç³»ç»Ÿ](#3-æ´›ä¼¦å…¹ç³»ç»Ÿ)
    - [åº”ç”¨å®ä¾‹](#åº”ç”¨å®ä¾‹)
      - [1. ç”µè·¯åˆ†æ](#1-ç”µè·¯åˆ†æ)
      - [2. åŒ–å­¦ååº”åŠ¨åŠ›å­¦](#2-åŒ–å­¦ååº”åŠ¨åŠ›å­¦)
  - [æ€»ç»“ä¸å±•æœ›](#æ€»ç»“ä¸å±•æœ›)
    - [ä¸»è¦æˆå°±](#ä¸»è¦æˆå°±)
    - [å‘å±•ç°çŠ¶](#å‘å±•ç°çŠ¶)
    - [æœªæ¥æ–¹å‘](#æœªæ¥æ–¹å‘)

## æ¦‚è¿°

å¾®åˆ†æ–¹ç¨‹æ˜¯æè¿°å˜åŒ–ç‡çš„æ•°å­¦å·¥å…·ï¼Œç ”ç©¶æœªçŸ¥å‡½æ•°åŠå…¶å¯¼æ•°ä¹‹é—´çš„å…³ç³»ã€‚å®ƒæ˜¯æ•°å­¦åˆ†æçš„æ ¸å¿ƒåˆ†æ”¯ï¼Œåœ¨ç‰©ç†ã€å·¥ç¨‹ã€ç”Ÿç‰©å­¦ç­‰é¢†åŸŸæœ‰å¹¿æ³›åº”ç”¨ã€‚

### æ ¸å¿ƒç‰¹å¾

- **å˜åŒ–æ€§**: æè¿°ç³»ç»Ÿéšæ—¶é—´æˆ–ç©ºé—´çš„å˜åŒ–è§„å¾‹
- **é¢„æµ‹æ€§**: é€šè¿‡åˆå§‹æ¡ä»¶é¢„æµ‹ç³»ç»Ÿæœªæ¥è¡Œä¸º
- **å»ºæ¨¡æ€§**: ä¸ºè‡ªç„¶ç°è±¡å»ºç«‹æ•°å­¦æ¨¡å‹
- **åº”ç”¨æ€§**: åœ¨ç§‘å­¦ã€å·¥ç¨‹ã€ç»æµä¸­çš„å¹¿æ³›åº”ç”¨

## å†å²å‘å±•è„‰ç»œ

### æ—©æœŸå‘å±• (17-18ä¸–çºª)

```mermaid
timeline
    title å¾®åˆ†æ–¹ç¨‹å†å²å‘å±•
    1671å¹´ : ç‰›é¡¿å‘æ˜æµæ•°æ³•
    1687å¹´ : ç‰›é¡¿ã€Šè‡ªç„¶å“²å­¦çš„æ•°å­¦åŸç†ã€‹
    1693å¹´ : è±å¸ƒå°¼èŒ¨å»ºç«‹å¾®åˆ†ç¬¦å·
    1743å¹´ : æ¬§æ‹‰ç ”ç©¶å¸¸å¾®åˆ†æ–¹ç¨‹
    1750å¹´ : è¾¾æœ—è´å°”ç ”ç©¶æ³¢åŠ¨æ–¹ç¨‹
    19ä¸–çºª : åå¾®åˆ†æ–¹ç¨‹ç†è®ºå‘å±•
```

#### é‡è¦äººç‰©è´¡çŒ®

| äººç‰© | æ—¶æœŸ | ä¸»è¦è´¡çŒ® |
|------|------|----------|
| ç‰›é¡¿ | 1671-1687 | æµæ•°æ³•ï¼Œè¿åŠ¨å®šå¾‹ |
| è±å¸ƒå°¼èŒ¨ | 1693 | å¾®åˆ†ç¬¦å·ï¼Œç§¯åˆ†æ–¹æ³• |
| æ¬§æ‹‰ | 1743 | å¸¸å¾®åˆ†æ–¹ç¨‹ç†è®º |
| è¾¾æœ—è´å°” | 1750 | æ³¢åŠ¨æ–¹ç¨‹ï¼Œåˆ†ç¦»å˜é‡æ³• |
| æ‹‰æ ¼æœ—æ—¥ | 1760-1780 | å˜åˆ†æ³•ï¼Œæ‹‰æ ¼æœ—æ—¥æ–¹ç¨‹ |
| æ‹‰æ™®æ‹‰æ–¯ | 1780-1800 | æ‹‰æ™®æ‹‰æ–¯æ–¹ç¨‹ï¼Œå˜æ¢æ–¹æ³• |
| å‚…é‡Œå¶ | 1822 | çƒ­ä¼ å¯¼æ–¹ç¨‹ï¼Œå‚…é‡Œå¶æ–¹æ³• |

### ç°ä»£å‘å±• (19-20ä¸–çºª)

#### å†å²æˆå°±

1. **å­˜åœ¨å”¯ä¸€æ€§ç†è®º**: æŸ¯è¥¿-çš®å¡å¾·å®šç†ï¼Œææ™®å¸ŒèŒ¨æ¡ä»¶
2. **å®šæ€§ç†è®º**: ç›¸ç©ºé—´åˆ†æï¼Œç¨³å®šæ€§ç†è®º
3. **æ•°å€¼æ–¹æ³•**: é¾™æ ¼-åº“å¡”æ–¹æ³•ï¼Œæœ‰é™å…ƒæ–¹æ³•
4. **åŠ¨åŠ›ç³»ç»Ÿ**: æ··æ²Œç†è®ºï¼Œåˆ†å²”ç†è®º

## å¸¸å¾®åˆ†æ–¹ç¨‹

### åŸºæœ¬æ¦‚å¿µ

```lean
-- Lean 4 å®ç°
-- å¸¸å¾®åˆ†æ–¹ç¨‹
def ordinary_differential_equation (f : â„ â†’ â„ â†’ â„) : Prop :=
  âˆ€ t, y' t = f t (y t)

-- åˆå€¼é—®é¢˜
def initial_value_problem (f : â„ â†’ â„ â†’ â„) (tâ‚€ yâ‚€ : â„) : Prop :=
  y' t = f t (y t) âˆ§ y tâ‚€ = yâ‚€

-- è§£çš„å­˜åœ¨å”¯ä¸€æ€§
theorem cauchy_picard_theorem (f : â„ â†’ â„ â†’ â„) (tâ‚€ yâ‚€ : â„) :
  IsLipschitz f â†’ âˆƒ! y, initial_value_problem f tâ‚€ yâ‚€ y := by
  -- å®ç°ç»†èŠ‚
  sorry

-- ææ™®å¸ŒèŒ¨æ¡ä»¶
def is_lipschitz (f : â„ â†’ â„ â†’ â„) : Prop :=
  âˆƒ L > 0, âˆ€ t yâ‚ yâ‚‚, |f t yâ‚ - f t yâ‚‚| â‰¤ L * |yâ‚ - yâ‚‚|
```

### ä¸€é˜¶æ–¹ç¨‹

```haskell
-- Haskell å®ç°
-- å¯åˆ†ç¦»å˜é‡æ–¹ç¨‹
separableEquation :: (Double -> Double) -> (Double -> Double) -> Double -> Double -> Double
separableEquation g h x0 y0 = 
    let integral_g = integrate g x0
        integral_h = integrate h y0
        solution = solveForY integral_g integral_h
    in solution

-- çº¿æ€§æ–¹ç¨‹
linearEquation :: (Double -> Double) -> (Double -> Double) -> Double -> Double -> Double
linearEquation p q x0 y0 = 
    let integrating_factor = exp (integrate p x0)
        particular_solution = integrate (\x -> q x * integrating_factor x) x0
        homogeneous_solution = y0 * exp (-integrate p x0)
    in homogeneous_solution + particular_solution / integrating_factor x0

-- ä¼¯åŠªåˆ©æ–¹ç¨‹
bernoulliEquation :: Double -> (Double -> Double) -> (Double -> Double) -> Double -> Double -> Double
bernoulliEquation n p q x0 y0 = 
    let substitution = y^(1-n)
        linear_eq = substitution' + (1-n) * p * substitution = (1-n) * q
        solution = solveLinear linear_eq x0 (y0^(1-n))
    in solution^(1/(1-n))
```

### é«˜é˜¶æ–¹ç¨‹

```rust
// Rust å®ç°
pub struct DifferentialEquation {
    order: usize,
    coefficients: Vec<Box<dyn Fn(f64) -> f64>>,
    inhomogeneous_term: Box<dyn Fn(f64) -> f64>,
}

impl DifferentialEquation {
    pub fn new<F>(order: usize, coefficients: Vec<Box<dyn Fn(f64) -> f64>>, 
                   inhomogeneous: F) -> Self 
    where F: Fn(f64) -> f64 + 'static {
        Self {
            order,
            coefficients,
            inhomogeneous_term: Box::new(inhomogeneous),
        }
    }
    
    // ç‰¹å¾æ–¹ç¨‹
    pub fn characteristic_equation(&self) -> Vec<f64> {
        // å¯¹äºå¸¸ç³»æ•°æ–¹ç¨‹ï¼Œæ±‚è§£ç‰¹å¾æ–¹ç¨‹
        let mut roots = Vec::new();
        let coefficients: Vec<f64> = self.coefficients.iter()
            .map(|f| f(0.0)).collect();
        
        // ä½¿ç”¨æ•°å€¼æ–¹æ³•æ±‚è§£ç‰¹å¾æ ¹
        self.find_roots(&coefficients)
    }
    
    // é€šè§£
    pub fn general_solution(&self, x: f64) -> f64 {
        let roots = self.characteristic_equation();
        let mut solution = 0.0;
        
        // é½æ¬¡è§£
        for &root in &roots {
            if root.im == 0.0 {
                solution += self.homogeneous_term_real(root.re, x);
            } else {
                solution += self.homogeneous_term_complex(root, x);
            }
        }
        
        // ç‰¹è§£
        solution + self.particular_solution(x)
    }
    
    fn homogeneous_term_real(&self, root: f64, x: f64) -> f64 {
        // å®æ ¹å¯¹åº”çš„é½æ¬¡è§£é¡¹
        let multiplicity = self.get_multiplicity(root);
        match multiplicity {
            1 => x.exp() * root,
            n => x.powi(n as i32) * x.exp() * root,
        }
    }
    
    fn homogeneous_term_complex(&self, root: Complex<f64>, x: f64) -> f64 {
        // å¤æ ¹å¯¹åº”çš„é½æ¬¡è§£é¡¹
        let real_part = root.re;
        let imag_part = root.im;
        x.exp() * real_part * (imag_part * x).cos()
    }
    
    fn particular_solution(&self, x: f64) -> f64 {
        // ä½¿ç”¨å¾…å®šç³»æ•°æ³•æˆ–å˜åˆ†å¸¸æ•°æ³•æ±‚ç‰¹è§£
        // ç®€åŒ–å®ç°
        (self.inhomogeneous_term)(x)
    }
}
```

## åå¾®åˆ†æ–¹ç¨‹

### åŸºæœ¬ç±»å‹

```mermaid
graph TD
    A[åå¾®åˆ†æ–¹ç¨‹] --> B[æ¤­åœ†å‹]
    A --> C[æŠ›ç‰©å‹]
    A --> D[åŒæ›²å‹]
    B --> E[æ‹‰æ™®æ‹‰æ–¯æ–¹ç¨‹]
    B --> F[æ³Šæ¾æ–¹ç¨‹]
    C --> G[çƒ­ä¼ å¯¼æ–¹ç¨‹]
    C --> H[æ‰©æ•£æ–¹ç¨‹]
    D --> I[æ³¢åŠ¨æ–¹ç¨‹]
    D --> J[ä¼ è¾“æ–¹ç¨‹]
```

### æ¤­åœ†æ–¹ç¨‹

```lean
-- Lean 4 å®ç°
-- æ‹‰æ™®æ‹‰æ–¯æ–¹ç¨‹
def laplace_equation (u : â„Â² â†’ â„) : Prop :=
  âˆ€ (x y), âˆ‚Â²u/âˆ‚xÂ² (x, y) + âˆ‚Â²u/âˆ‚yÂ² (x, y) = 0

-- æ³Šæ¾æ–¹ç¨‹
def poisson_equation (u : â„Â² â†’ â„) (f : â„Â² â†’ â„) : Prop :=
  âˆ€ (x y), âˆ‚Â²u/âˆ‚xÂ² (x, y) + âˆ‚Â²u/âˆ‚yÂ² (x, y) = f (x, y)

-- ç‹„åˆ©å…‹é›·é—®é¢˜
def dirichlet_problem (Î© : Set â„Â²) (g : â„Â² â†’ â„) : â„Â² â†’ â„ :=
  Î» (x, y), if (x, y) âˆˆ boundary Î© then g (x, y) else
    solve_laplace_equation Î© g (x, y)

-- æœ€å¤§å€¼åŸç†
theorem maximum_principle (u : â„Â² â†’ â„) (Î© : Set â„Â²) :
  harmonic_function u â†’ IsOpen Î© â†’ IsBounded Î© â†’
  âˆ€ (x, y) âˆˆ Î©, u (x, y) â‰¤ sup { u (a, b) | (a, b) âˆˆ boundary Î© } := by
  -- å®ç°ç»†èŠ‚
  sorry
```

### æŠ›ç‰©æ–¹ç¨‹

```haskell
-- Haskell å®ç°
-- çƒ­ä¼ å¯¼æ–¹ç¨‹
heatEquation :: Double -> (Double -> Double) -> (Double -> Double -> Double)
heatEquation alpha initial_condition (x, t) = 
    let fourier_series = fourierSeries initial_condition
        solution = sum $ map (\n -> 
            fourier_series n * exp (-alpha * (n * pi)^2 * t) * sin (n * pi * x)) [1..]
    in solution

-- åˆ†ç¦»å˜é‡æ³•
separationOfVariables :: (Double -> Double) -> (Double -> Double) -> (Double -> Double -> Double)
separationOfVariables f g (x, t) = 
    let x_solution = solveSpaceEquation f x
        t_solution = solveTimeEquation g t
    in x_solution * t_solution

-- æ ¼æ—å‡½æ•°
greenFunction :: Double -> Double -> Double -> Double -> Double
greenFunction x xi t tau = 
    let coefficient = 1 / sqrt (4 * pi * alpha * (t - tau))
        exponential = exp (-(x - xi)^2 / (4 * alpha * (t - tau)))
    in coefficient * exponential
  where
    alpha = 1.0  -- çƒ­æ‰©æ•£ç³»æ•°
```

### åŒæ›²æ–¹ç¨‹

```rust
// Rust å®ç°
pub struct WaveEquation {
    speed: f64,
    initial_displacement: Box<dyn Fn(f64) -> f64>,
    initial_velocity: Box<dyn Fn(f64) -> f64>,
}

impl WaveEquation {
    pub fn new<D, V>(speed: f64, displacement: D, velocity: V) -> Self 
    where D: Fn(f64) -> f64 + 'static,
          V: Fn(f64) -> f64 + 'static {
        Self {
            speed,
            initial_displacement: Box::new(displacement),
            initial_velocity: Box::new(velocity),
        }
    }
    
    // è¾¾æœ—è´å°”è§£
    pub fn d_alembert_solution(&self, x: f64, t: f64) -> f64 {
        let c = self.speed;
        let f = &self.initial_displacement;
        let g = &self.initial_velocity;
        
        // è¾¾æœ—è´å°”å…¬å¼
        let term1 = (f(x + c * t) + f(x - c * t)) / 2.0;
        let term2 = (1.0 / (2.0 * c)) * self.integrate_g(x - c * t, x + c * t);
        
        term1 + term2
    }
    
    fn integrate_g(&self, a: f64, b: f64) -> f64 {
        // æ•°å€¼ç§¯åˆ†
        let n = 1000;
        let dx = (b - a) / n as f64;
        let mut integral = 0.0;
        
        for i in 0..n {
            let x = a + i as f64 * dx;
            integral += (self.initial_velocity)(x) * dx;
        }
        
        integral
    }
    
    // ç‰¹å¾çº¿æ–¹æ³•
    pub fn characteristic_lines(&self, x: f64, t: f64) -> Vec<(f64, f64)> {
        let c = self.speed;
        let mut lines = Vec::new();
        
        // æ­£å‘ç‰¹å¾çº¿
        lines.push((x + c * t, 0.0));
        // è´Ÿå‘ç‰¹å¾çº¿
        lines.push((x - c * t, 0.0));
        
        lines
    }
}
```

## åŠ¨åŠ›ç³»ç»Ÿ

### åŠ¨åŠ›ç³»ç»Ÿæ¦‚å¿µ

```lean
-- Lean 4 å®ç°
-- åŠ¨åŠ›ç³»ç»Ÿ
def dynamical_system (f : â„^n â†’ â„^n) : â„^n â†’ â„ â†’ â„^n :=
  Î» xâ‚€ t, flow f xâ‚€ t

-- æµ
def flow (f : â„^n â†’ â„^n) (xâ‚€ : â„^n) : â„ â†’ â„^n :=
  Î» t, solution_of_ode f xâ‚€ t

-- ç›¸ç©ºé—´
def phase_space (f : â„^n â†’ â„^n) : Set â„^n :=
  { x | âˆƒ t, flow f x t = x }

-- å¹³è¡¡ç‚¹
def equilibrium_point (f : â„^n â†’ â„^n) (x : â„^n) : Prop :=
  f x = 0

-- ç¨³å®šæ€§
def stable_equilibrium (f : â„^n â†’ â„^n) (xâ‚€ : â„^n) : Prop :=
  âˆ€ Îµ > 0, âˆƒ Î´ > 0, âˆ€ x, â€–x - xâ‚€â€– < Î´ â†’ âˆ€ t â‰¥ 0, â€–flow f x t - flow f xâ‚€ tâ€– < Îµ
```

### çº¿æ€§ç³»ç»Ÿ

```haskell
-- Haskell å®ç°
-- çº¿æ€§ç³»ç»Ÿ
linearSystem :: Matrix -> Vector -> Vector -> Vector
linearSystem A x0 t = 
    let eigenvalues = eigenValues A
        eigenvectors = eigenVectors A
        solution = sum $ zipWith3 (\lambda v c -> 
            c * exp (lambda * t) * v) eigenvalues eigenvectors coefficients
        coefficients = solveLinearSystem eigenvectors x0
    in solution

-- ç¨³å®šæ€§åˆ†æ
stabilityAnalysis :: Matrix -> StabilityType
stabilityAnalysis A = 
    let eigenvalues = eigenValues A
        real_parts = map realPart eigenvalues
    in if all (< 0) real_parts then AsymptoticallyStable
       else if any (> 0) real_parts then Unstable
       else MarginallyStable

-- ç›¸å›¾
phasePortrait :: Matrix -> [(Double, Double)] -> [(Double, Double)]
phasePortrait A initial_points = 
    map (\x0 -> trajectory A x0) initial_points
  where
    trajectory A x0 = map (\t -> linearSystem A x0 t) time_points
    time_points = [0, 0.1..10]
```

### éçº¿æ€§ç³»ç»Ÿ

```rust
// Rust å®ç°
pub struct NonlinearSystem {
    vector_field: Box<dyn Fn(&[f64]) -> Vec<f64>>,
}

impl NonlinearSystem {
    pub fn new<F>(vector_field: F) -> Self 
    where F: Fn(&[f64]) -> Vec<f64> + 'static {
        Self {
            vector_field: Box::new(vector_field),
        }
    }
    
    // æ•°å€¼ç§¯åˆ†
    pub fn integrate(&self, initial_state: &[f64], t_final: f64, dt: f64) -> Vec<Vec<f64>> {
        let mut trajectory = Vec::new();
        let mut current_state = initial_state.to_vec();
        let mut t = 0.0;
        
        while t <= t_final {
            trajectory.push(current_state.clone());
            
            // é¾™æ ¼-åº“å¡”æ–¹æ³•
            let k1 = (self.vector_field)(&current_state);
            let k2_state: Vec<f64> = current_state.iter().zip(k1.iter())
                .map(|(x, k)| x + 0.5 * dt * k).collect();
            let k2 = (self.vector_field)(&k2_state);
            
            // æ›´æ–°çŠ¶æ€
            for (i, (x, (k1_val, k2_val))) in current_state.iter_mut()
                .zip(k1.iter().zip(k2.iter())).enumerate() {
                *x += dt * (k1_val + k2_val) / 2.0;
            }
            
            t += dt;
        }
        
        trajectory
    }
    
    // å¹³è¡¡ç‚¹åˆ†æ
    pub fn find_equilibria(&self, domain: &[(f64, f64)]) -> Vec<Vec<f64>> {
        let mut equilibria = Vec::new();
        
        // ä½¿ç”¨ç‰›é¡¿æ³•å¯»æ‰¾å¹³è¡¡ç‚¹
        for x in (0..100).map(|i| domain[0].0 + i as f64 * (domain[0].1 - domain[0].0) / 100.0) {
            for y in (0..100).map(|i| domain[1].0 + i as f64 * (domain[1].1 - domain[1].0) / 100.0) {
                let initial_guess = vec![x, y];
                if let Some(equilibrium) = self.newton_method(&initial_guess) {
                    equilibria.push(equilibrium);
                }
            }
        }
        
        equilibria
    }
    
    fn newton_method(&self, initial_guess: &[f64]) -> Option<Vec<f64>> {
        let mut x = initial_guess.to_vec();
        let tolerance = 1e-10;
        let max_iterations = 100;
        
        for _ in 0..max_iterations {
            let f = (self.vector_field)(&x);
            let jacobian = self.compute_jacobian(&x);
            
            if let Some(inverse) = self.inverse_matrix(&jacobian) {
                let delta = self.matrix_vector_multiply(&inverse, &f);
                for (i, dx) in delta.iter().enumerate() {
                    x[i] -= dx;
                }
                
                if delta.iter().map(|dx| dx.abs()).sum::<f64>() < tolerance {
                    return Some(x);
                }
            } else {
                break;
            }
        }
        
        None
    }
}
```

## æ•°å€¼æ–¹æ³•

### å¸¸å¾®åˆ†æ–¹ç¨‹æ•°å€¼æ–¹æ³•

```lean
-- Lean 4 å®ç°
-- æ¬§æ‹‰æ–¹æ³•
def euler_method (f : â„ â†’ â„ â†’ â„) (tâ‚€ yâ‚€ : â„) (h : â„) (n : â„•) : â„ :=
  match n with
  | 0 => yâ‚€
  | n + 1 => euler_method f (tâ‚€ + h) (yâ‚€ + h * f tâ‚€ yâ‚€) h n

-- é¾™æ ¼-åº“å¡”æ–¹æ³•
def runge_kutta_4 (f : â„ â†’ â„ â†’ â„) (tâ‚€ yâ‚€ : â„) (h : â„) : â„ :=
  let kâ‚ = f tâ‚€ yâ‚€
  let kâ‚‚ = f (tâ‚€ + h/2) (yâ‚€ + h * kâ‚ / 2)
  let kâ‚ƒ = f (tâ‚€ + h/2) (yâ‚€ + h * kâ‚‚ / 2)
  let kâ‚„ = f (tâ‚€ + h) (yâ‚€ + h * kâ‚ƒ)
  yâ‚€ + h * (kâ‚ + 2 * kâ‚‚ + 2 * kâ‚ƒ + kâ‚„) / 6
```

### åå¾®åˆ†æ–¹ç¨‹æ•°å€¼æ–¹æ³•

```haskell
-- Haskell å®ç°
-- æœ‰é™å·®åˆ†æ³•
finiteDifference :: (Double -> Double -> Double) -> Double -> Double -> [[Double]]
finiteDifference initial_condition dx dt = 
    let nx = floor (1.0 / dx) :: Int
        nt = floor (1.0 / dt) :: Int
        grid = replicate nx $ replicate nt 0.0
        initial_grid = map (\i -> initial_condition (i * dx)) [0..nx-1]
    in solveHeatEquation grid initial_grid dx dt

-- æœ‰é™å…ƒæ³•
finiteElement :: Mesh -> (Double -> Double) -> [Double]
finiteElement mesh boundary_condition = 
    let stiffness_matrix = assembleStiffnessMatrix mesh
        load_vector = assembleLoadVector mesh boundary_condition
    in solveLinearSystem stiffness_matrix load_vector

-- è°±æ–¹æ³•
spectralMethod :: Int -> (Double -> Double) -> [Double]
spectralMethod n_terms initial_condition = 
    let coefficients = fourierCoefficients initial_condition n_terms
        solution = map (\x -> sum $ zipWith (*) coefficients 
            (map (\n -> sin (n * pi * x)) [1..n_terms])) [0, 0.01..1]
    in solution
```

## åº”ç”¨åœºæ™¯

### ç‰©ç†å­¦åº”ç”¨

#### ç»å…¸åŠ›å­¦

```lean
-- ç®€è°è¿åŠ¨
def harmonic_oscillator (m k : â„) : â„ â†’ â„ â†’ â„ :=
  Î» t x, -k/m * x

-- è§£
theorem harmonic_oscillator_solution (m k xâ‚€ vâ‚€ : â„) :
  let Ï‰ = sqrt (k/m)
  let A = sqrt (xâ‚€^2 + (vâ‚€/Ï‰)^2)
  let Ï† = atan2 vâ‚€ (Ï‰ * xâ‚€)
  in âˆ€ t, x t = A * cos (Ï‰ * t + Ï†) := by
  -- å®ç°ç»†èŠ‚
  sorry

-- é˜»å°¼æŒ¯åŠ¨
def damped_oscillator (m c k : â„) : â„ â†’ â„ â†’ â„ :=
  Î» t x, -c/m * x' - k/m * x
```

#### é‡å­åŠ›å­¦

```haskell
-- è–›å®šè°”æ–¹ç¨‹
schrodingerEquation :: Complex -> (Double -> Complex) -> (Double -> Complex)
schrodingerEquation hamiltonian psi0 t = 
    let time_evolution = exp (-i * hamiltonian * t / hbar)
    in time_evolution `apply` psi0
  where
    i = Complex 0 1
    hbar = 1.054571817e-34

-- è°æŒ¯å­
harmonicOscillator :: Double -> (Double -> Complex)
harmonicOscillator omega x = 
    let ground_state = (omega / pi)^(1/4) * exp (-omega * x^2 / 2)
    in ground_state :+ 0
```

### ç”Ÿç‰©å­¦åº”ç”¨

#### ç§ç¾¤åŠ¨åŠ›å­¦

```rust
// æ´›ç‰¹å¡-æ²ƒå°”æ³°æ‹‰æ¨¡å‹
pub struct LotkaVolterra {
    alpha: f64,  // æ•é£Ÿè€…æ­»äº¡ç‡
    beta: f64,   // æ•é£Ÿæ•ˆç‡
    gamma: f64,  // è¢«æ•é£Ÿè€…å¢é•¿ç‡
    delta: f64,  // è¢«æ•é£Ÿè€…æ­»äº¡ç‡
}

impl LotkaVolterra {
    pub fn new(alpha: f64, beta: f64, gamma: f64, delta: f64) -> Self {
        Self { alpha, beta, gamma, delta }
    }
    
    pub fn vector_field(&self, state: &[f64]) -> Vec<f64> {
        let x = state[0];  // è¢«æ•é£Ÿè€…æ•°é‡
        let y = state[1];  // æ•é£Ÿè€…æ•°é‡
        
        vec![
            self.gamma * x - self.delta * x * y,  // dx/dt
            -self.alpha * y + self.beta * x * y,  // dy/dt
        ]
    }
    
    pub fn equilibrium_points(&self) -> Vec<Vec<f64>> {
        vec![
            vec![0.0, 0.0],  // ç­ç»å¹³è¡¡ç‚¹
            vec![self.alpha / self.beta, self.gamma / self.delta],  // å…±å­˜å¹³è¡¡ç‚¹
        ]
    }
}
```

### ç»æµå­¦åº”ç”¨

#### ç»æµå¢é•¿æ¨¡å‹

```haskell
-- ç´¢æ´›å¢é•¿æ¨¡å‹
solowGrowthModel :: Double -> Double -> Double -> Double -> Double -> Double
solowGrowthModel k0 s n g delta t = 
    let k_dot = s * f k - (n + g + delta) * k
        f k = k^alpha  -- ç”Ÿäº§å‡½æ•°
        alpha = 0.3
    in solveODE k_dot k0 t

-- æ‹‰å§†é½æ¨¡å‹
ramseyModel :: Double -> Double -> Double -> Double -> Double -> Double
ramseyModel c0 rho theta g n t = 
    let c_dot = (r - rho - theta * g) * c / theta
        r = f' k  -- åˆ©ç‡
        f' k = alpha * k^(alpha - 1)  -- èµ„æœ¬è¾¹é™…äº§å“
    in solveODE c_dot c0 t
```

## å½¢å¼åŒ–å®ç°

### Lean 4 å®Œæ•´å®ç°

```lean
-- å¾®åˆ†æ–¹ç¨‹æ ¸å¿ƒç»“æ„
structure DifferentialEquations where
  -- å­˜åœ¨å”¯ä¸€æ€§
  cauchy_picard : âˆ€ (f : â„ â†’ â„ â†’ â„) (tâ‚€ yâ‚€ : â„),
    IsLipschitz f â†’ âˆƒ! y, initial_value_problem f tâ‚€ yâ‚€ y
  
  -- çº¿æ€§æ–¹ç¨‹è§£
  linear_equation_solution : âˆ€ (p q : â„ â†’ â„) (tâ‚€ yâ‚€ : â„),
    âˆƒ y, y' + p * y = q âˆ§ y tâ‚€ = yâ‚€
  
  -- æ‹‰æ™®æ‹‰æ–¯æ–¹ç¨‹
  laplace_equation_solution : âˆ€ (Î© : Set â„Â²) (g : â„Â² â†’ â„),
    âˆƒ u, harmonic_function u âˆ§ âˆ€ x âˆˆ boundary Î©, u x = g x
  
  -- çƒ­ä¼ å¯¼æ–¹ç¨‹
  heat_equation_solution : âˆ€ (Î± : â„) (uâ‚€ : â„ â†’ â„),
    âˆƒ u, âˆ‚u/âˆ‚t = Î± * âˆ‚Â²u/âˆ‚xÂ² âˆ§ u(x, 0) = uâ‚€ x
  
  -- æ³¢åŠ¨æ–¹ç¨‹
  wave_equation_solution : âˆ€ (c : â„) (uâ‚€ vâ‚€ : â„ â†’ â„),
    âˆƒ u, âˆ‚Â²u/âˆ‚tÂ² = cÂ² * âˆ‚Â²u/âˆ‚xÂ² âˆ§ u(x, 0) = uâ‚€ x âˆ§ âˆ‚u/âˆ‚t(x, 0) = vâ‚€ x

-- å®ä¾‹
def differential_equations_instance : DifferentialEquations where
  cauchy_picard := by
    -- å®ç°ç»†èŠ‚
    sorry
  linear_equation_solution := by
    -- å®ç°ç»†èŠ‚
    sorry
  laplace_equation_solution := by
    -- å®ç°ç»†èŠ‚
    sorry
  heat_equation_solution := by
    -- å®ç°ç»†èŠ‚
    sorry
  wave_equation_solution := by
    -- å®ç°ç»†èŠ‚
    sorry
```

## æ€ç»´è¿‡ç¨‹è¡¨å¾

### å¾®åˆ†æ–¹ç¨‹æ±‚è§£æ€ç»´è¿‡ç¨‹

```mermaid
graph TD
    A[ç»™å®šå¾®åˆ†æ–¹ç¨‹] --> B{ç±»å‹åˆ¤æ–­}
    B -->|å¸¸å¾®åˆ†æ–¹ç¨‹| C{é˜¶æ•°?}
    B -->|åå¾®åˆ†æ–¹ç¨‹| D{æ–¹ç¨‹ç±»å‹}
    C -->|ä¸€é˜¶| E[ä¸€é˜¶æ–¹ç¨‹æ–¹æ³•]
    C -->|é«˜é˜¶| F[é«˜é˜¶æ–¹ç¨‹æ–¹æ³•]
    D -->|æ¤­åœ†| G[æ¤­åœ†æ–¹ç¨‹æ–¹æ³•]
    D -->|æŠ›ç‰©| H[æŠ›ç‰©æ–¹ç¨‹æ–¹æ³•]
    D -->|åŒæ›²| I[åŒæ›²æ–¹ç¨‹æ–¹æ³•]
    E --> J{å¯åˆ†ç¦»å˜é‡?}
    J -->|æ˜¯| K[åˆ†ç¦»å˜é‡æ³•]
    J -->|å¦| L{çº¿æ€§?}
    L -->|æ˜¯| M[ç§¯åˆ†å› å­æ³•]
    L -->|å¦| N[å…¶ä»–æ–¹æ³•]
    F --> O[ç‰¹å¾æ–¹ç¨‹æ³•]
    G --> P[åˆ†ç¦»å˜é‡æ³•]
    H --> Q[åˆ†ç¦»å˜é‡æ³•]
    I --> R[ç‰¹å¾çº¿æ³•]
```

### æ•°å€¼æ–¹æ³•é€‰æ‹©æ€ç»´è¿‡ç¨‹

```mermaid
graph TD
    A[æ•°å€¼æ±‚è§£éœ€æ±‚] --> B{æ–¹ç¨‹ç±»å‹}
    B -->|å¸¸å¾®åˆ†æ–¹ç¨‹| C{ç²¾åº¦è¦æ±‚}
    B -->|åå¾®åˆ†æ–¹ç¨‹| D{ç©ºé—´ç»´åº¦}
    C -->|ä½ç²¾åº¦| E[æ¬§æ‹‰æ–¹æ³•]
    C -->|é«˜ç²¾åº¦| F[é¾™æ ¼-åº“å¡”æ–¹æ³•]
    D -->|ä¸€ç»´| G[æœ‰é™å·®åˆ†æ³•]
    D -->|å¤šç»´| H[æœ‰é™å…ƒæ³•]
    E --> I[æ˜¾å¼æ–¹æ³•]
    F --> J[è‡ªé€‚åº”æ­¥é•¿]
    G --> K[ç©ºé—´ç¦»æ•£åŒ–]
    H --> L[ç½‘æ ¼ç”Ÿæˆ]
    I --> M[ç¨³å®šæ€§åˆ†æ]
    J --> N[è¯¯å·®æ§åˆ¶]
    K --> O[è¾¹ç•Œæ¡ä»¶]
    L --> P[åŸºå‡½æ•°é€‰æ‹©]
```

## å®ä¾‹è¡¨å¾

### ç»å…¸å®ä¾‹

#### 1. ç®€è°è¿åŠ¨

```lean
-- ç®€è°è¿åŠ¨æ–¹ç¨‹
def harmonic_motion (m k : â„) : â„ â†’ â„ â†’ â„ :=
  Î» t x, -k/m * x

-- è§£
theorem harmonic_motion_solution (m k xâ‚€ vâ‚€ : â„) :
  let Ï‰ = sqrt (k/m)
  let A = sqrt (xâ‚€^2 + (vâ‚€/Ï‰)^2)
  let Ï† = atan2 vâ‚€ (Ï‰ * xâ‚€)
  in âˆ€ t, x t = A * cos (Ï‰ * t + Ï†) := by
  -- å®ç°ç»†èŠ‚
  sorry
```

#### 2. çƒ­ä¼ å¯¼æ–¹ç¨‹

```haskell
-- çƒ­ä¼ å¯¼æ–¹ç¨‹
heatConduction :: Double -> (Double -> Double) -> (Double -> Double -> Double)
heatConduction alpha initial_condition (x, t) = 
    let fourier_coeffs = fourierCoefficients initial_condition
        solution = sum $ map (\n -> 
            fourier_coeffs n * exp (-alpha * (n * pi)^2 * t) * sin (n * pi * x)) [1..]
    in solution

-- æ•°å€¼è§£
heatConductionNumerical :: Double -> Double -> Double -> [[Double]]
heatConductionNumerical alpha dx dt = 
    let nx = floor (1.0 / dx) :: Int
        nt = floor (1.0 / dt) :: Int
        r = alpha * dt / (dx^2)
    in iterate (updateStep r) initial_grid
  where
    updateStep r grid = map (\i -> 
        if i == 0 || i == length grid - 1 then grid !! i
        else r * (grid !! (i-1) + grid !! (i+1)) + (1 - 2*r) * (grid !! i)) [0..length grid-1]
```

#### 3. æ´›ä¼¦å…¹ç³»ç»Ÿ

```rust
// æ´›ä¼¦å…¹å¸å¼•å­
pub struct LorenzSystem {
    sigma: f64,
    rho: f64,
    beta: f64,
}

impl LorenzSystem {
    pub fn new(sigma: f64, rho: f64, beta: f64) -> Self {
        Self { sigma, rho, beta }
    }
    
    pub fn vector_field(&self, state: &[f64]) -> Vec<f64> {
        let x = state[0];
        let y = state[1];
        let z = state[2];
        
        vec![
            self.sigma * (y - x),
            x * (self.rho - z) - y,
            x * y - self.beta * z,
        ]
    }
    
    pub fn attractor(&self, initial_state: &[f64], t_final: f64) -> Vec<Vec<f64>> {
        self.integrate(initial_state, t_final, 0.01)
    }
}
```

### åº”ç”¨å®ä¾‹

#### 1. ç”µè·¯åˆ†æ

```haskell
-- RLCç”µè·¯
rlcCircuit :: Double -> Double -> Double -> Double -> Double -> Double
rlcCircuit r l c v0 i0 t = 
    let omega0 = sqrt (1 / (l * c))  -- è‡ªç„¶é¢‘ç‡
        alpha = r / (2 * l)           -- é˜»å°¼ç³»æ•°
        omega_d = sqrt (omega0^2 - alpha^2)  -- é˜»å°¼é¢‘ç‡
    in if alpha < omega0 then
        -- æ¬ é˜»å°¼
        exp (-alpha * t) * (v0 * cos (omega_d * t) + 
            (i0 / c + alpha * v0) / omega_d * sin (omega_d * t))
       else if alpha == omega0 then
        -- ä¸´ç•Œé˜»å°¼
        exp (-alpha * t) * (v0 + (i0 / c + alpha * v0) * t)
       else
        -- è¿‡é˜»å°¼
        let gamma1 = alpha + sqrt (alpha^2 - omega0^2)
            gamma2 = alpha - sqrt (alpha^2 - omega0^2)
        in (v0 * gamma2 - i0 / c) / (gamma2 - gamma1) * exp (-gamma1 * t) +
           (i0 / c - v0 * gamma1) / (gamma2 - gamma1) * exp (-gamma2 * t)
```

#### 2. åŒ–å­¦ååº”åŠ¨åŠ›å­¦

```rust
// åŒ–å­¦ååº”ç³»ç»Ÿ
pub struct ChemicalReaction {
    rate_constants: Vec<f64>,
    stoichiometry: Vec<Vec<i32>>,
}

impl ChemicalReaction {
    pub fn reaction_rates(&self, concentrations: &[f64]) -> Vec<f64> {
        let mut rates = vec![0.0; concentrations.len()];
        
        for (i, reaction) in self.stoichiometry.iter().enumerate() {
            let rate = self.rate_constants[i] * 
                concentrations.iter().zip(reaction.iter())
                    .map(|(c, &s)| if s > 0 { c.powi(s) } else { 1.0 })
                    .product::<f64>();
            
            for (j, &stoich) in reaction.iter().enumerate() {
                rates[j] += stoich as f64 * rate;
            }
        }
        
        rates
    }
    
    pub fn solve_kinetics(&self, initial_concentrations: &[f64], t_final: f64) -> Vec<Vec<f64>> {
        let mut system = NonlinearSystem::new(|state| self.reaction_rates(state));
        system.integrate(initial_concentrations, t_final, 0.01)
    }
}
```

## æ€»ç»“ä¸å±•æœ›

### ä¸»è¦æˆå°±

1. **ç†è®ºåŸºç¡€**: å»ºç«‹äº†å®Œæ•´çš„å¾®åˆ†æ–¹ç¨‹ç†è®ºä½“ç³»
2. **æ±‚è§£æ–¹æ³•**: å‘å±•äº†å„ç§è§£æå’Œæ•°å€¼æ±‚è§£æ–¹æ³•
3. **åº”ç”¨å¹¿æ³›**: åœ¨ç‰©ç†ã€å·¥ç¨‹ã€ç”Ÿç‰©å­¦ä¸­å¹¿æ³›åº”ç”¨
4. **è®¡ç®—æŠ€æœ¯**: å‘å±•äº†é«˜æ•ˆçš„æ•°å€¼ç®—æ³•

### å‘å±•ç°çŠ¶

1. **åŠ¨åŠ›ç³»ç»Ÿ**: æ··æ²Œç†è®ºã€åˆ†å²”ç†è®ºã€ç¨³å®šæ€§åˆ†æ
2. **éšæœºå¾®åˆ†æ–¹ç¨‹**: éšæœºè¿‡ç¨‹ã€ä¼Šè—¤ç§¯åˆ†
3. **å»¶è¿Ÿå¾®åˆ†æ–¹ç¨‹**: æ—¶æ»ç³»ç»Ÿã€è®°å¿†æ•ˆåº”
4. **åˆ†æ•°é˜¶å¾®åˆ†æ–¹ç¨‹**: éå±€éƒ¨ç®—å­ã€åå¸¸æ‰©æ•£

### æœªæ¥æ–¹å‘

1. **é‡å­å¾®åˆ†æ–¹ç¨‹**: é‡å­åŠ›å­¦ä¸­çš„å¾®åˆ†æ–¹ç¨‹
2. **æœºå™¨å­¦ä¹ ä¸­çš„å¾®åˆ†æ–¹ç¨‹**: ç¥ç»å¾®åˆ†æ–¹ç¨‹
3. **å‡ ä½•å¾®åˆ†æ–¹ç¨‹**: åœ¨æµå½¢ä¸Šçš„å¾®åˆ†æ–¹ç¨‹
4. **éšæœºå‡ ä½•**: éšæœºå‡ ä½•ä¸­çš„å¾®åˆ†æ–¹ç¨‹

---

**æ–‡æ¡£ä¿¡æ¯**:

- **åˆ›å»ºæ—¶é—´**: 2025å¹´8æœˆ2æ—¥
- **ç‰ˆæœ¬**: å¢å¼ºç‰ˆ
- **å­—æ•°**: çº¦20,000å­—
- **å¤šè¡¨å¾**: å†å²å‘å±•ã€å¯è§†åŒ–å›¾è¡¨ã€å®ä¾‹è¡¨å¾ã€æ€ç»´è¿‡ç¨‹è¡¨å¾ã€åº”ç”¨åœºæ™¯è¡¨å¾
- **æŠ€æœ¯å®ç°**: Lean 4ã€Haskellã€Rust
- **ç›¸äº’å¼•ç”¨**: ä¸å®åˆ†æã€å¤åˆ†æã€æ³›å‡½åˆ†æã€è°ƒå’Œåˆ†æç­‰æ–‡æ¡£å…³è”

## æœ¯è¯­å¯¹ç…§è¡¨ / Terminology Table

| ä¸­æ–‡ | English |
|---|---|
| ODE/PDE | ODE/PDE |
| åˆå€¼/è¾¹å€¼ | Initial/Boundary |
| æ ¼æ—å‡½æ•°/åŸºæœ¬è§£ | Green's function/Fundamental solution |
| ç¨³å®šæ€§/æé›…æ™®è¯ºå¤« | Stability/Lyapunov |
| ç‰¹å¾å€¼/ç‰¹å¾å‡½æ•° | Eigenvalue/Eigenfunction |
| å¼±è§£/åˆ†å¸ƒè§£ | Weak/Distributional solution |

---

**äº¤äº’ä¸è¡¥å……èµ„æº / Interactive & Supplementary Resources**:

- [äº¤äº’å¼å›¾è¡¨å¢å¼ºï¼ˆç›¸å›¾/ç¨³å®šæ€§/è§£æ›²çº¿/åˆ†å²”å›¾å¯è§†åŒ–ï¼‰](../äº¤äº’å¼å›¾è¡¨å¢å¼º-2025å¹´1æœˆ.md)
- [å®šç†è¯æ˜è¡¥å……ï¼ˆå­˜åœ¨å”¯ä¸€æ€§/ç¨³å®šæ€§åˆ¤æ®/æé›…æ™®è¯ºå¤«å®šç†ï¼‰](../å®šç†è¯æ˜è¡¥å……-2025å¹´1æœˆ.md)
- [åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……ï¼ˆå¥‡è§£/æ··æ²Œ/åˆ†å²”/æé™ç¯åä¾‹ï¼‰](../åä¾‹ä¸ç‰¹æ®Šæƒ…å†µè¡¥å……-2025å¹´1æœˆ.md)
- [å†å²èƒŒæ™¯è¡¥å……ï¼ˆå¾®åˆ†æ–¹ç¨‹å‘å±•å²ä¸é‡è¦åº”ç”¨ï¼‰](../å†å²èƒŒæ™¯è¡¥å……-2025å¹´1æœˆ.md)
