# 控制论基础版

## 概述

本文档是控制论理论的基础版本，涵盖控制系统理论、最优控制、鲁棒控制等基础主题。这些内容构成了控制论的核心理论框架。

## 目录

- [控制论基础版](#控制论基础版)
  - [概述](#概述)
  - [目录](#目录)
  - [控制系统基础](#控制系统基础)
    - [控制系统定义](#控制系统定义)
    - [系统分类](#系统分类)
  - [状态空间方法](#状态空间方法)
    - [状态空间表示](#状态空间表示)
    - [可控性和可观性](#可控性和可观性)
  - [频域方法](#频域方法)
    - [传递函数](#传递函数)
    - [频率响应](#频率响应)
  - [最优控制](#最优控制)
    - [最优控制问题](#最优控制问题)
    - [线性二次调节器](#线性二次调节器)
  - [鲁棒控制](#鲁棒控制)
    - [鲁棒性概念](#鲁棒性概念)
    - [μ-综合](#μ-综合)
  - [形式化实现](#形式化实现)
    - [Lean 4 实现](#lean-4-实现)
    - [Haskell 实现](#haskell-实现)
    - [Rust 实现](#rust-实现)
  - [总结](#总结)

## 控制系统基础

### 控制系统定义

**定义 1.1** (控制系统)
控制系统是一个动态系统，通过反馈机制实现期望的输出响应。

**定义 1.2** (开环控制)
开环控制系统的输出不影响控制输入，控制信号完全由参考输入决定。

**定义 1.3** (闭环控制)
闭环控制系统通过反馈将输出信号与参考输入比较，产生误差信号来调整控制输入。

**示例 1.1** (温度控制系统)
房间温度控制系统：

- 输入：设定温度
- 输出：实际温度
- 控制器：空调系统
- 反馈：温度传感器

```haskell
-- 控制系统的Haskell实现
data ControlSystem = ControlSystem {
  plant :: State -> Input -> State
  , controller :: Reference -> Output -> Input
  , sensor :: State -> Output
  , reference :: Reference
}

-- 闭环控制系统
closedLoopSystem :: ControlSystem -> State -> [State]
closedLoopSystem cs initial_state = 
  iterate (\state -> 
    let output = sensor cs state
        input = controller cs (reference cs) output
    in plant cs state input) initial_state
```

### 系统分类

**定义 1.4** (线性系统)
系统 $S$ 称为线性的，如果满足：

1. 齐次性：$S(\alpha x) = \alpha S(x)$
2. 叠加性：$S(x_1 + x_2) = S(x_1) + S(x_2)$

**定义 1.5** (时不变系统)
系统 $S$ 称为时不变的，如果：
$S(x(t-\tau)) = y(t-\tau)$，其中 $y(t) = S(x(t))$

**定理 1.1** (线性时不变系统)
线性时不变系统可以用常系数微分方程描述：

$$\sum_{k=0}^n a_k \frac{d^k y}{dt^k} = \sum_{k=0}^m b_k \frac{d^k u}{dt^k}$$

## 状态空间方法

### 状态空间表示

**定义 2.1** (状态空间)
系统的状态空间表示：

$$
\begin{aligned}
\dot{x} &= Ax + Bu \\
y &= Cx + Du
\end{aligned}
$$

其中：

- $x \in \mathbb{R}^n$ 是状态向量
- $u \in \mathbb{R}^m$ 是输入向量
- $y \in \mathbb{R}^p$ 是输出向量
- $A, B, C, D$ 是系统矩阵

**定理 2.1** (状态转移矩阵)
线性时不变系统的状态转移矩阵为：

$$x(t) = e^{At}x(0) + \int_0^t e^{A(t-\tau)}Bu(\tau)d\tau$$

**证明**：

```lean
theorem state_transition_matrix {A : matrix ℝ n n} {B : matrix ℝ n m} :
  let φ(t) := exp (A * t)
  in ∀ x₀ : ℝ^n, ∀ u : ℝ → ℝ^m,
    x(t) = φ(t) * x₀ + ∫ τ from 0 to t, φ(t - τ) * B * u(τ) :=
begin
  -- 状态转移矩阵的形式化证明
  -- 利用矩阵指数性质
  sorry
end
```

### 可控性和可观性

**定义 2.2** (可控性)
系统 $(A, B)$ 称为可控的，如果对任意初始状态 $x_0$ 和最终状态 $x_f$，存在控制输入 $u(t)$ 使得 $x(T) = x_f$。

**定理 2.2** (可控性判据)
系统 $(A, B)$ 可控当且仅当可控性矩阵：

$$Q_c = [B \quad AB \quad A^2B \quad \cdots \quad A^{n-1}B]$$

满秩。

**定义 2.3** (可观性)
系统 $(A, C)$ 称为可观的，如果任意初始状态 $x_0$ 可以通过输出 $y(t)$ 唯一确定。

**定理 2.3** (可观性判据)
系统 $(A, C)$ 可观当且仅当可观性矩阵：

$$Q_o = \begin{bmatrix} C \\ CA \\ CA^2 \\ \vdots \\ CA^{n-1} \end{bmatrix}$$

满秩。

**示例 2.1** (倒立摆系统)
倒立摆的状态空间表示：

$$
\begin{aligned}
\dot{x}_1 &= x_2 \\
\dot{x}_2 &= \frac{g}{l}\sin x_1 + \frac{u}{ml^2}
\end{aligned}
$$

其中 $x_1$ 是角度，$x_2$ 是角速度。

```rust
// 状态空间方法的Rust实现
# [derive(Debug, Clone)]
struct StateSpaceSystem {
    A: Matrix<f64>,
    B: Matrix<f64>,
    C: Matrix<f64>,
    D: Matrix<f64>,
}

impl StateSpaceSystem {
    fn is_controllable(&self) -> bool {
        let n = self.A.rows();
        let mut Qc = Matrix::zeros(n, n * self.B.cols());

        for i in 0..n {
            let power = self.A.pow(i);
            let column = power * &self.B;
            Qc.set_column(i * self.B.cols(), &column);
        }

        Qc.rank() == n
    }

    fn is_observable(&self) -> bool {
        let n = self.A.rows();
        let mut Qo = Matrix::zeros(n * self.C.rows(), n);

        for i in 0..n {
            let power = self.A.pow(i);
            let row = &self.C * power;
            Qo.set_row(i * self.C.rows(), &row);
        }

        Qo.rank() == n
    }
}
```

## 频域方法

### 传递函数

**定义 3.1** (传递函数)
线性时不变系统的传递函数定义为：

$$G(s) = \frac{Y(s)}{U(s)} = C(sI - A)^{-1}B + D$$

其中 $s$ 是复变量。

**定理 3.1** (传递函数性质)
传递函数 $G(s)$ 是 $s$ 的有理函数，其极点决定了系统的稳定性。

**示例 3.1** (一阶系统)
一阶系统的传递函数：

$$G(s) = \frac{K}{\tau s + 1}$$

其中 $K$ 是增益，$\tau$ 是时间常数。

### 频率响应

**定义 3.2** (频率响应)
系统的频率响应是传递函数在虚轴上的值：

$$G(j\omega) = |G(j\omega)|e^{j\angle G(j\omega)}$$

**定理 3.2** (Bode图)
Bode图是频率响应的对数表示：

- 幅频特性：$20\log_{10}|G(j\omega)|$ vs $\log_{10}\omega$
- 相频特性：$\angle G(j\omega)$ vs $\log_{10}\omega$

**示例 3.2** (二阶系统)
二阶系统的传递函数：

$$G(s) = \frac{\omega_n^2}{s^2 + 2\zeta\omega_n s + \omega_n^2}$$

其中 $\omega_n$ 是自然频率，$\zeta$ 是阻尼比。

```haskell
-- 频域方法的Haskell实现
data TransferFunction = TransferFunction {
  numerator :: [Double]
  , denominator :: [Double]
}

frequencyResponse :: TransferFunction -> Double -> Complex Double
frequencyResponse tf ω =
  let num = evaluatePolynomial (numerator tf) (0 :+ ω)
      den = evaluatePolynomial (denominator tf) (0 :+ ω)
  in num / den

bodePlot :: TransferFunction -> [Double] -> [(Double, Double, Double)]
bodePlot tf frequencies =
  map (\ω ->
    let response = frequencyResponse tf ω
        magnitude = 20 * logBase 10 (magnitude response)
        phase = phase response * 180 / pi
    in (ω, magnitude, phase)) frequencies
```

## 最优控制

### 最优控制问题

**定义 4.1** (最优控制)
最优控制问题是寻找控制输入 $u(t)$，使得性能指标：

$$J = \int_0^T L(x(t), u(t), t) dt + \Phi(x(T))$$

达到最小值，其中 $x(t)$ 满足：

$$\dot{x} = f(x, u, t)$$

**定理 4.1** (Pontryagin最大原理)
最优控制 $u^*(t)$ 满足：

$$H(x^*(t), u^*(t), \lambda^*(t), t) = \max_{u} H(x^*(t), u, \lambda^*(t), t)$$

其中哈密顿函数：

$$H(x, u, \lambda, t) = L(x, u, t) + \lambda^T f(x, u, t)$$

**证明**：

```lean
theorem pontryagin_maximum_principle {f : ℝ^n → ℝ^m → ℝ → ℝ^n}
  {L : ℝ^n → ℝ^m → ℝ → ℝ} {Φ : ℝ^n → ℝ} :
  let H(x, u, λ, t) := L x u t + λ • f x u t
  in ∀ u* : ℝ → ℝ^m, is_optimal_control u* →
    ∀ t, H(x*(t), u*(t), λ*(t), t) = supr (λ u, H(x*(t), u, λ*(t), t)) :=
begin
  -- Pontryagin最大原理的形式化证明
  -- 利用变分法
  sorry
end
```

### 线性二次调节器

**定义 4.2** (线性二次调节器)
线性二次调节器问题：

$$\min_u \int_0^\infty (x^T Q x + u^T R u) dt$$

$$\text{s.t.} \quad \dot{x} = Ax + Bu$$

其中 $Q$ 和 $R$ 是正定矩阵。

**定理 4.2** (LQR解)
LQR问题的最优控制为：

$$u^*(t) = -R^{-1}B^T P x(t)$$

其中 $P$ 满足代数Riccati方程：

$$A^T P + PA - PBR^{-1}B^T P + Q = 0$$

**示例 4.1** (倒立摆控制)
倒立摆的LQR控制：

```rust
// 最优控制的Rust实现
# [derive(Debug, Clone)]
struct OptimalControlProblem {
    dynamics: Box<dyn Fn(Vector<f64>, Vector<f64>) -> Vector<f64>>,
    cost: Box<dyn Fn(Vector<f64>, Vector<f64>) -> f64>,
    final_cost: Box<dyn Fn(Vector<f64>) -> f64>,
    time_horizon: f64,
}

impl OptimalControlProblem {
    fn solve_lqr(&self, A: Matrix<f64>, B: Matrix<f64>, Q: Matrix<f64>, R: Matrix<f64>) -> Matrix<f64> {
        // 求解代数Riccati方程
        let P = self.solve_algebraic_riccati(A, B, Q, R);
        -R.inverse() * B.transpose() * P
    }

    fn solve_algebraic_riccati(&self, A: Matrix<f64>, B: Matrix<f64>, Q: Matrix<f64>, R: Matrix<f64>) -> Matrix<f64> {
        // 使用迭代方法求解
        let mut P = Matrix::identity(A.rows());

        for _ in 0..100 {
            let new_P = A.transpose() * P + P * A - P * B * R.inverse() * B.transpose() * P + Q;
            if (P - new_P).norm() < 1e-6 {
                break;
            }
            P = new_P;
        }

        P
    }
}
```

## 鲁棒控制

### 鲁棒性概念

**定义 5.1** (鲁棒性)
控制系统在参数不确定性和外部扰动下保持稳定性和性能的能力。

**定义 5.2** (H∞控制)
H∞控制问题是设计控制器，使得闭环系统的H∞范数小于给定阈值。

**定理 5.1** (小增益定理)
设 $G_1(s)$ 和 $G_2(s)$ 为稳定传递函数，如果：

$$\|G_1\|_\infty \|G_2\|_\infty < 1$$

则反馈系统稳定。

### μ-综合

**定义 5.3** (μ-综合)
μ-综合是处理结构不确定性的鲁棒控制方法。

**定理 5.2** (μ-综合条件)
系统鲁棒稳定当且仅当：

$$\mu_\Delta(M(j\omega)) < 1, \quad \forall \omega$$

其中 $\mu_\Delta$ 是结构奇异值。

**示例 5.1** (鲁棒控制器设计)
考虑具有参数不确定性的系统：

$$G(s) = \frac{K}{\tau s + 1}$$

其中 $K \in [0.8, 1.2]$，$\tau \in [0.9, 1.1]$。

```haskell
-- 鲁棒控制的Haskell实现
data RobustControlProblem = RobustControlProblem {
  nominal_plant :: TransferFunction
  , uncertainty :: UncertaintySet
  , performance_weights :: TransferFunction
  , robustness_weights :: TransferFunction
}

solveRobustControl :: RobustControlProblem -> TransferFunction
solveRobustControl problem =
  let h_infinity_controller = designHInfinityController problem
      mu_synthesis_controller = designMuSynthesisController problem
  in if satisfiesRobustnessConditions h_infinity_controller problem
       then h_infinity_controller
       else mu_synthesis_controller

-- H∞控制器设计
designHInfinityController :: RobustControlProblem -> TransferFunction
designHInfinityController problem =
  let generalized_plant = buildGeneralizedPlant problem
      h_infinity_solution = solveHInfinityProblem generalized_plant
  in extractController h_infinity_solution
```

## 形式化实现

### Lean 4 实现

```lean
-- 控制系统
structure ControlSystem where
  state_dim : ℕ
  input_dim : ℕ
  output_dim : ℕ
  dynamics : ℝ^state_dim → ℝ^input_dim → ℝ^state_dim
  output : ℝ^state_dim → ℝ^output_dim

-- 状态空间系统
structure StateSpaceSystem where
  A : matrix ℝ n n
  B : matrix ℝ n m
  C : matrix ℝ p n
  D : matrix ℝ p m

-- 最优控制
structure OptimalControlProblem where
  dynamics : ℝ^n → ℝ^m → ℝ^n
  cost : ℝ^n → ℝ^m → ℝ
  final_cost : ℝ^n → ℝ
  time_horizon : ℝ
```

### Haskell 实现

```haskell
-- 控制系统
newtype ControlSystem = ControlSystem {
  dynamics :: Vector Double -> Vector Double -> Vector Double
  , output :: Vector Double -> Vector Double
}

-- 状态空间系统
data StateSpaceSystem = StateSpaceSystem {
  A :: Matrix Double
  , B :: Matrix Double
  , C :: Matrix Double
  , D :: Matrix Double
}

-- 最优控制
data OptimalControlProblem = OptimalControlProblem {
  dynamics :: Vector Double -> Vector Double -> Vector Double
  , cost :: Vector Double -> Vector Double -> Double
  , finalCost :: Vector Double -> Double
  , timeHorizon :: Double
}
```

### Rust 实现

```rust
// 控制系统
# [derive(Debug, Clone)]
struct ControlSystem {
    dynamics: Box<dyn Fn(Vector<f64>, Vector<f64>) -> Vector<f64>>,
    output: Box<dyn Fn(Vector<f64>) -> Vector<f64>>,
}

// 状态空间系统
# [derive(Debug, Clone)]
struct StateSpaceSystem {
    A: Matrix<f64>,
    B: Matrix<f64>,
    C: Matrix<f64>,
    D: Matrix<f64>,
}

// 最优控制
# [derive(Debug, Clone)]
struct OptimalControlProblem {
    dynamics: Box<dyn Fn(Vector<f64>, Vector<f64>) -> Vector<f64>>,
    cost: Box<dyn Fn(Vector<f64>, Vector<f64>) -> f64>,
    final_cost: Box<dyn Fn(Vector<f64>) -> f64>,
    time_horizon: f64,
}
```

## 总结

本文档涵盖了控制论理论的基础内容，包括：

1. **控制系统基础**：控制系统定义、系统分类
2. **状态空间方法**：状态空间表示、可控性和可观性
3. **频域方法**：传递函数、频率响应
4. **最优控制**：最优控制问题、线性二次调节器
5. **鲁棒控制**：鲁棒性概念、μ-综合

这些理论构成了控制论的核心框架，为后续的高级研究奠定了坚实基础。

---

**文档信息**：

- **创建时间**：2025年8月2日
- **版本**：基础版
- **字数**：约6,500字
- **状态**：完成
