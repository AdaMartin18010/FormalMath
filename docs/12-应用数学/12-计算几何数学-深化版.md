# è®¡ç®—å‡ ä½•æ•°å­¦ - æ·±åŒ–ç‰ˆ

## ğŸ“š æ¦‚è¿°

è®¡ç®—å‡ ä½•æ•°å­¦æ˜¯ç ”ç©¶å‡ ä½•é—®é¢˜çš„ç®—æ³•è®¾è®¡å’Œåˆ†æçš„æ•°å­¦ç†è®ºä½“ç³»ã€‚æœ¬æ·±åŒ–ç‰ˆå°†æ·±å…¥æ¢è®¨è®¡ç®—å‡ ä½•çš„æ•°å­¦åŸºç¡€ï¼ŒåŒ…æ‹¬å‡ ä½•ç®—æ³•ã€è®¡ç®—æ‹“æ‰‘ã€å‡ ä½•ä¼˜åŒ–ç­‰æ ¸å¿ƒå†…å®¹ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

1. **æŒæ¡å‡ ä½•ç®—æ³•æ•°å­¦åŸºç¡€**ï¼šç†è§£å‡¸åŒ…ç®—æ³•ã€ä¸‰è§’å‰–åˆ†ã€æœ€è¿‘é‚»æœç´¢çš„æ•°å­¦åŸç†
2. **æŒæ¡è®¡ç®—æ‹“æ‰‘æ•°å­¦ç†è®º**ï¼šç†è§£æŒä¹…åŒè°ƒã€æµå½¢å­¦ä¹ ã€æ‹“æ‰‘æ•°æ®åˆ†æçš„æ•°å­¦æ–¹æ³•
3. **æŒæ¡å‡ ä½•ä¼˜åŒ–æ•°å­¦åŸç†**ï¼šç†è§£å‡ ä½•è§„åˆ’ã€å‡¸ä¼˜åŒ–å‡ ä½•ã€éçº¿æ€§ä¼˜åŒ–çš„æ•°å­¦ç†è®º
4. **æŒæ¡å‡ ä½•æŸ¥è¯¢æ•°å­¦æ–¹æ³•**ï¼šç†è§£èŒƒå›´æŸ¥è¯¢ã€æœ€è¿‘é‚»æŸ¥è¯¢ã€ç›¸äº¤æŸ¥è¯¢çš„æ•°å­¦ç®—æ³•

## ğŸ“– ç›®å½•

- [è®¡ç®—å‡ ä½•æ•°å­¦ - æ·±åŒ–ç‰ˆ](#è®¡ç®—å‡ ä½•æ•°å­¦---æ·±åŒ–ç‰ˆ)
  - [ğŸ“š æ¦‚è¿°](#-æ¦‚è¿°)
  - [ğŸ¯ å­¦ä¹ ç›®æ ‡](#-å­¦ä¹ ç›®æ ‡)
  - [ğŸ“– ç›®å½•](#-ç›®å½•)
  - [1. å‡ ä½•ç®—æ³•æ•°å­¦ç†è®º](#1-å‡ ä½•ç®—æ³•æ•°å­¦ç†è®º)
    - [1.1 å‡¸åŒ…ç®—æ³•æ•°å­¦](#11-å‡¸åŒ…ç®—æ³•æ•°å­¦)
      - [1.1.1 Grahamæ‰«æç®—æ³•](#111-grahamæ‰«æç®—æ³•)
      - [1.1.2 Jarvisæ­¥è¿›ç®—æ³•](#112-jarvisæ­¥è¿›ç®—æ³•)
      - [1.1.3 åˆ†æ²»å‡¸åŒ…ç®—æ³•](#113-åˆ†æ²»å‡¸åŒ…ç®—æ³•)
    - [1.2 ä¸‰è§’å‰–åˆ†æ•°å­¦](#12-ä¸‰è§’å‰–åˆ†æ•°å­¦)
      - [1.2.1 Delaunayä¸‰è§’å‰–åˆ†](#121-delaunayä¸‰è§’å‰–åˆ†)
      - [1.2.2 å¢é‡ç®—æ³•](#122-å¢é‡ç®—æ³•)
      - [1.2.3 çº¦æŸä¸‰è§’å‰–åˆ†](#123-çº¦æŸä¸‰è§’å‰–åˆ†)
    - [1.3 æœ€è¿‘é‚»æœç´¢æ•°å­¦](#13-æœ€è¿‘é‚»æœç´¢æ•°å­¦)
      - [1.3.1 k-dæ ‘](#131-k-dæ ‘)
      - [1.3.2 Ræ ‘](#132-ræ ‘)
      - [1.3.3 å±€éƒ¨æ•æ„Ÿå“ˆå¸Œ](#133-å±€éƒ¨æ•æ„Ÿå“ˆå¸Œ)
  - [2. è®¡ç®—æ‹“æ‰‘æ•°å­¦ç†è®º](#2-è®¡ç®—æ‹“æ‰‘æ•°å­¦ç†è®º)
    - [2.1 æŒä¹…åŒè°ƒ](#21-æŒä¹…åŒè°ƒ)
      - [2.1.1 å•çº¯å¤å½¢](#211-å•çº¯å¤å½¢)
      - [2.1.2 åŒè°ƒç¾¤](#212-åŒè°ƒç¾¤)
      - [2.1.3 æŒä¹…æ€§](#213-æŒä¹…æ€§)
    - [2.2 æµå½¢å­¦ä¹ ](#22-æµå½¢å­¦ä¹ )
      - [2.2.1 å±€éƒ¨çº¿æ€§åµŒå…¥ï¼ˆLLEï¼‰](#221-å±€éƒ¨çº¿æ€§åµŒå…¥lle)
      - [2.2.2 ç­‰è·æ˜ å°„ï¼ˆIsomapï¼‰](#222-ç­‰è·æ˜ å°„isomap)
      - [2.2.3 æ‹‰æ™®æ‹‰æ–¯ç‰¹å¾æ˜ å°„](#223-æ‹‰æ™®æ‹‰æ–¯ç‰¹å¾æ˜ å°„)
    - [2.3 æ‹“æ‰‘æ•°æ®åˆ†æ](#23-æ‹“æ‰‘æ•°æ®åˆ†æ)
      - [2.3.1 Mapperç®—æ³•](#231-mapperç®—æ³•)
      - [2.3.2 æŒä¹…æ€§æ™¯è§‚](#232-æŒä¹…æ€§æ™¯è§‚)
      - [2.3.3 æŒä¹…æ€§å›¾åƒ](#233-æŒä¹…æ€§å›¾åƒ)
  - [3. å‡ ä½•ä¼˜åŒ–æ•°å­¦ç†è®º](#3-å‡ ä½•ä¼˜åŒ–æ•°å­¦ç†è®º)
    - [3.1 å‡ ä½•è§„åˆ’](#31-å‡ ä½•è§„åˆ’)
      - [3.1.1 æ­£é¡¹å‡ ä½•è§„åˆ’](#311-æ­£é¡¹å‡ ä½•è§„åˆ’)
      - [3.1.2 å¯¹å¶é—®é¢˜](#312-å¯¹å¶é—®é¢˜)
      - [3.1.3 å†…ç‚¹æ³•](#313-å†…ç‚¹æ³•)
    - [3.2 å‡¸ä¼˜åŒ–å‡ ä½•](#32-å‡¸ä¼˜åŒ–å‡ ä½•)
      - [3.2.1 å‡¸é›†](#321-å‡¸é›†)
      - [3.2.2 å‡¸å‡½æ•°](#322-å‡¸å‡½æ•°)
      - [3.2.3 å¯¹å¶ç†è®º](#323-å¯¹å¶ç†è®º)
    - [3.3 éçº¿æ€§ä¼˜åŒ–](#33-éçº¿æ€§ä¼˜åŒ–)
      - [3.3.1 æ¢¯åº¦ä¸‹é™](#331-æ¢¯åº¦ä¸‹é™)
      - [3.3.2 ç‰›é¡¿æ³•](#332-ç‰›é¡¿æ³•)
      - [3.3.3 çº¦æŸä¼˜åŒ–](#333-çº¦æŸä¼˜åŒ–)
  - [4. å‡ ä½•æŸ¥è¯¢æ•°å­¦ç†è®º](#4-å‡ ä½•æŸ¥è¯¢æ•°å­¦ç†è®º)
    - [4.1 èŒƒå›´æŸ¥è¯¢](#41-èŒƒå›´æŸ¥è¯¢)
      - [4.1.1 æ­£äº¤èŒƒå›´æŸ¥è¯¢](#411-æ­£äº¤èŒƒå›´æŸ¥è¯¢)
      - [4.1.2 åŠç©ºé—´æŸ¥è¯¢](#412-åŠç©ºé—´æŸ¥è¯¢)
      - [4.1.3 åœ†èŒƒå›´æŸ¥è¯¢](#413-åœ†èŒƒå›´æŸ¥è¯¢)
    - [4.2 æœ€è¿‘é‚»æŸ¥è¯¢](#42-æœ€è¿‘é‚»æŸ¥è¯¢)
      - [4.2.1 ç²¾ç¡®æœ€è¿‘é‚»](#421-ç²¾ç¡®æœ€è¿‘é‚»)
      - [4.2.2 è¿‘ä¼¼æœ€è¿‘é‚»](#422-è¿‘ä¼¼æœ€è¿‘é‚»)
      - [4.2.3 k-æœ€è¿‘é‚»](#423-k-æœ€è¿‘é‚»)
    - [4.3 ç›¸äº¤æŸ¥è¯¢](#43-ç›¸äº¤æŸ¥è¯¢)
      - [4.3.1 çº¿æ®µç›¸äº¤](#431-çº¿æ®µç›¸äº¤)
      - [4.3.2 å¤šè¾¹å½¢ç›¸äº¤](#432-å¤šè¾¹å½¢ç›¸äº¤)
      - [4.3.3 å‡¸åŒ…ç›¸äº¤](#433-å‡¸åŒ…ç›¸äº¤)
  - [5. æŠ€æœ¯å®ç°](#5-æŠ€æœ¯å®ç°)
    - [5.1 Pythonå®ç°](#51-pythonå®ç°)
    - [5.2 é«˜çº§å‡ ä½•ç®—æ³•å®ç°](#52-é«˜çº§å‡ ä½•ç®—æ³•å®ç°)
  - [6. åº”ç”¨æ¡ˆä¾‹](#6-åº”ç”¨æ¡ˆä¾‹)
    - [6.1 è®¡ç®—æœºå›¾å½¢å­¦åº”ç”¨](#61-è®¡ç®—æœºå›¾å½¢å­¦åº”ç”¨)
    - [6.2 æœºå™¨äººå­¦åº”ç”¨](#62-æœºå™¨äººå­¦åº”ç”¨)
    - [6.3 åœ°ç†ä¿¡æ¯ç³»ç»Ÿåº”ç”¨](#63-åœ°ç†ä¿¡æ¯ç³»ç»Ÿåº”ç”¨)
  - [7. å‰æ²¿å‘å±•](#7-å‰æ²¿å‘å±•)
    - [7.1 è®¡ç®—å‡ ä½•ä¸æœºå™¨å­¦ä¹ ](#71-è®¡ç®—å‡ ä½•ä¸æœºå™¨å­¦ä¹ )
    - [7.2 æ‹“æ‰‘æ•°æ®åˆ†æ](#72-æ‹“æ‰‘æ•°æ®åˆ†æ)
    - [7.3 å‡ ä½•ä¼˜åŒ–å‰æ²¿](#73-å‡ ä½•ä¼˜åŒ–å‰æ²¿)
  - [8. æ€»ç»“ä¸å±•æœ›](#8-æ€»ç»“ä¸å±•æœ›)
    - [8.1 æ ¸å¿ƒè¦ç‚¹æ€»ç»“](#81-æ ¸å¿ƒè¦ç‚¹æ€»ç»“)
    - [8.2 å‘å±•è¶‹åŠ¿](#82-å‘å±•è¶‹åŠ¿)
    - [8.3 æŒ‘æˆ˜ä¸æœºé‡](#83-æŒ‘æˆ˜ä¸æœºé‡)
  - [ğŸ“š å‚è€ƒæ–‡çŒ®](#-å‚è€ƒæ–‡çŒ®)
  - [ğŸ”— ç›¸å…³é“¾æ¥](#-ç›¸å…³é“¾æ¥)

---

## 1. å‡ ä½•ç®—æ³•æ•°å­¦ç†è®º

### 1.1 å‡¸åŒ…ç®—æ³•æ•°å­¦

#### 1.1.1 Grahamæ‰«æç®—æ³•

**æè§’æ’åº**ï¼š
å¯¹äºç‚¹é›†$P$ï¼Œé€‰æ‹©æœ€ä¸‹æ–¹çš„ç‚¹$p_0$ï¼ŒæŒ‰æè§’æ’åºå…¶ä»–ç‚¹ï¼š
$$\theta_i = \text{atan2}(y_i - y_0, x_i - x_0)$$

**å·¦è½¬åˆ¤æ–­**ï¼š
å¯¹äºä¸‰ç‚¹$p_1, p_2, p_3$ï¼Œåˆ¤æ–­$p_3$æ˜¯å¦åœ¨$p_1p_2$çš„å·¦ä¾§ï¼š
$$\text{ccw}(p_1, p_2, p_3) = (x_2 - x_1)(y_3 - y_1) - (y_2 - y_1)(x_3 - x_1)$$

å¦‚æœ$\text{ccw} > 0$ï¼Œåˆ™$p_3$åœ¨å·¦ä¾§ã€‚

**ç®—æ³•æ­¥éª¤**ï¼š

1. æ‰¾åˆ°æœ€ä¸‹æ–¹çš„ç‚¹$p_0$
2. æŒ‰æè§’æ’åºå…¶ä»–ç‚¹
3. ä½¿ç”¨æ ˆç»´æŠ¤å‡¸åŒ…
4. å¯¹äºæ¯ä¸ªç‚¹$p_i$ï¼Œå¦‚æœæ ˆé¡¶ä¸‰ç‚¹ä¸æ„æˆå·¦è½¬ï¼Œåˆ™å¼¹å‡ºæ ˆé¡¶
5. å°†$p_i$å‹å…¥æ ˆ

#### 1.1.2 Jarvisæ­¥è¿›ç®—æ³•

**æè§’è®¡ç®—**ï¼š
å¯¹äºå½“å‰å‡¸åŒ…ç‚¹$p$ï¼Œæ‰¾åˆ°æè§’æœ€å°çš„ä¸‹ä¸€ä¸ªç‚¹ï¼š
$$\theta_i = \text{atan2}(y_i - y_p, x_i - x_p)$$

**ç®—æ³•æ­¥éª¤**ï¼š

1. æ‰¾åˆ°æœ€ä¸‹æ–¹çš„ç‚¹ä½œä¸ºèµ·å§‹ç‚¹
2. æ‰¾åˆ°æè§’æœ€å°çš„ä¸‹ä¸€ä¸ªç‚¹
3. é‡å¤æ­¥éª¤2ç›´åˆ°å›åˆ°èµ·å§‹ç‚¹

**æ—¶é—´å¤æ‚åº¦**ï¼š$O(nh)$ï¼Œå…¶ä¸­$h$æ˜¯å‡¸åŒ…é¡¶ç‚¹æ•°ã€‚

#### 1.1.3 åˆ†æ²»å‡¸åŒ…ç®—æ³•

**åˆå¹¶ç­–ç•¥**ï¼š
å¯¹äºä¸¤ä¸ªå‡¸åŒ…$H_1, H_2$ï¼Œæ‰¾åˆ°ä¸Šåˆ‡çº¿å’Œä¸‹åˆ‡çº¿ï¼š

- ä¸Šåˆ‡çº¿ï¼šè¿æ¥ä¸¤ä¸ªå‡¸åŒ…çš„æœ€é«˜ç‚¹
- ä¸‹åˆ‡çº¿ï¼šè¿æ¥ä¸¤ä¸ªå‡¸åŒ…çš„æœ€ä½ç‚¹

**ç®—æ³•æ­¥éª¤**ï¼š

1. å°†ç‚¹é›†åˆ†ä¸ºä¸¤åŠ
2. é€’å½’è®¡ç®—ä¸¤ä¸ªå­é›†çš„å‡¸åŒ…
3. åˆå¹¶ä¸¤ä¸ªå‡¸åŒ…

**æ—¶é—´å¤æ‚åº¦**ï¼š$O(n \log n)$ã€‚

### 1.2 ä¸‰è§’å‰–åˆ†æ•°å­¦

#### 1.2.1 Delaunayä¸‰è§’å‰–åˆ†

**ç©ºåœ†æ€§è´¨**ï¼š
å¯¹äºä¸‰è§’å½¢$\triangle abc$ï¼Œå…¶å¤–æ¥åœ†ä¸åŒ…å«å…¶ä»–ç‚¹ï¼š
$$\forall p \in P \setminus \{a, b, c\}, p \notin \text{circumcircle}(a, b, c)$$

**æœ€å¤§åŒ–æœ€å°è§’**ï¼š
Delaunayä¸‰è§’å‰–åˆ†æœ€å¤§åŒ–æ‰€æœ‰ä¸‰è§’å½¢çš„æœ€å°å†…è§’ã€‚

**ç¿»è½¬æ“ä½œ**ï¼š
å¯¹äºå››è¾¹å½¢$abcd$ï¼Œå¦‚æœ$d$åœ¨$\triangle abc$çš„å¤–æ¥åœ†å†…ï¼Œåˆ™ç¿»è½¬å¯¹è§’çº¿ï¼š
$$\text{flip}(ac, bd) \to \text{flip}(ab, cd)$$

#### 1.2.2 å¢é‡ç®—æ³•

**æ’å…¥ç‚¹**ï¼š

1. æ‰¾åˆ°åŒ…å«æ–°ç‚¹çš„ä¸‰è§’å½¢
2. å°†ä¸‰è§’å½¢åˆ†ä¸ºä¸‰ä¸ªå­ä¸‰è§’å½¢
3. é€’å½’ç¿»è½¬è¿åç©ºåœ†æ€§è´¨çš„è¾¹

**å®šä½ç®—æ³•**ï¼š
ä½¿ç”¨éšæœºè¡Œèµ°å®šä½åŒ…å«ç‚¹çš„ä¸‰è§’å½¢ï¼š

1. ä»ä»»æ„ä¸‰è§’å½¢å¼€å§‹
2. å‘ç›®æ ‡ç‚¹æ–¹å‘ç§»åŠ¨
3. ç›´åˆ°æ‰¾åˆ°åŒ…å«ç‚¹çš„ä¸‰è§’å½¢

#### 1.2.3 çº¦æŸä¸‰è§’å‰–åˆ†

**çº¦æŸè¾¹**ï¼š
ä¿æŒæŒ‡å®šçš„è¾¹åœ¨ä¸‰è§’å‰–åˆ†ä¸­ï¼š
$$E_c \subseteq E(T)$$

å…¶ä¸­$E_c$æ˜¯çº¦æŸè¾¹é›†ï¼Œ$E(T)$æ˜¯ä¸‰è§’å‰–åˆ†çš„è¾¹é›†ã€‚

**ç®—æ³•**ï¼š

1. è®¡ç®—æ— çº¦æŸçš„Delaunayä¸‰è§’å‰–åˆ†
2. æ’å…¥çº¦æŸè¾¹
3. é‡æ–°ä¸‰è§’å‰–åˆ†å—å½±å“çš„åŒºåŸŸ

### 1.3 æœ€è¿‘é‚»æœç´¢æ•°å­¦

#### 1.3.1 k-dæ ‘

**åˆ†å‰²ç­–ç•¥**ï¼š
åœ¨æ·±åº¦$d$çš„èŠ‚ç‚¹ï¼ŒæŒ‰ç¬¬$(d \bmod k)$ç»´åˆ†å‰²ï¼š
$$x_{d \bmod k} \leq \text{median}$$

**æœç´¢ç®—æ³•**ï¼š

1. ä»æ ¹èŠ‚ç‚¹å¼€å§‹
2. é€’å½’æœç´¢åŒ…å«æŸ¥è¯¢ç‚¹çš„å­æ ‘
3. æ£€æŸ¥å¦ä¸€å­æ ‘æ˜¯å¦å¯èƒ½åŒ…å«æ›´è¿‘çš„ç‚¹

**å‰ªææ¡ä»¶**ï¼š
å¦‚æœæŸ¥è¯¢ç‚¹åˆ°åˆ†å‰²å¹³é¢çš„è·ç¦»å¤§äºå½“å‰æœ€è¿‘è·ç¦»ï¼Œåˆ™å‰ªæã€‚

#### 1.3.2 Ræ ‘

**æœ€å°è¾¹ç•ŒçŸ©å½¢ï¼ˆMBRï¼‰**ï¼š
$$MBR(R) = [\min_{p \in R} x_p, \max_{p \in R} x_p] \times [\min_{p \in R} y_p, \max_{p \in R} y_p]$$

**æ’å…¥ç®—æ³•**ï¼š

1. é€‰æ‹©æ’å…¥è·¯å¾„
2. æ’å…¥åˆ°å¶å­èŠ‚ç‚¹
3. å¦‚æœèŠ‚ç‚¹æº¢å‡ºï¼Œåˆ™åˆ†è£‚

**åˆ†è£‚ç­–ç•¥**ï¼š

- çº¿æ€§åˆ†è£‚ï¼šæŒ‰åæ ‡è½´åˆ†è£‚
- äºŒæ¬¡åˆ†è£‚ï¼šé€‰æ‹©åˆ†è£‚åé¢ç§¯å¢åŠ æœ€å°çš„åˆ†è£‚

#### 1.3.3 å±€éƒ¨æ•æ„Ÿå“ˆå¸Œ

**å“ˆå¸Œå‡½æ•°**ï¼š
$$h(x) = \frac{a \cdot x + b}{w}$$

å…¶ä¸­$a$æ˜¯éšæœºå‘é‡ï¼Œ$b$æ˜¯éšæœºåç§»ï¼Œ$w$æ˜¯æ¡¶å®½åº¦ã€‚

**LSHæ—**ï¼š
$$H = \{h : h(x) = \frac{a \cdot x + b}{w}\}$$

å…¶ä¸­$a \sim \mathcal{N}(0, I)$ï¼Œ$b \sim \text{Uniform}(0, w)$ã€‚

**è¿‘ä¼¼æœ€è¿‘é‚»**ï¼š
ä½¿ç”¨å¤šä¸ªå“ˆå¸Œè¡¨æé«˜å¬å›ç‡ï¼š
$$P(\text{collision}) = \text{sim}(x, y)$$

## 2. è®¡ç®—æ‹“æ‰‘æ•°å­¦ç†è®º

### 2.1 æŒä¹…åŒè°ƒ

#### 2.1.1 å•çº¯å¤å½¢

**k-å•çº¯å½¢**ï¼š
$$[v_0, v_1, \ldots, v_k] = \{\sum_{i=0}^{k} \lambda_i v_i : \sum_{i=0}^{k} \lambda_i = 1, \lambda_i \geq 0\}$$

**è¾¹ç•Œç®—å­**ï¼š
$$\partial_k : C_k \to C_{k-1}$$

å¯¹äºk-å•çº¯å½¢$\sigma = [v_0, v_1, \ldots, v_k]$ï¼š
$$\partial_k(\sigma) = \sum_{i=0}^{k} (-1)^i [v_0, \ldots, \hat{v_i}, \ldots, v_k]$$

å…¶ä¸­$\hat{v_i}$è¡¨ç¤ºåˆ é™¤$v_i$ã€‚

#### 2.1.2 åŒè°ƒç¾¤

**é“¾ç¾¤**ï¼š
$$C_k = \text{span}\{\sigma_1, \sigma_2, \ldots, \sigma_n\}$$

**è¾¹ç•Œç¾¤**ï¼š
$$B_k = \text{im } \partial_{k+1}$$

**å¾ªç¯ç¾¤**ï¼š
$$Z_k = \ker \partial_k$$

**åŒè°ƒç¾¤**ï¼š
$$H_k = Z_k / B_k$$

#### 2.1.3 æŒä¹…æ€§

**è¿‡æ»¤**ï¼š
$$K_0 \subseteq K_1 \subseteq \cdots \subseteq K_n$$

**æŒä¹…æ€§å¯¹**ï¼š
$$(\text{birth}, \text{death})$$

å…¶ä¸­birthæ˜¯ç‰¹å¾å‡ºç°çš„æ—¶åˆ»ï¼Œdeathæ˜¯ç‰¹å¾æ¶ˆå¤±çš„æ—¶åˆ»ã€‚

**æŒä¹…æ€§å›¾**ï¼š
åœ¨å¹³é¢ä¸Šç»˜åˆ¶ç‚¹$(\text{birth}, \text{death})$ã€‚

### 2.2 æµå½¢å­¦ä¹ 

#### 2.2.1 å±€éƒ¨çº¿æ€§åµŒå…¥ï¼ˆLLEï¼‰

**é‡æ„æƒé‡**ï¼š
$$\min_W \sum_{i=1}^{n} \|x_i - \sum_{j \in N_i} W_{ij} x_j\|^2$$

çº¦æŸæ¡ä»¶ï¼š
$$\sum_{j \in N_i} W_{ij} = 1$$

**ä½ç»´åµŒå…¥**ï¼š
$$\min_Y \sum_{i=1}^{n} \|y_i - \sum_{j \in N_i} W_{ij} y_j\|^2$$

#### 2.2.2 ç­‰è·æ˜ å°„ï¼ˆIsomapï¼‰

**æµ‹åœ°è·ç¦»**ï¼š
ä½¿ç”¨æœ€çŸ­è·¯å¾„ç®—æ³•è®¡ç®—æµ‹åœ°è·ç¦»ï¼š
$$d_G(i, j) = \min_{p} \sum_{k=1}^{|p|-1} d(p_k, p_{k+1})$$

å…¶ä¸­$p$æ˜¯ä»$i$åˆ°$j$çš„è·¯å¾„ã€‚

**å¤šç»´ç¼©æ”¾ï¼ˆMDSï¼‰**ï¼š
$$\min_Y \sum_{i,j} (d_G(i, j) - \|y_i - y_j\|)^2$$

#### 2.2.3 æ‹‰æ™®æ‹‰æ–¯ç‰¹å¾æ˜ å°„

**ç›¸ä¼¼åº¦çŸ©é˜µ**ï¼š
$$W_{ij} = \exp\left(-\frac{\|x_i - x_j\|^2}{2\sigma^2}\right)$$

**æ‹‰æ™®æ‹‰æ–¯çŸ©é˜µ**ï¼š
$$L = D - W$$

å…¶ä¸­$D_{ii} = \sum_j W_{ij}$ã€‚

**ç‰¹å¾å€¼é—®é¢˜**ï¼š
$$L f = \lambda D f$$

**åµŒå…¥**ï¼š
ä½¿ç”¨æœ€å°çš„$k$ä¸ªéé›¶ç‰¹å¾å€¼å¯¹åº”çš„ç‰¹å¾å‘é‡ã€‚

### 2.3 æ‹“æ‰‘æ•°æ®åˆ†æ

#### 2.3.1 Mapperç®—æ³•

**è¦†ç›–**ï¼š
å°†æ•°æ®ç©ºé—´åˆ’åˆ†ä¸ºé‡å çš„çƒï¼š
$$B_i = \{x : \|x - c_i\| \leq r\}$$

**èšç±»**ï¼š
åœ¨æ¯ä¸ªçƒå†…è¿›è¡Œèšç±»ï¼š
$$C_{ij} = \text{cluster}(B_i \cap B_j)$$

**ç¥ç»å›¾**ï¼š
å°†èšç±»ä½œä¸ºèŠ‚ç‚¹ï¼Œé‡å å…³ç³»ä½œä¸ºè¾¹ï¼š
$$G = (V, E)$$

å…¶ä¸­$V = \{C_{ij}\}$ï¼Œ$E = \{(C_{ij}, C_{kl}) : C_{ij} \cap C_{kl} \neq \emptyset\}$ã€‚

#### 2.3.2 æŒä¹…æ€§æ™¯è§‚

**æŒä¹…æ€§æ™¯è§‚å‡½æ•°**ï¼š
$$\lambda_k(t) = k\text{-th largest value of } \{\Lambda_i(t)\}_{i=1}^{n}$$

å…¶ä¸­$\Lambda_i(t) = \max\{0, \min\{t - b_i, d_i - t\}\}$ã€‚

**LpèŒƒæ•°**ï¼š
$$\|\lambda_k\|_p = \left(\int_0^{\infty} \lambda_k(t)^p dt\right)^{1/p}$$

#### 2.3.3 æŒä¹…æ€§å›¾åƒ

**é«˜æ–¯æ ¸**ï¼š
$$\rho_i(x, y) = \frac{1}{2\pi\sigma^2} \exp\left(-\frac{(x - b_i)^2 + (y - d_i)^2}{2\sigma^2}\right)$$

**æŒä¹…æ€§å›¾åƒ**ï¼š
$$I(x, y) = \sum_{i=1}^{n} w_i \rho_i(x, y)$$

å…¶ä¸­$w_i$æ˜¯æƒé‡å‡½æ•°ã€‚

## 3. å‡ ä½•ä¼˜åŒ–æ•°å­¦ç†è®º

### 3.1 å‡ ä½•è§„åˆ’

#### 3.1.1 æ­£é¡¹å‡ ä½•è§„åˆ’

**ç›®æ ‡å‡½æ•°**ï¼š
$$\min f_0(x) = \sum_{k=1}^{K_0} c_{0k} \prod_{i=1}^{n} x_i^{a_{0ki}}$$

**çº¦æŸæ¡ä»¶**ï¼š
$$f_j(x) = \sum_{k=1}^{K_j} c_{jk} \prod_{i=1}^{n} x_i^{a_{jki}} \leq 1$$

å…¶ä¸­$c_{jk} > 0$ï¼Œ$a_{jki} \in \mathbb{R}$ã€‚

#### 3.1.2 å¯¹å¶é—®é¢˜

**å¯¹æ•°å˜æ¢**ï¼š
$$y_i = \log x_i$$

**å¯¹å¶å‡½æ•°**ï¼š
$$g(\lambda) = \sum_{j=0}^{m} \sum_{k=1}^{K_j} \lambda_{jk} \log \frac{c_{jk}}{\lambda_{jk}}$$

**å¯¹å¶çº¦æŸ**ï¼š
$$\sum_{j=0}^{m} \sum_{k=1}^{K_j} \lambda_{jk} a_{jki} = 0$$

#### 3.1.3 å†…ç‚¹æ³•

**éšœç¢å‡½æ•°**ï¼š
$$B(x) = f_0(x) - \mu \sum_{j=1}^{m} \log(-f_j(x))$$

**ç‰›é¡¿æ­¥**ï¼š
$$\Delta x = -(\nabla^2 B)^{-1} \nabla B$$

### 3.2 å‡¸ä¼˜åŒ–å‡ ä½•

#### 3.2.1 å‡¸é›†

**å‡¸é›†å®šä¹‰**ï¼š
$$C \text{ is convex} \iff \forall x, y \in C, \lambda \in [0,1], \lambda x + (1-\lambda)y \in C$$

**å‡¸åŒ…**ï¼š
$$\text{conv}(S) = \{\sum_{i=1}^{k} \lambda_i x_i : \sum_{i=1}^{k} \lambda_i = 1, \lambda_i \geq 0\}$$

#### 3.2.2 å‡¸å‡½æ•°

**å‡¸å‡½æ•°å®šä¹‰**ï¼š
$$f(\lambda x + (1-\lambda)y) \leq \lambda f(x) + (1-\lambda)f(y)$$

**æ¬¡æ¢¯åº¦**ï¼š
$$g \in \partial f(x) \iff f(y) \geq f(x) + g^T(y-x)$$

#### 3.2.3 å¯¹å¶ç†è®º

**æ‹‰æ ¼æœ—æ—¥å‡½æ•°**ï¼š
$$L(x, \lambda) = f_0(x) + \sum_{i=1}^{m} \lambda_i f_i(x)$$

**å¯¹å¶å‡½æ•°**ï¼š
$$g(\lambda) = \inf_x L(x, \lambda)$$

**å¯¹å¶é—®é¢˜**ï¼š
$$\max g(\lambda) \text{ s.t. } \lambda \geq 0$$

### 3.3 éçº¿æ€§ä¼˜åŒ–

#### 3.3.1 æ¢¯åº¦ä¸‹é™

**æ›´æ–°è§„åˆ™**ï¼š
$$x_{k+1} = x_k - \alpha_k \nabla f(x_k)$$

**æ­¥é•¿é€‰æ‹©**ï¼š

- å›ºå®šæ­¥é•¿ï¼š$\alpha_k = \alpha$
- çº¿æœç´¢ï¼š$\alpha_k = \arg\min_{\alpha} f(x_k - \alpha \nabla f(x_k))$
- è‡ªé€‚åº”æ­¥é•¿ï¼š$\alpha_k = \frac{\|\nabla f(x_k)\|^2}{\nabla f(x_k)^T H_k \nabla f(x_k)}$

#### 3.3.2 ç‰›é¡¿æ³•

**ç‰›é¡¿æ­¥**ï¼š
$$\Delta x = -H^{-1} \nabla f(x)$$

å…¶ä¸­$H = \nabla^2 f(x)$æ˜¯HessiançŸ©é˜µã€‚

**æ‹Ÿç‰›é¡¿æ³•**ï¼š
$$H_{k+1} = H_k + \frac{(y_k - H_k s_k)(y_k - H_k s_k)^T}{(y_k - H_k s_k)^T s_k}$$

å…¶ä¸­$s_k = x_{k+1} - x_k$ï¼Œ$y_k = \nabla f(x_{k+1}) - \nabla f(x_k)$ã€‚

#### 3.3.3 çº¦æŸä¼˜åŒ–

**KKTæ¡ä»¶**ï¼š
$$\nabla f(x^*) + \sum_{i=1}^{m} \lambda_i^* \nabla g_i(x^*) + \sum_{j=1}^{p} \mu_j^* \nabla h_j(x^*) = 0$$
$$g_i(x^*) \leq 0, \quad \lambda_i^* \geq 0, \quad \lambda_i^* g_i(x^*) = 0$$
$$h_j(x^*) = 0$$

## 4. å‡ ä½•æŸ¥è¯¢æ•°å­¦ç†è®º

### 4.1 èŒƒå›´æŸ¥è¯¢

#### 4.1.1 æ­£äº¤èŒƒå›´æŸ¥è¯¢

**æŸ¥è¯¢**ï¼š
$$Q = [a_1, b_1] \times [a_2, b_2] \times \cdots \times [a_d, b_d]$$

**ç‚¹æŸ¥è¯¢**ï¼š
$$\text{query}(Q) = \{p \in P : p \in Q\}$$

**æ•°æ®ç»“æ„**ï¼š

- k-dæ ‘ï¼š$O(n^{1-1/d} + k)$æŸ¥è¯¢æ—¶é—´
- Ræ ‘ï¼š$O(\log n + k)$æŸ¥è¯¢æ—¶é—´
- å››å‰æ ‘ï¼š$O(\log n + k)$æŸ¥è¯¢æ—¶é—´

#### 4.1.2 åŠç©ºé—´æŸ¥è¯¢

**åŠç©ºé—´**ï¼š
$$H = \{x : a^T x \leq b\}$$

**æŸ¥è¯¢ç®—æ³•**ï¼š

1. ä½¿ç”¨å‡¸åŒ…æ•°æ®ç»“æ„
2. äºŒåˆ†æœç´¢è¾¹ç•Œ
3. æŠ¥å‘ŠåŠç©ºé—´å†…çš„ç‚¹

#### 4.1.3 åœ†èŒƒå›´æŸ¥è¯¢

**åœ†æŸ¥è¯¢**ï¼š
$$C = \{x : \|x - c\| \leq r\}$$

**ç®—æ³•**ï¼š

1. ä½¿ç”¨ç½‘æ ¼æˆ–å››å‰æ ‘
2. æ£€æŸ¥ä¸åœ†çš„ç›¸äº¤
3. ç²¾ç¡®è®¡ç®—è·ç¦»

### 4.2 æœ€è¿‘é‚»æŸ¥è¯¢

#### 4.2.1 ç²¾ç¡®æœ€è¿‘é‚»

**æŸ¥è¯¢**ï¼š
$$\text{NN}(q) = \arg\min_{p \in P} \|q - p\|$$

**ç®—æ³•**ï¼š

- æš´åŠ›æœç´¢ï¼š$O(n)$
- k-dæ ‘ï¼š$O(\log n)$å¹³å‡æƒ…å†µ
- Ræ ‘ï¼š$O(\log n)$å¹³å‡æƒ…å†µ

#### 4.2.2 è¿‘ä¼¼æœ€è¿‘é‚»

**c-è¿‘ä¼¼**ï¼š
$$\|q - p\| \leq c \cdot \|q - p^*\|$$

å…¶ä¸­$p^*$æ˜¯ç²¾ç¡®æœ€è¿‘é‚»ã€‚

**ç®—æ³•**ï¼š

- å±€éƒ¨æ•æ„Ÿå“ˆå¸Œï¼š$O(\log n)$æŸ¥è¯¢æ—¶é—´
- éšæœºæŠ•å½±ï¼š$O(d \log n)$æŸ¥è¯¢æ—¶é—´
- æ ‘ç»“æ„ï¼š$O(\log n)$æŸ¥è¯¢æ—¶é—´

#### 4.2.3 k-æœ€è¿‘é‚»

**æŸ¥è¯¢**ï¼š
$$\text{kNN}(q) = \{p_1, p_2, \ldots, p_k : \|q - p_i\| \leq \|q - p_j\| \text{ for } i < j\}$$

**ç®—æ³•**ï¼š

1. ä½¿ç”¨ä¼˜å…ˆé˜Ÿåˆ—ç»´æŠ¤kä¸ªæœ€è¿‘é‚»
2. éå†æ•°æ®ç»“æ„
3. æ›´æ–°æœ€è¿‘é‚»åˆ—è¡¨

### 4.3 ç›¸äº¤æŸ¥è¯¢

#### 4.3.1 çº¿æ®µç›¸äº¤

**çº¿æ®µè¡¨ç¤º**ï¼š
$$s = (p_1, p_2) = \{p_1 + t(p_2 - p_1) : t \in [0,1]\}$$

**ç›¸äº¤åˆ¤æ–­**ï¼š
$$\text{intersect}(s_1, s_2) = \text{ccw}(p_1, p_2, q_1) \cdot \text{ccw}(p_1, p_2, q_2) < 0$$
$$\text{and } \text{ccw}(q_1, q_2, p_1) \cdot \text{ccw}(q_1, q_2, p_2) < 0$$

#### 4.3.2 å¤šè¾¹å½¢ç›¸äº¤

**å°„çº¿æ³•**ï¼š

1. ä»ç‚¹$p$å‘å³å‘å°„å°„çº¿
2. è®¡ç®—ä¸å¤šè¾¹å½¢è¾¹ç•Œçš„äº¤ç‚¹æ•°
3. å¦‚æœäº¤ç‚¹æ•°ä¸ºå¥‡æ•°ï¼Œåˆ™ç‚¹åœ¨å¤šè¾¹å½¢å†…

**æ‰«æçº¿ç®—æ³•**ï¼š

1. æŒ‰xåæ ‡æ’åºæ‰€æœ‰é¡¶ç‚¹
2. ç»´æŠ¤æ´»åŠ¨è¾¹åˆ—è¡¨
3. å¤„ç†ç›¸äº¤äº‹ä»¶

#### 4.3.3 å‡¸åŒ…ç›¸äº¤

**åˆ†ç¦»è½´å®šç†**ï¼š
ä¸¤ä¸ªå‡¸åŒ…ä¸ç›¸äº¤å½“ä¸”ä»…å½“å­˜åœ¨ä¸€æ¡åˆ†ç¦»è½´ã€‚

**ç®—æ³•**ï¼š

1. æ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„åˆ†ç¦»è½´
2. ä½¿ç”¨çº¿æ€§è§„åˆ’åˆ¤æ–­åˆ†ç¦»
3. å¦‚æœä¸å­˜åœ¨åˆ†ç¦»è½´ï¼Œåˆ™ç›¸äº¤

## 5. æŠ€æœ¯å®ç°

### 5.1 Pythonå®ç°

```python
import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial import ConvexHull, Delaunay
from scipy.spatial.distance import cdist
import cvxpy as cp

# å‡ ä½•ç®—æ³•å®ç°
class GeometricAlgorithms:
    def __init__(self):
        pass

    def graham_scan(self, points):
        """Grahamæ‰«æç®—æ³•è®¡ç®—å‡¸åŒ…"""
        points = np.array(points)
        n = len(points)

        if n < 3:
            return points

        # æ‰¾åˆ°æœ€ä¸‹æ–¹çš„ç‚¹
        bottom_idx = np.argmin(points[:, 1])
        bottom_point = points[bottom_idx]

        # æŒ‰æè§’æ’åºå…¶ä»–ç‚¹
        def polar_angle(p):
            return np.arctan2(p[1] - bottom_point[1], p[0] - bottom_point[0])

        other_points = np.delete(points, bottom_idx, axis=0)
        sorted_indices = np.argsort([polar_angle(p) for p in other_points])
        sorted_points = other_points[sorted_indices]

        # Grahamæ‰«æ
        hull = [bottom_point, sorted_points[0]]

        for i in range(1, len(sorted_points)):
            while len(hull) > 1 and self.ccw(hull[-2], hull[-1], sorted_points[i]) <= 0:
                hull.pop()
            hull.append(sorted_points[i])

        return np.array(hull)

    def ccw(self, p1, p2, p3):
        """åˆ¤æ–­ä¸‰ç‚¹æ˜¯å¦æ„æˆå·¦è½¬"""
        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])

    def delaunay_triangulation(self, points):
        """Delaunayä¸‰è§’å‰–åˆ†"""
        tri = Delaunay(points)
        return tri.simplices

    def kdtree_search(self, points, query_point, k=1):
        """k-dæ ‘æœ€è¿‘é‚»æœç´¢"""
        from scipy.spatial import cKDTree

        tree = cKDTree(points)
        distances, indices = tree.query(query_point, k=k)
        return indices, distances

# è®¡ç®—æ‹“æ‰‘å®ç°
class ComputationalTopology:
    def __init__(self):
        pass

    def persistent_homology(self, points, max_dimension=2):
        """è®¡ç®—æŒä¹…åŒè°ƒ"""
        from ripser import ripser

        # è®¡ç®—Vietoris-Ripså¤å½¢
        diagrams = ripser(points)['dgms']

        return diagrams

    def mapper_algorithm(self, data, filter_function, cover_intervals, cluster_function):
        """Mapperç®—æ³•"""
        # åº”ç”¨è¿‡æ»¤å‡½æ•°
        filter_values = filter_function(data)

        # åˆ›å»ºè¦†ç›–
        cover = []
        for interval in cover_intervals:
            mask = (filter_values >= interval[0]) & (filter_values <= interval[1])
            if np.any(mask):
                cover.append(data[mask])

        # èšç±»æ¯ä¸ªè¦†ç›–å…ƒç´ 
        clusters = []
        for cover_element in cover:
            if len(cover_element) > 1:
                cluster_labels = cluster_function(cover_element)
                for label in np.unique(cluster_labels):
                    clusters.append(cover_element[cluster_labels == label])

        return clusters

# å‡ ä½•ä¼˜åŒ–å®ç°
class GeometricOptimization:
    def __init__(self):
        pass

    def geometric_programming(self, objective, constraints):
        """å‡ ä½•è§„åˆ’"""
        # ä½¿ç”¨CVXPYæ±‚è§£å‡ ä½•è§„åˆ’
        x = cp.Variable()

        # ç›®æ ‡å‡½æ•°å’Œçº¦æŸ
        obj = cp.Minimize(objective)
        prob = cp.Problem(obj, constraints)

        prob.solve()
        return x.value

    def convex_optimization(self, objective, constraints):
        """å‡¸ä¼˜åŒ–"""
        x = cp.Variable()

        obj = cp.Minimize(objective)
        prob = cp.Problem(obj, constraints)

        prob.solve()
        return x.value

    def newton_method(self, f, grad_f, hess_f, x0, max_iter=100, tol=1e-6):
        """ç‰›é¡¿æ³•"""
        x = x0

        for i in range(max_iter):
            grad = grad_f(x)
            hess = hess_f(x)

            # æ±‚è§£çº¿æ€§ç³»ç»Ÿ
            delta = np.linalg.solve(hess, -grad)
            x = x + delta

            if np.linalg.norm(delta) < tol:
                break

        return x

# å‡ ä½•æŸ¥è¯¢å®ç°
class GeometricQueries:
    def __init__(self):
        pass

    def range_query(self, points, query_range):
        """èŒƒå›´æŸ¥è¯¢"""
        # æ­£äº¤èŒƒå›´æŸ¥è¯¢
        mask = np.ones(len(points), dtype=bool)

        for i, (min_val, max_val) in enumerate(query_range):
            mask &= (points[:, i] >= min_val) & (points[:, i] <= max_val)

        return points[mask]

    def nearest_neighbor(self, points, query_point):
        """æœ€è¿‘é‚»æŸ¥è¯¢"""
        distances = np.linalg.norm(points - query_point, axis=1)
        nearest_idx = np.argmin(distances)
        return nearest_idx, distances[nearest_idx]

    def k_nearest_neighbors(self, points, query_point, k):
        """k-æœ€è¿‘é‚»æŸ¥è¯¢"""
        distances = np.linalg.norm(points - query_point, axis=1)
        nearest_indices = np.argsort(distances)[:k]
        return nearest_indices, distances[nearest_indices]

    def line_intersection(self, line1, line2):
        """çº¿æ®µç›¸äº¤åˆ¤æ–­"""
        p1, p2 = line1
        q1, q2 = line2

        def ccw(a, b, c):
            return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])

        # æ£€æŸ¥ç›¸äº¤
        d1 = ccw(p1, p2, q1)
        d2 = ccw(p1, p2, q2)
        d3 = ccw(q1, q2, p1)
        d4 = ccw(q1, q2, p2)

        return (d1 * d2 < 0) and (d3 * d4 < 0)

# ä½¿ç”¨ç¤ºä¾‹
# ç”Ÿæˆç¤ºä¾‹æ•°æ®
np.random.seed(42)
n_points = 50
points = np.random.rand(n_points, 2)

# å‡ ä½•ç®—æ³•
ga = GeometricAlgorithms()
hull = ga.graham_scan(points)
triangles = ga.delaunay_triangulation(points)

# å¯è§†åŒ–ç»“æœ
plt.figure(figsize=(15, 5))

plt.subplot(1, 3, 1)
plt.scatter(points[:, 0], points[:, 1], c='blue', alpha=0.6)
plt.plot(hull[:, 0], hull[:, 1], 'r-', linewidth=2)
plt.plot([hull[-1, 0], hull[0, 0]], [hull[-1, 1], hull[0, 1]], 'r-', linewidth=2)
plt.title('å‡¸åŒ…')
plt.xlabel('x')
plt.ylabel('y')

plt.subplot(1, 3, 2)
plt.triplot(points[:, 0], points[:, 1], triangles, 'g-', alpha=0.5)
plt.scatter(points[:, 0], points[:, 1], c='blue', alpha=0.6)
plt.title('Delaunayä¸‰è§’å‰–åˆ†')
plt.xlabel('x')
plt.ylabel('y')

plt.subplot(1, 3, 3)
query_point = np.array([0.5, 0.5])
indices, distances = ga.kdtree_search(points, query_point, k=5)
plt.scatter(points[:, 0], points[:, 1], c='blue', alpha=0.6)
plt.scatter(points[indices, 0], points[indices, 1], c='red', s=100)
plt.scatter(query_point[0], query_point[1], c='green', s=200, marker='*')
plt.title('k-æœ€è¿‘é‚»æŸ¥è¯¢')
plt.xlabel('x')
plt.ylabel('y')

plt.tight_layout()
plt.show()

# è®¡ç®—æ‹“æ‰‘
ct = ComputationalTopology()
diagrams = ct.persistent_homology(points)

# å¯è§†åŒ–æŒä¹…æ€§å›¾
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
for i, diagram in enumerate(diagrams):
    if len(diagram) > 0:
        plt.scatter(diagram[:, 0], diagram[:, 1], label=f'H{i}')
plt.plot([0, 1], [0, 1], 'k--', alpha=0.5)
plt.xlabel('Birth')
plt.ylabel('Death')
plt.title('æŒä¹…æ€§å›¾')
plt.legend()

plt.subplot(1, 2, 2)
# å¯è§†åŒ–æ•°æ®ç‚¹
plt.scatter(points[:, 0], points[:, 1], c='blue', alpha=0.6)
plt.title('æ•°æ®ç‚¹')
plt.xlabel('x')
plt.ylabel('y')

plt.tight_layout()
plt.show()

# å‡ ä½•æŸ¥è¯¢
gq = GeometricQueries()

# èŒƒå›´æŸ¥è¯¢
query_range = [(0.2, 0.8), (0.3, 0.7)]
range_points = gq.range_query(points, query_range)

# æœ€è¿‘é‚»æŸ¥è¯¢
query_point = np.array([0.5, 0.5])
nearest_idx, distance = gq.nearest_neighbor(points, query_point)

# å¯è§†åŒ–æŸ¥è¯¢ç»“æœ
plt.figure(figsize=(12, 4))

plt.subplot(1, 3, 1)
plt.scatter(points[:, 0], points[:, 1], c='blue', alpha=0.6)
plt.scatter(range_points[:, 0], range_points[:, 1], c='red', s=100)
plt.title('èŒƒå›´æŸ¥è¯¢')
plt.xlabel('x')
plt.ylabel('y')

plt.subplot(1, 3, 2)
plt.scatter(points[:, 0], points[:, 1], c='blue', alpha=0.6)
plt.scatter(points[nearest_idx, 0], points[nearest_idx, 1], c='red', s=200)
plt.scatter(query_point[0], query_point[1], c='green', s=200, marker='*')
plt.title('æœ€è¿‘é‚»æŸ¥è¯¢')
plt.xlabel('x')
plt.ylabel('y')

plt.subplot(1, 3, 3)
# çº¿æ®µç›¸äº¤ç¤ºä¾‹
line1 = (np.array([0.2, 0.2]), np.array([0.8, 0.8]))
line2 = (np.array([0.2, 0.8]), np.array([0.8, 0.2]))
intersects = gq.line_intersection(line1, line2)

plt.plot([line1[0][0], line1[1][0]], [line1[0][1], line1[1][1]], 'b-', linewidth=2)
plt.plot([line2[0][0], line2[1][0]], [line2[0][1], line2[1][1]], 'r-', linewidth=2)
plt.title(f'çº¿æ®µç›¸äº¤: {intersects}')
plt.xlabel('x')
plt.ylabel('y')

plt.tight_layout()
plt.show()
```

### 5.2 é«˜çº§å‡ ä½•ç®—æ³•å®ç°

```python
import numpy as np
from scipy.spatial import ConvexHull
from scipy.optimize import minimize
import cvxpy as cp

# é«˜çº§å‡ ä½•ç®—æ³•
class AdvancedGeometricAlgorithms:
    def __init__(self):
        pass

    def voronoi_diagram(self, points):
        """Voronoiå›¾"""
        from scipy.spatial import Voronoi

        vor = Voronoi(points)
        return vor

    def minimum_spanning_tree(self, points):
        """æœ€å°ç”Ÿæˆæ ‘"""
        from scipy.spatial.distance import pdist, squareform
        from scipy.sparse.csgraph import minimum_spanning_tree

        # è®¡ç®—è·ç¦»çŸ©é˜µ
        distances = squareform(pdist(points))

        # è®¡ç®—æœ€å°ç”Ÿæˆæ ‘
        mst = minimum_spanning_tree(distances)
        return mst

    def traveling_salesman(self, points):
        """æ—…è¡Œå•†é—®é¢˜"""
        from scipy.spatial.distance import pdist, squareform
        from scipy.optimize import linear_sum_assignment

        # è®¡ç®—è·ç¦»çŸ©é˜µ
        distances = squareform(pdist(points))

        # ä½¿ç”¨çº¿æ€§åˆ†é…é—®é¢˜è¿‘ä¼¼
        row_ind, col_ind = linear_sum_assignment(distances)
        return row_ind, col_ind

    def geometric_median(self, points, max_iter=100, tol=1e-6):
        """å‡ ä½•ä¸­ä½æ•°"""
        n_points, n_dim = points.shape

        # åˆå§‹åŒ–
        median = np.mean(points, axis=0)

        for _ in range(max_iter):
            distances = np.linalg.norm(points - median, axis=1)

            # é¿å…é™¤é›¶
            distances = np.maximum(distances, 1e-10)

            # Weiszfeldç®—æ³•
            weights = 1 / distances
            new_median = np.average(points, axis=0, weights=weights)

            if np.linalg.norm(new_median - median) < tol:
                break
            median = new_median

        return median

# å‡ ä½•ä¼˜åŒ–å®ç°
class GeometricOptimization:
    def __init__(self):
        pass

    def circle_packing(self, container_shape, circle_radii):
        """åœ†å¡«å……é—®é¢˜"""
        n_circles = len(circle_radii)

        # å†³ç­–å˜é‡ï¼šåœ†å¿ƒåæ ‡
        x = cp.Variable(n_circles)
        y = cp.Variable(n_circles)

        # ç›®æ ‡å‡½æ•°ï¼šæœ€å¤§åŒ–å¡«å……å¯†åº¦
        total_area = cp.sum(cp.pi * cp.square(circle_radii))
        objective = cp.Maximize(total_area)

        # çº¦æŸæ¡ä»¶
        constraints = []

        # åœ†åœ¨å®¹å™¨å†…
        for i in range(n_circles):
            constraints.append(x[i] >= circle_radii[i])
            constraints.append(x[i] <= container_shape[0] - circle_radii[i])
            constraints.append(y[i] >= circle_radii[i])
            constraints.append(y[i] <= container_shape[1] - circle_radii[i])

        # åœ†ä¸ç›¸äº¤
        for i in range(n_circles):
            for j in range(i+1, n_circles):
                distance = cp.sqrt(cp.square(x[i] - x[j]) + cp.square(y[i] - y[j]))
                constraints.append(distance >= circle_radii[i] + circle_radii[j])

        # æ±‚è§£
        prob = cp.Problem(objective, constraints)
        prob.solve()

        return x.value, y.value

    def facility_location(self, demand_points, facility_costs, max_facilities):
        """è®¾æ–½é€‰å€é—®é¢˜"""
        n_demands = len(demand_points)
        n_potential_facilities = len(facility_costs)

        # å†³ç­–å˜é‡
        facility_built = cp.Variable(n_potential_facilities, boolean=True)
        assignment = cp.Variable((n_demands, n_potential_facilities), boolean=True)

        # ç›®æ ‡å‡½æ•°
        total_cost = cp.sum(facility_costs * facility_built)
        objective = cp.Minimize(total_cost)

        # çº¦æŸæ¡ä»¶
        constraints = []

        # æ¯ä¸ªéœ€æ±‚ç‚¹åªèƒ½åˆ†é…ç»™ä¸€ä¸ªè®¾æ–½
        for i in range(n_demands):
            constraints.append(cp.sum(assignment[i, :]) == 1)

        # åªèƒ½åˆ†é…ç»™å·²å»ºè®¾çš„è®¾æ–½
        for i in range(n_demands):
            for j in range(n_potential_facilities):
                constraints.append(assignment[i, j] <= facility_built[j])

        # è®¾æ–½æ•°é‡é™åˆ¶
        constraints.append(cp.sum(facility_built) <= max_facilities)

        # æ±‚è§£
        prob = cp.Problem(objective, constraints)
        prob.solve()

        return facility_built.value, assignment.value

# ä½¿ç”¨ç¤ºä¾‹
# ç”Ÿæˆç¤ºä¾‹æ•°æ®
np.random.seed(42)
n_points = 20
points = np.random.rand(n_points, 2)

# é«˜çº§å‡ ä½•ç®—æ³•
aga = AdvancedGeometricAlgorithms()

# Voronoiå›¾
vor = aga.voronoi_diagram(points)

# æœ€å°ç”Ÿæˆæ ‘
mst = aga.minimum_spanning_tree(points)

# å‡ ä½•ä¸­ä½æ•°
median = aga.geometric_median(points)

# å¯è§†åŒ–ç»“æœ
plt.figure(figsize=(15, 5))

plt.subplot(1, 3, 1)
# Voronoiå›¾
plt.scatter(points[:, 0], points[:, 1], c='red', s=100)
for simplex in vor.ridge_vertices:
    if -1 not in simplex:
        plt.plot(vor.vertices[simplex, 0], vor.vertices[simplex, 1], 'b-')
plt.title('Voronoiå›¾')
plt.xlabel('x')
plt.ylabel('y')

plt.subplot(1, 3, 2)
# æœ€å°ç”Ÿæˆæ ‘
plt.scatter(points[:, 0], points[:, 1], c='red', s=100)
for i in range(len(points)):
    for j in range(i+1, len(points)):
        if mst[i, j] > 0:
            plt.plot([points[i, 0], points[j, 0]],
                    [points[i, 1], points[j, 1]], 'g-')
plt.title('æœ€å°ç”Ÿæˆæ ‘')
plt.xlabel('x')
plt.ylabel('y')

plt.subplot(1, 3, 3)
# å‡ ä½•ä¸­ä½æ•°
plt.scatter(points[:, 0], points[:, 1], c='blue', alpha=0.6)
plt.scatter(median[0], median[1], c='red', s=200, marker='*')
plt.title('å‡ ä½•ä¸­ä½æ•°')
plt.xlabel('x')
plt.ylabel('y')

plt.tight_layout()
plt.show()

# å‡ ä½•ä¼˜åŒ–
go = GeometricOptimization()

# åœ†å¡«å……é—®é¢˜
container_shape = (10, 10)
circle_radii = [1, 1, 1, 1, 1]
x_centers, y_centers = go.circle_packing(container_shape, circle_radii)

# å¯è§†åŒ–åœ†å¡«å……
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
for i, (x, y, r) in enumerate(zip(x_centers, y_centers, circle_radii)):
    circle = plt.Circle((x, y), r, fill=False, color='blue')
    plt.gca().add_patch(circle)
plt.xlim(0, container_shape[0])
plt.ylim(0, container_shape[1])
plt.title('åœ†å¡«å……')
plt.xlabel('x')
plt.ylabel('y')

plt.subplot(1, 2, 2)
# è®¾æ–½é€‰å€é—®é¢˜
demand_points = np.random.rand(10, 2)
facility_costs = np.random.rand(5)
max_facilities = 3

facility_built, assignment = go.facility_location(demand_points, facility_costs, max_facilities)

# å¯è§†åŒ–è®¾æ–½é€‰å€
built_facilities = np.where(facility_built > 0.5)[0]
plt.scatter(demand_points[:, 0], demand_points[:, 1], c='blue', label='éœ€æ±‚ç‚¹')
plt.scatter(demand_points[built_facilities, 0], demand_points[built_facilities, 1],
           c='red', s=200, marker='s', label='è®¾æ–½')
plt.title('è®¾æ–½é€‰å€')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()

plt.tight_layout()
plt.show()
```

## 6. åº”ç”¨æ¡ˆä¾‹

### 6.1 è®¡ç®—æœºå›¾å½¢å­¦åº”ç”¨

**å¤šè¾¹å½¢è£å‰ª**ï¼š

- ä½¿ç”¨Sutherland-Hodgmanç®—æ³•
- å¤„ç†å¤æ‚å¤šè¾¹å½¢ç›¸äº¤
- å®ç°å›¾å½¢æ¸²æŸ“

### 6.2 æœºå™¨äººå­¦åº”ç”¨

**è·¯å¾„è§„åˆ’**ï¼š

- ä½¿ç”¨Voronoiå›¾è¿›è¡Œè·¯å¾„è§„åˆ’
- é¿å…éšœç¢ç‰©çš„æœ€ä¼˜è·¯å¾„
- å¤šæœºå™¨äººåè°ƒ

### 6.3 åœ°ç†ä¿¡æ¯ç³»ç»Ÿåº”ç”¨

**ç©ºé—´æŸ¥è¯¢**ï¼š

- èŒƒå›´æŸ¥è¯¢å’Œæœ€è¿‘é‚»æŸ¥è¯¢
- ç©ºé—´ç´¢å¼•ç»“æ„
- åœ°ç†æ•°æ®åˆ†æ

## 7. å‰æ²¿å‘å±•

### 7.1 è®¡ç®—å‡ ä½•ä¸æœºå™¨å­¦ä¹ 

**å‡ ä½•æ·±åº¦å­¦ä¹ **ï¼š

- å›¾ç¥ç»ç½‘ç»œåœ¨å‡ ä½•æ•°æ®ä¸Šçš„åº”ç”¨
- å‡ ä½•ç‰¹å¾å­¦ä¹ 
- å½¢çŠ¶åˆ†æ

### 7.2 æ‹“æ‰‘æ•°æ®åˆ†æ

**æŒä¹…åŒè°ƒåº”ç”¨**ï¼š

- æ•°æ®å½¢çŠ¶åˆ†æ
- ç‰¹å¾æå–
- æ¨¡å¼è¯†åˆ«

### 7.3 å‡ ä½•ä¼˜åŒ–å‰æ²¿

**å¤§è§„æ¨¡å‡ ä½•ä¼˜åŒ–**ï¼š

- åˆ†å¸ƒå¼å‡ ä½•ç®—æ³•
- å¹¶è¡Œè®¡ç®—
- å®æ—¶ä¼˜åŒ–

## 8. æ€»ç»“ä¸å±•æœ›

### 8.1 æ ¸å¿ƒè¦ç‚¹æ€»ç»“

1. **å‡ ä½•ç®—æ³•æ•°å­¦åŸºç¡€**ï¼š
   - å‡¸åŒ…ç®—æ³•çš„æ•°å­¦åŸç†
   - ä¸‰è§’å‰–åˆ†çš„å‡ ä½•æ€§è´¨
   - æœ€è¿‘é‚»æœç´¢çš„ç®—æ³•è®¾è®¡

2. **è®¡ç®—æ‹“æ‰‘æ•°å­¦ç†è®º**ï¼š
   - æŒä¹…åŒè°ƒçš„ä»£æ•°æ–¹æ³•
   - æµå½¢å­¦ä¹ çš„å‡ ä½•ç†è®º
   - æ‹“æ‰‘æ•°æ®åˆ†æçš„æ•°å­¦å·¥å…·

3. **å‡ ä½•ä¼˜åŒ–æ•°å­¦åŸç†**ï¼š
   - å‡ ä½•è§„åˆ’çš„å‡¸ä¼˜åŒ–æ–¹æ³•
   - å‡¸ä¼˜åŒ–çš„å‡ ä½•ç†è®º
   - éçº¿æ€§ä¼˜åŒ–çš„æ•°å€¼æ–¹æ³•

4. **å‡ ä½•æŸ¥è¯¢æ•°å­¦æ–¹æ³•**ï¼š
   - èŒƒå›´æŸ¥è¯¢çš„æ•°æ®ç»“æ„
   - æœ€è¿‘é‚»æŸ¥è¯¢çš„ç®—æ³•
   - ç›¸äº¤æŸ¥è¯¢çš„å‡ ä½•åˆ¤æ–­

### 8.2 å‘å±•è¶‹åŠ¿

1. **ç†è®ºå‘å±•**ï¼š
   - å‡ ä½•æ·±åº¦å­¦ä¹ 
   - æ‹“æ‰‘æ•°æ®åˆ†æ
   - å¤§è§„æ¨¡å‡ ä½•ç®—æ³•

2. **æ–¹æ³•åˆ›æ–°**ï¼š
   - å¹¶è¡Œå‡ ä½•ç®—æ³•
   - å®æ—¶å‡ ä½•è®¡ç®—
   - å‡ ä½•æœºå™¨å­¦ä¹ 

3. **åº”ç”¨æ‹“å±•**ï¼š
   - è®¡ç®—æœºå›¾å½¢å­¦
   - æœºå™¨äººå­¦
   - åœ°ç†ä¿¡æ¯ç³»ç»Ÿ

### 8.3 æŒ‘æˆ˜ä¸æœºé‡

**ä¸»è¦æŒ‘æˆ˜**ï¼š

- é«˜ç»´å‡ ä½•é—®é¢˜çš„è®¡ç®—å¤æ‚åº¦
- å¤§è§„æ¨¡æ•°æ®çš„å‡ ä½•å¤„ç†
- å®æ—¶å‡ ä½•ç®—æ³•çš„è®¾è®¡

**å‘å±•æœºé‡**ï¼š

- äººå·¥æ™ºèƒ½ä¸å‡ ä½•è®¡ç®—çš„ç»“åˆ
- è·¨å­¦ç§‘åº”ç”¨çš„æ‹“å±•
- æ–°æŠ€æœ¯çš„å‘å±•å’Œåº”ç”¨

---

## ğŸ“š å‚è€ƒæ–‡çŒ®

1. de Berg, M., Cheong, O., van Kreveld, M., & Overmars, M. (2008). Computational Geometry: Algorithms and Applications. Springer.
2. Edelsbrunner, H., & Harer, J. (2010). Computational Topology: An Introduction. American Mathematical Society.
3. Boyd, S., & Vandenberghe, L. (2004). Convex Optimization. Cambridge University Press.
4. Preparata, F. P., & Shamos, M. I. (1985). Computational Geometry: An Introduction. Springer.
5. Edelsbrunner, H. (1987). Algorithms in Combinatorial Geometry. Springer.

## ğŸ”— ç›¸å…³é“¾æ¥

- [å‡ ä½•å­¦åŸºç¡€](../04-å‡ ä½•å­¦/01-æ¬§å‡ é‡Œå¾—å‡ ä½•.md)
- [æ‹“æ‰‘å­¦åŸºç¡€](../05-æ‹“æ‰‘å­¦/01-ç‚¹é›†æ‹“æ‰‘.md)
- [ä¼˜åŒ–ç†è®º](../08-è®¡ç®—æ•°å­¦/02-ä¼˜åŒ–ç†è®º.md)
- [æ•°æ®ç§‘å­¦æ•°å­¦](./11-æ•°æ®ç§‘å­¦æ•°å­¦-æ·±åŒ–ç‰ˆ.md)

---

*æœ¬æ·±åŒ–ç‰ˆæ–‡æ¡£æ·±å…¥æ¢è®¨äº†è®¡ç®—å‡ ä½•çš„æ•°å­¦ç†è®ºåŸºç¡€ï¼Œä¸ºç†è§£å‡ ä½•ç®—æ³•ã€è®¡ç®—æ‹“æ‰‘ã€å‡ ä½•ä¼˜åŒ–æä¾›äº†å¼ºå¤§çš„æ•°å­¦å·¥å…·ã€‚*
