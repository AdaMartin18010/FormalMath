# 运筹学基础版

## 概述

本文档是运筹学理论的基础版本，涵盖线性规划、非线性规划、动态规划、排队论等基础主题。
这些内容构成了运筹学的核心理论框架。

## 目录

- [运筹学基础版](#运筹学基础版)
  - [概述](#概述)
  - [目录](#目录)
  - [线性规划](#线性规划)
    - [线性规划问题](#线性规划问题)
    - [单纯形法](#单纯形法)
  - [非线性规划](#非线性规划)
    - [无约束优化](#无约束优化)
    - [约束优化](#约束优化)
  - [动态规划](#动态规划)
    - [动态规划原理](#动态规划原理)
    - [随机动态规划](#随机动态规划)
  - [排队论](#排队论)
    - [排队系统](#排队系统)
    - [M/M/1队列](#mm1队列)
  - [网络优化](#网络优化)
    - [最小生成树](#最小生成树)
    - [最短路径](#最短路径)
  - [形式化实现](#形式化实现)
    - [Lean 4 实现](#lean-4-实现)
    - [Haskell 实现](#haskell-实现)
    - [Rust 实现](#rust-实现)
  - [总结](#总结)

## 线性规划

### 线性规划问题

**定义 1.1** (线性规划)
线性规划问题是寻找向量 $x \in \mathbb{R}^n$，使得：

$$
\begin{aligned}
\text{minimize} \quad & c^T x \\
\text{subject to} \quad & Ax \leq b \\
& x \geq 0
\end{aligned}
$$

其中 $c \in \mathbb{R}^n$，$A \in \mathbb{R}^{m \times n}$，$b \in \mathbb{R}^m$。

**定理 1.1** (线性规划基本定理)
线性规划的最优解（如果存在）必定在可行域的顶点处达到。

**证明**：

```lean
theorem linear_programming_fundamental {A : matrix ℝ m n} {b : ℝ^m} {c : ℝ^n} :
  let feasible_set := {x : ℝ^n | A * x ≤ b ∧ x ≥ 0}
  let objective := λ x, c • x
  in ∀ x : ℝ^n, x ∈ feasible_set ∧ is_optimal objective x →
    is_vertex feasible_set x :=
begin
  -- 线性规划基本定理的形式化证明
  -- 利用凸集理论
  sorry
end
```

### 单纯形法

**算法 1.1** (单纯形法)

1. 将问题转化为标准形式
2. 找到初始基本可行解
3. 选择进入变量（负系数最大的非基本变量）
4. 选择离开变量（最小比值测试）
5. 更新基本解
6. 重复步骤3-5直到最优

**示例 1.1** (生产计划问题)
某工厂生产两种产品，每种产品需要不同的资源，目标是最大化利润：

$$
\begin{aligned}
\text{maximize} \quad & 3x_1 + 2x_2 \\
\text{subject to} \quad & 2x_1 + x_2 \leq 8 \\
& x_1 + 2x_2 \leq 6 \\
& x_1, x_2 \geq 0
\end{aligned}
$$

```haskell
-- 线性规划的Haskell实现
data LinearProgram = LinearProgram {
  objective :: Vector Double
  , constraints :: Matrix Double
  , bounds :: Vector Double
  , variableBounds :: [(Int, Double, Double)]  -- (index, lower, upper)
}

simplexMethod :: LinearProgram -> Maybe (Vector Double, Double)
simplexMethod lp =
  let standardForm = convertToStandardForm lp
      initialBasis = findInitialBasis standardForm
  in iterateSimplex standardForm initialBasis

-- 单纯形法迭代
iterateSimplex :: StandardForm -> Basis -> Maybe (Vector Double, Double)
iterateSimplex sf basis =
  case findEnteringVariable sf basis of
    Nothing -> Just (currentSolution sf basis, objectiveValue sf basis)
    Just entering ->
      case findLeavingVariable sf basis entering of
        Nothing -> Nothing  -- 无界解
        Just leaving -> iterateSimplex sf (updateBasis basis entering leaving)
```

## 非线性规划

### 无约束优化

**定义 2.1** (无约束优化)
无约束优化问题是寻找 $x \in \mathbb{R}^n$，使得：

$$\min_{x \in \mathbb{R}^n} f(x)$$

**定理 2.1** (一阶必要条件)
设 $f$ 在 $x^*$ 处可微，如果 $x^*$ 是局部最小值点，则：

$$\nabla f(x^*) = 0$$

**定理 2.2** (二阶充分条件)
设 $f$ 在 $x^*$ 处二阶可微，如果：

1. $\nabla f(x^*) = 0$
2. $\nabla^2 f(x^*)$ 正定

则 $x^*$ 是严格局部最小值点。

### 约束优化

**定义 2.2** (约束优化)
约束优化问题是寻找 $x \in \mathbb{R}^n$，使得：

$$
\begin{aligned}
\text{minimize} \quad & f(x) \\
\text{subject to} \quad & g_i(x) \leq 0, \quad i = 1, \ldots, m \\
& h_j(x) = 0, \quad j = 1, \ldots, p
\end{aligned}
$$

**定理 2.3** (KKT条件)
设 $x^*$ 为约束优化问题的局部最小值点，且约束满足正则性条件，则存在拉格朗日乘子 $\lambda_i \geq 0$ 和 $\mu_j$，使得：

$$\nabla f(x^*) + \sum_{i=1}^m \lambda_i \nabla g_i(x^*) + \sum_{j=1}^p \mu_j \nabla h_j(x^*) = 0$$

且 $\lambda_i g_i(x^*) = 0$ 对所有 $i$ 成立。

**示例 2.1** (二次规划)
二次规划问题：

$$
\begin{aligned}
\text{minimize} \quad & \frac{1}{2}x^T Q x + c^T x \\
\text{subject to} \quad & Ax \leq b
\end{aligned}
$$

其中 $Q$ 是正定矩阵。

```rust
// 非线性规划的Rust实现
# [derive(Debug, Clone)]
struct NonlinearProgram {
    objective: Box<dyn Fn(Vector) -> f64>,
    constraints: Vec<Box<dyn Fn(Vector) -> f64>>,
    equality_constraints: Vec<Box<dyn Fn(Vector) -> f64>>,
}

impl NonlinearProgram {
    fn solve(&self, initial_point: Vector) -> Option<(Vector, f64)> {
        // 使用内点法求解
        self.interior_point_method(initial_point)
    }

    fn interior_point_method(&self, x0: Vector) -> Option<(Vector, f64)> {
        let mut x = x0;
        let mut barrier_parameter = 1.0;

        for _ in 0..100 {
            // 求解障碍问题
            let barrier_objective = |x: Vector| {
                self.objective(x) + barrier_parameter * self.barrier_function(x)
            };

            // 使用牛顿法求解无约束问题
            x = self.newton_method(barrier_objective, x);
            barrier_parameter *= 0.1;
        }

        Some((x, self.objective(x)))
    }
}
```

## 动态规划

### 动态规划原理

**定义 3.1** (动态规划)
动态规划是解决多阶段决策问题的数学方法，基于贝尔曼最优性原理。

**定理 3.1** (贝尔曼方程)
设 $V_t(x_t)$ 为从状态 $x_t$ 开始的最优值函数，则：

$$V_t(x_t) = \min_{u_t} \{c_t(x_t, u_t) + V_{t+1}(f_t(x_t, u_t))\}$$

其中 $c_t$ 是阶段成本，$f_t$ 是状态转移函数。

**示例 3.1** (最短路径问题)
在图中寻找从起点到终点的最短路径。

```haskell
-- 动态规划的Haskell实现
data DynamicProgramming = DynamicProgramming {
  states :: [State]
  , actions :: State -> [Action]
  , transition :: State -> Action -> State
  , cost :: State -> Action -> Double
  , horizon :: Int
}

solveDynamicProgramming :: DynamicProgramming -> State -> [Action]
solveDynamicProgramming dp initial_state =
  let value_function = computeValueFunction dp
      optimal_policy = computeOptimalPolicy dp value_function
  in extractOptimalPath dp optimal_policy initial_state

-- 值函数计算
computeValueFunction :: DynamicProgramming -> Map State Double
computeValueFunction dp =
  let initial_values = Map.fromList [(s, 0.0) | s <- states dp]
  in foldl updateValueFunction initial_values [0..horizon dp - 1]

updateValueFunction :: Map State Double -> Int -> Map State Double
updateValueFunction values t =
  Map.fromList [(s, minimum [cost dp s a + values Map.! transition dp s a | a <- actions dp s]) | s <- states dp]
```

### 随机动态规划

**定义 3.2** (随机动态规划)
在随机环境中，状态转移具有不确定性，贝尔曼方程变为：

$$V_t(x_t) = \min_{u_t} \{c_t(x_t, u_t) + \mathbb{E}[V_{t+1}(f_t(x_t, u_t, \omega_t))]\}$$

其中 $\omega_t$ 是随机扰动。

## 排队论

### 排队系统

**定义 4.1** (排队系统)
排队系统由以下要素组成：

1. 到达过程
2. 服务过程
3. 服务规则
4. 系统容量

**定义 4.2** (Kendall记号)
排队系统用 $A/B/c/K/m/Z$ 表示，其中：

- $A$：到达间隔分布
- $B$：服务时间分布
- $c$：服务台数量
- $K$：系统容量
- $m$：顾客源数量
- $Z$：服务规则

### M/M/1队列

**定义 4.3** (M/M/1队列)
M/M/1队列是具有泊松到达、指数服务时间、单服务台的队列。

**定理 4.1** (M/M/1队列性能)
设 $\lambda$ 为到达率，$\mu$ 为服务率，$\rho = \lambda/\mu < 1$，则：

1. 平均队列长度：$L_q = \frac{\rho^2}{1-\rho}$
2. 平均等待时间：$W_q = \frac{\rho}{\mu(1-\rho)}$
3. 平均系统时间：$W = \frac{1}{\mu(1-\rho)}$

**示例 4.1** (银行排队)
银行有一个服务窗口，顾客按泊松过程到达，服务时间服从指数分布。

```rust
// 排队论的Rust实现
# [derive(Debug, Clone)]
struct QueueingSystem {
    arrival_rate: f64,
    service_rate: f64,
    servers: usize,
    capacity: Option<usize>,
}

impl QueueingSystem {
    fn mm1_performance(&self) -> QueuePerformance {
        let rho = self.arrival_rate / self.service_rate;

        QueuePerformance {
            average_queue_length: rho * rho / (1.0 - rho),
            average_waiting_time: rho / (self.service_rate * (1.0 - rho)),
            average_system_time: 1.0 / (self.service_rate * (1.0 - rho)),
            utilization: rho,
        }
    }

    fn simulate(&self, duration: f64) -> SimulationResult {
        let mut queue = Vec::new();
        let mut server_busy = false;
        let mut total_waiting_time = 0.0;
        let mut total_customers = 0;

        // 离散事件仿真
        // 简化实现
        SimulationResult {
            average_waiting_time: total_waiting_time / total_customers as f64,
            queue_length_distribution: vec![], // 实际实现中计算
        }
    }
}
```

## 网络优化

### 最小生成树

**定义 5.1** (最小生成树)
给定连通无向图 $G = (V, E)$ 和边权重 $w: E \to \mathbb{R}$，最小生成树是权重最小的生成树。

**算法 5.1** (Kruskal算法)

1. 将边按权重排序
2. 初始化空树
3. 依次选择最小权重边，如果不形成环则加入树中
4. 重复直到树包含 $|V|-1$ 条边

**示例 5.1** (通信网络)
设计通信网络，使所有节点连通且总成本最小。

```haskell
-- 网络优化的Haskell实现
data Graph = Graph {
  vertices :: [Vertex]
  , edges :: [Edge]
}

data Edge = Edge {
  from :: Vertex
  , to :: Vertex
  , weight :: Double
}

kruskalAlgorithm :: Graph -> [Edge]
kruskalAlgorithm graph =
  let sorted_edges = sortBy (comparing weight) (edges graph)
      initial_forest = map (\v -> [v]) (vertices graph)
  in foldl addEdge [] sorted_edges
  where
    addEdge tree_edges edge =
      if not (createsCycle tree_edges edge)
        then edge : tree_edges
        else tree_edges
```

### 最短路径

**定义 5.2** (最短路径)
在加权图中寻找从起点到终点的权重最小的路径。

**算法 5.2** (Dijkstra算法)

1. 初始化距离数组，起点距离为0，其他为无穷大
2. 选择未访问节点中距离最小的节点
3. 更新该节点的邻居距离
4. 标记该节点为已访问
5. 重复直到所有节点被访问

## 形式化实现

### Lean 4 实现

```lean
-- 线性规划
structure LinearProgram where
  objective : ℝ^n
  constraints : matrix ℝ m n
  bounds : ℝ^m
  variable_bounds : list (fin n × ℝ × ℝ)

-- 非线性规划
structure NonlinearProgram where
  objective : ℝ^n → ℝ
  constraints : list (ℝ^n → ℝ)
  equality_constraints : list (ℝ^n → ℝ)

-- 动态规划
structure DynamicProgramming where
  states : list State
  actions : State → list Action
  transition : State → Action → State
  cost : State → Action → ℝ
  horizon : ℕ
```

### Haskell 实现

```haskell
-- 线性规划
data LinearProgram = LinearProgram {
  objective :: Vector Double
  , constraints :: Matrix Double
  , bounds :: Vector Double
  , variableBounds :: [(Int, Double, Double)]
}

-- 非线性规划
data NonlinearProgram = NonlinearProgram {
  objective :: Vector Double -> Double
  , constraints :: [Vector Double -> Double]
  , equalityConstraints :: [Vector Double -> Double]
}

-- 动态规划
data DynamicProgramming s a = DynamicProgramming {
  states :: [s]
  , actions :: s -> [a]
  , transition :: s -> a -> s
  , cost :: s -> a -> Double
  , horizon :: Int
}
```

### Rust 实现

```rust
// 线性规划
# [derive(Debug, Clone)]
struct LinearProgram {
    objective: Vector<f64>,
    constraints: Matrix<f64>,
    bounds: Vector<f64>,
    variable_bounds: Vec<(usize, f64, f64)>,
}

// 非线性规划
# [derive(Debug, Clone)]
struct NonlinearProgram {
    objective: Box<dyn Fn(Vector<f64>) -> f64>,
    constraints: Vec<Box<dyn Fn(Vector<f64>) -> f64>>,
    equality_constraints: Vec<Box<dyn Fn(Vector<f64>) -> f64>>,
}

// 动态规划
# [derive(Debug, Clone)]
struct DynamicProgramming<S, A> {
    states: Vec<S>,
    actions: Box<dyn Fn(&S) -> Vec<A>>,
    transition: Box<dyn Fn(&S, &A) -> S>,
    cost: Box<dyn Fn(&S, &A) -> f64>,
    horizon: usize,
}
```

## 总结

本文档涵盖了运筹学理论的基础内容，包括：

1. **线性规划**：线性规划问题、单纯形法
2. **非线性规划**：无约束优化、约束优化、KKT条件
3. **动态规划**：贝尔曼方程、随机动态规划
4. **排队论**：排队系统、M/M/1队列性能分析
5. **网络优化**：最小生成树、最短路径算法

这些理论构成了运筹学的核心框架，为后续的高级研究奠定了坚实基础。

---

**文档信息**：

- **创建时间**：2025年8月2日
- **版本**：基础版
- **字数**：约7,000字
- **状态**：完成
