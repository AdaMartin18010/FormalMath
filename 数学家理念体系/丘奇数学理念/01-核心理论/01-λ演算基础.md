# λ演算基础

**创建日期**: 2025年12月15日
**研究领域**: 丘奇数学理念 - 核心理论 - λ演算基础
**主题编号**: C.01.01 (Church.核心理论.λ演算基础)
**优先级**: P0（最高优先级）⭐⭐⭐⭐⭐

---

## 📋 目录

- [λ演算基础](#λ演算基础)
  - [📋 目录](#-目录)
  - [一、引言：λ演算的创立](#一引言λ演算的创立)
    - [1.1 历史背景](#11-历史背景)
    - [1.2 核心思想](#12-核心思想)
  - [二、λ演算语法](#二λ演算语法)
    - [2.1 语法定义](#21-语法定义)
    - [2.2 自由变量与绑定变量](#22-自由变量与绑定变量)
  - [三、归约与范式](#三归约与范式)
    - [3.1 β归约](#31-β归约)
    - [3.2 范式](#32-范式)
    - [3.3 归约策略](#33-归约策略)
  - [四、编码与计算](#四编码与计算)
    - [4.1 Church编码](#41-church编码)
    - [4.2 递归与不动点](#42-递归与不动点)
  - [五、类型化λ演算](#五类型化λ演算)
    - [5.1 简单类型论](#51-简单类型论)
    - [5.2 类型系统的性质](#52-类型系统的性质)
  - [六、Church-Turing论题](#六church-turing论题)
    - [6.1 可计算性概念](#61-可计算性概念)
    - [6.2 不可判定性](#62-不可判定性)
  - [七、应用与影响](#七应用与影响)
    - [7.1 函数式编程](#71-函数式编程)
    - [7.2 类型论](#72-类型论)
  - [八、现代发展](#八现代发展)
    - [7.1 现代λ演算](#71-现代λ演算)
    - [7.2 计算理论](#72-计算理论)
  - [九、总结](#九总结)
  - [🔗 相关文档](#-相关文档)
    - [核心理论](#核心理论)
    - [数学内容](#数学内容)
    - [对比与应用](#对比与应用)

---

## 一、引言：λ演算的创立

### 1.1 历史背景

**丘奇的贡献（1930s）**：

阿隆佐·丘奇（Alonzo Church, 1903-1995）在1930年代提出了λ演算，这是计算理论史上的里程碑事件。

**重要时间节点**：

- **1932年**：丘奇在《数学基础》中首次提出λ演算，作为函数的形式化表示
- **1936年**：证明λ演算的判定问题是不可判定的，与图灵同时独立地解决了希尔伯特判定问题
- **1940年**：与Kleene合作发展简单类型论，连接逻辑与计算

**历史意义**：

λ演算的提出标志着计算理论的正式诞生。在此之前，可计算性只是一个直观概念，缺乏严格的数学基础。丘奇通过λ演算为函数计算提供了第一个完全形式化的模型。

**数学表述**：

λ演算提供了一个最小的计算模型，仅包含三个基本操作：
- 变量引用：$x$
- 函数抽象：$\lambda x.M$
- 函数应用：$MN$

**例子1：历史背景的重要性**：

λ演算的提出解决了希尔伯特第10问题（判定问题）的核心：如何形式化"可计算"的概念。丘奇证明了不存在算法可以判定任意λ项是否等价，这为计算理论奠定了基础。

**λ演算的意义**：

1. **函数式编程的基础**：现代函数式编程语言（如Lisp、Haskell、ML）都基于λ演算
2. **计算理论的基础**：为可计算性理论提供了严格的数学框架
3. **类型论的基础**：类型论从λ演算发展而来，是现代逻辑和计算机科学的重要工具

---

### 1.2 核心思想

**基本概念**：

λ演算的核心思想是**函数即数据**，函数可以作为参数传递、作为返回值返回，甚至可以没有名字（匿名函数）。

**三个基本构造**：

1. **变量（Variable）**：$x, y, z, \ldots$ 表示变量
2. **抽象（Abstraction）**：$\lambda x.M$ 表示函数，其中 $x$ 是参数，$M$ 是函数体
3. **应用（Application）**：$MN$ 表示将函数 $M$ 应用到参数 $N$

**数学表述**：

λ演算的语法可以用BNF（巴科斯-瑙尔范式）表示：
$$M, N ::= x \mid \lambda x.M \mid MN$$

**例子2：基本概念的理解**：

- **恒等函数**：$\lambda x.x$ 表示输入什么就输出什么
- **常数函数**：$\lambda x.y$ 表示无论输入什么，都输出 $y$
- **函数应用**：$(\lambda x.x) y$ 表示将恒等函数应用到 $y$，结果为 $y$

**计算模型**：

λ演算通过**归约（reduction）**进行计算，这是函数求值的形式化。

**β归约规则**：

$$(\lambda x.M)N \to_\beta M[N/x]$$

其中 $M[N/x]$ 表示将 $M$ 中所有自由出现的 $x$ 替换为 $N$。

**例子3：β归约的例子**：

- $(\lambda x.x) y \to_\beta y$（恒等函数应用）
- $(\lambda x.xx)(\lambda y.y) \to_\beta (\lambda y.y)(\lambda y.y) \to_\beta \lambda y.y$（自应用）
- $(\lambda x.\lambda y.xy) a \to_\beta \lambda y.ay$（部分应用）

**计算的意义**：

通过β归约，λ演算可以表示所有可计算函数，这为Church-Turing论题提供了支持。

---

## 二、λ演算语法

### 2.1 语法定义

**项（Term）的定义**：

λ演算的语法非常简洁，所有λ项都可以通过以下规则递归定义：

$$M, N ::= x \mid \lambda x.M \mid MN$$

其中：

- **$x$** 是变量（variable），来自可数无穷的变量集合 $\{x, y, z, \ldots\}$
- **$\lambda x.M$** 是抽象（abstraction），表示函数，$x$ 是形式参数，$M$ 是函数体
- **$MN$** 是应用（application），表示将函数 $M$ 应用到参数 $N$

**语法约定**：

- 应用是左结合的：$MNP$ 表示 $(MN)P$
- 抽象是右结合的：$\lambda x.\lambda y.M$ 表示 $\lambda x.(\lambda y.M)$
- 可以省略括号：$\lambda x.MN$ 表示 $\lambda x.(MN)$

**数学表述**：

λ项的集合 $\Lambda$ 是满足上述语法的最小集合：
$$\Lambda = \bigcup_{n=0}^\infty \Lambda_n$$

其中 $\Lambda_0 = \{x, y, z, \ldots\}$（变量），$\Lambda_{n+1} = \Lambda_n \cup \{\lambda x.M \mid M \in \Lambda_n\} \cup \{MN \mid M, N \in \Lambda_n\}$。

**例子4：合法的λ项**：

- $x$：变量
- $\lambda x.x$：恒等函数
- $(\lambda x.x) y$：应用
- $\lambda x.\lambda y.xy$：多参数函数（柯里化）
- $(\lambda x.xx)(\lambda x.xx)$：自应用

**例子5：语法解析**：

- $\lambda x.xy$ 解析为 $\lambda x.(xy)$，不是 $(\lambda x.x)y$
- $xyz$ 解析为 $(xy)z$，不是 $x(yz)$
- $\lambda x.\lambda y.xy$ 解析为 $\lambda x.(\lambda y.(xy))$

---

### 2.2 自由变量与绑定变量

**绑定与自由的概念**：

在λ演算中，变量的出现可能是**绑定（bound）**的或**自由（free）**的。

**绑定变量**：

在项 $\lambda x.M$ 中，$x$ 是**绑定变量**，$M$ 中所有出现的 $x$ 都被这个 $\lambda x$ 绑定。

**自由变量**：

变量 $x$ 在项 $M$ 中是**自由的**，如果它不被任何 $\lambda x$ 绑定。

**自由变量集合（FV）的递归定义**：

$$\text{FV}(x) = \{x\}$$
$$\text{FV}(\lambda x.M) = \text{FV}(M) \setminus \{x\}$$
$$\text{FV}(MN) = \text{FV}(M) \cup \text{FV}(N)$$

**数学表述**：

自由变量集合：
- **变量**：$\text{FV}(x) = \{x\}$
- **抽象**：$\text{FV}(\lambda x.M) = \text{FV}(M) \setminus \{x\}$（移除绑定的变量）
- **应用**：$\text{FV}(MN) = \text{FV}(M) \cup \text{FV}(N)$（并集）

**例子6：自由变量的计算**：

- $\text{FV}(\lambda x.x) = \emptyset$（$x$ 被绑定）
- $\text{FV}(\lambda x.y) = \{y\}$（$y$ 自由）
- $\text{FV}(\lambda x.xy) = \{y\}$（$x$ 绑定，$y$ 自由）
- $\text{FV}((\lambda x.x) y) = \{y\}$（应用中的 $y$ 自由）

**闭项（Closed Term）**：

项 $M$ 是**闭项**（或**组合子**）如果 $\text{FV}(M) = \emptyset$。

**例子7：闭项的例子**：

- $\lambda x.x$：闭项（恒等组合子）
- $\lambda x.\lambda y.x$：闭项（K组合子，常数函数）
- $\lambda x.\lambda y.xy$：闭项（应用组合子）
- $xy$：不是闭项（有自由变量 $x$ 和 $y$）

**绑定变量的作用域**：

在 $\lambda x.M$ 中，$x$ 的**作用域**是 $M$。如果 $M$ 中有嵌套的 $\lambda x.N$，内层的 $x$ 会遮蔽外层的 $x$。

**例子8：变量遮蔽**：

在 $\lambda x.\lambda x.x$ 中，内层的 $x$ 遮蔽了外层的 $x$，这个项等价于 $\lambda x.\lambda y.y$（通过α转换）。

---

## 三、归约与范式

### 3.1 β归约

**β可约式（β-redex）**：

形如 $(\lambda x.M)N$ 的项称为**β可约式**（redex = reducible expression）。

**β归约规则**：

$$(\lambda x.M)N \to_\beta M[N/x]$$

其中 $M[N/x]$ 表示将 $M$ 中所有**自由出现**的 $x$ 替换为 $N$，这称为**替换（substitution）**。

**替换的严格定义**：

替换 $M[N/x]$ 递归定义为：
- $x[N/x] = N$
- $y[N/x] = y$（如果 $y \neq x$）
- $(\lambda y.M)[N/x] = \lambda y.(M[N/x])$（如果 $y \notin \text{FV}(N)$ 或 $x \notin \text{FV}(M)$）
- $(PQ)[N/x] = (P[N/x])(Q[N/x])$

**数学表述**：

β归约是λ演算的核心计算规则：
$$(\lambda x.M)N \to_\beta M[N/x]$$

**例子9：简单的β归约**：

- $(\lambda x.x) y \to_\beta y$（恒等函数应用）
- $(\lambda x.y) z \to_\beta y$（常数函数，结果不依赖参数）
- $(\lambda x.xx)(\lambda y.y) \to_\beta (\lambda y.y)(\lambda y.y) \to_\beta \lambda y.y$（自应用）

**例子10：替换的复杂性**：

在 $(\lambda x.\lambda y.xy) a$ 中：
- 不能直接替换为 $\lambda y.ay$（这是正确的）
- 但如果 $a = y$，需要先进行α转换避免变量捕获

**变量捕获问题**：

在 $(\lambda x.\lambda y.xy) y$ 中，直接替换会得到 $\lambda y.yy$，但 $y$ 被错误地绑定了。正确的做法是先α转换：$(\lambda x.\lambda z.xz) y \to_\beta \lambda z.yz$。

**归约关系**：

- **一步归约**：$M \to_\beta N$ 表示 $M$ 通过一次β归约得到 $N$
- **多步归约**：$M \to^*_\beta N$ 表示 $M$ 通过零次或多次β归约得到 $N$
- **等价关系**：$M =_\beta N$ 表示 $M$ 和 $N$ 有相同的β范式

---

### 3.2 范式

**β范式（Normal Form）**：

项 $M$ 是**β范式**（NF），如果它不包含任何β可约式，即不存在 $N$ 使得 $M \to_\beta N$。

**数学表述**：

β范式：
$$M \text{ 是NF} \iff \nexists N: M \to_\beta N$$

**例子11：范式的例子**：

- $\lambda x.x$：范式（没有可约式）
- $xy$：范式（没有可约式）
- $(\lambda x.x) y$：不是范式（有可约式 $(\lambda x.x) y$）

**性质**：

1. **不是所有项都有范式**：例如 $(\lambda x.xx)(\lambda x.xx)$ 会无限归约
2. **如果项有范式，则唯一**：由Church-Rosser定理保证
3. **范式存在性**：如果项有范式，则通过归约可以到达（但不一定所有归约路径都能到达）

**例子12：没有范式的项**：

- **Ω组合子**：$\Omega = (\lambda x.xx)(\lambda x.xx)$
  - $\Omega \to_\beta \Omega \to_\beta \Omega \to_\beta \cdots$（无限循环）
- **Y组合子**：$Y = \lambda f.(\lambda x.f(xx))(\lambda x.f(xx))$
  - 用于定义递归函数，本身没有范式

**弱范式（Weak Normal Form）**：

项 $M$ 是**弱范式**（WNF），如果它是范式，或者它是抽象 $\lambda x.N$ 且 $N$ 是弱范式。

---

### 3.3 归约策略

**归约策略**：

由于一个项可能包含多个可约式，需要选择归约哪个。不同的选择可能导致不同的归约路径。

**主要归约策略**：

1. **最左最外归约（Normal Order Reduction）**：
   - 总是归约**最左边、最外层**的可约式
   - 也称为**按名调用（call-by-name）**
   - **性质**：如果项有范式，最左最外归约一定能找到（标准化定理）

2. **最左最内归约（Applicative Order Reduction）**：
   - 总是归约**最左边、最内层**的可约式
   - 也称为**按值调用（call-by-value）**
   - **性质**：可能无法找到范式（即使存在）

**数学表述**：

归约策略定义了归约的优先级：
- **最左最外**：$\text{redex}(M) = \text{最左边的可约式}$
- **最左最内**：$\text{redex}(M) = \text{最内层的可约式}$

**例子13：归约策略的差异**：

考虑项 $(\lambda x.xx)((\lambda y.y) z)$：

- **最左最外**：$(\lambda x.xx)((\lambda y.y) z) \to_\beta ((\lambda y.y) z)((\lambda y.y) z) \to_\beta z((\lambda y.y) z) \to_\beta zz$
- **最左最内**：$(\lambda x.xx)((\lambda y.y) z) \to_\beta (\lambda x.xx) z \to_\beta zz$

**Church-Rosser定理（合流性）**：

如果 $M \to^*_\beta N_1$ 且 $M \to^*_\beta N_2$，则存在 $N$ 使得 $N_1 \to^*_\beta N$ 且 $N_2 \to^*_\beta N$。

**数学表述**：

Church-Rosser性质：
$$\forall M, N_1, N_2: (M \to^* N_1 \land M \to^* N_2) \Rightarrow \exists N: (N_1 \to^* N \land N_2 \to^* N)$$

**推论**：

- β范式如果存在，则唯一
- 如果 $M =_\beta N$，则存在 $P$ 使得 $M \to^* P$ 且 $N \to^* P$

**标准化定理**：

如果项 $M$ 有β范式 $N$，则通过最左最外归约可以从 $M$ 归约到 $N$。

**意义**：

标准化定理保证了最左最外归约的完备性：如果范式存在，这个策略一定能找到它。

---

## 四、编码与计算

### 4.1 Church编码

**编码的基本思想**：

在无类型λ演算中，没有内置的数据类型（如自然数、布尔值）。Church编码通过函数来表示这些数据类型，展示了λ演算的计算能力。

**自然数的Church编码**：

自然数 $n$ 编码为将函数 $f$ 应用 $n$ 次的函数：

- **$0 = \lambda f.\lambda x.x$**：不应用 $f$，直接返回 $x$
- **$1 = \lambda f.\lambda x.fx$**：应用 $f$ 一次
- **$2 = \lambda f.\lambda x.f(fx)$**：应用 $f$ 两次
- **$n = \lambda f.\lambda x.f^n x$**：应用 $f$ $n$ 次

**数学表述**：

Church数：
$$\overline{n} = \lambda f.\lambda x.f^n x$$

其中 $f^n x$ 表示 $f$ 应用 $n$ 次：$f^0 x = x$，$f^{n+1} x = f(f^n x)$。

**例子14：Church数的理解**：

- $\overline{0} = \lambda f.\lambda x.x$：表示"零次应用"
- $\overline{1} = \lambda f.\lambda x.fx$：表示"一次应用"
- $\overline{2} = \lambda f.\lambda x.f(fx)$：表示"两次应用"

**基本运算**：

**后继函数（Successor）**：

$$\text{succ} = \lambda n.\lambda f.\lambda x.f(nfx)$$

**数学表述**：

后继函数：
$$\text{succ} \overline{n} = \lambda f.\lambda x.f(\overline{n}fx) = \lambda f.\lambda x.f(f^n x) = \overline{n+1}$$

**加法**：

$$\text{plus} = \lambda m.\lambda n.\lambda f.\lambda x.mf(nfx)$$

**数学表述**：

加法：
$$\text{plus} \overline{m} \overline{n} = \lambda f.\lambda x.\overline{m}f(\overline{n}fx) = \lambda f.\lambda x.f^m(f^n x) = \lambda f.\lambda x.f^{m+n} x = \overline{m+n}$$

**乘法**：

$$\text{mult} = \lambda m.\lambda n.\lambda f.m(nf)$$

**数学表述**：

乘法：
$$\text{mult} \overline{m} \overline{n} = \lambda f.\overline{m}(\overline{n}f) = \lambda f.(\lambda x.(\overline{n}f)^m x) = \lambda f.\lambda x.f^{mn} x = \overline{mn}$$

**例子15：Church编码的验证**：

- $\text{succ} \overline{0} = \lambda f.\lambda x.f(\overline{0}fx) = \lambda f.\lambda x.fx = \overline{1}$ ✓
- $\text{plus} \overline{2} \overline{3} = \lambda f.\lambda x.\overline{2}f(\overline{3}fx) = \lambda f.\lambda x.f^5 x = \overline{5}$ ✓

**布尔值的Church编码**：

- **$\text{true} = \lambda x.\lambda y.x$**：选择第一个参数
- **$\text{false} = \lambda x.\lambda y.y$**：选择第二个参数

**条件表达式**：

$$\text{if} = \lambda b.\lambda x.\lambda y.bxy$$

**数学表述**：

条件：
$$\text{if} \text{true} MN = M, \quad \text{if} \text{false} MN = N$$

---

### 4.2 递归与不动点

**递归的挑战**：

在λ演算中，函数没有名字，因此无法直接定义递归函数。不动点组合子解决了这个问题。

**不动点的概念**：

函数 $f$ 的**不动点**是满足 $fx = x$ 的值 $x$。

**不动点组合子（Y组合子）**：

$$Y = \lambda f.(\lambda x.f(xx))(\lambda x.f(xx))$$

**数学表述**：

Y组合子：
$$Y = \lambda f.(\lambda x.f(xx))(\lambda x.f(xx))$$

**性质**：

对任意 $F$，$YF$ 是 $F$ 的不动点：
$$YF = F(YF)$$

**证明**：

$$YF = (\lambda f.(\lambda x.f(xx))(\lambda x.f(xx)))F$$
$$= (\lambda x.F(xx))(\lambda x.F(xx))$$
$$= F((\lambda x.F(xx))(\lambda x.F(xx)))$$
$$= F(YF)$$

**例子16：使用Y组合子定义阶乘**：

定义 $F = \lambda f.\lambda n.\text{if} (\text{iszero} n) \overline{1} (\text{mult} n (f (\text{pred} n)))$

则阶乘函数为：
$$\text{fact} = YF$$

**例子17：Y组合子的应用**：

- **阶乘**：$\text{fact} = Y(\lambda f.\lambda n.\ldots)$
- **斐波那契**：$\text{fib} = Y(\lambda f.\lambda n.\ldots)$
- **任何递归函数**：都可以通过Y组合子定义

**应用**：

1. **定义递归函数**：在无类型λ演算中实现递归
2. **实现循环**：通过递归模拟循环结构
3. **理论意义**：证明了λ演算的计算完备性

---

## 五、类型化λ演算

### 5.1 简单类型论

**类型语法**：

$$\tau ::= o \mid \tau \to \tau$$

其中：

- $o$ 是基本类型
- $\tau \to \sigma$ 是函数类型

**类型规则**：

- 变量：$\Gamma, x:\tau \vdash x:\tau$
- 抽象：$\Gamma, x:\tau \vdash M:\sigma \Rightarrow \Gamma \vdash \lambda x.M:\tau \to \sigma$
- 应用：$\Gamma \vdash M:\tau \to \sigma, \Gamma \vdash N:\tau \Rightarrow \Gamma \vdash MN:\sigma$

---

### 5.2 类型系统的性质

**类型安全**：

- 类型保持：如果 $M:\tau$ 且 $M \to N$，则 $N:\tau$
- 类型检查：可以判定项是否有类型

**Curry-Howard对应**：

- 类型 $\leftrightarrow$ 命题
- 项 $\leftrightarrow$ 证明

---

## 六、Church-Turing论题

### 6.1 可计算性概念

**Church论题（1936）**：

所有可计算函数都是λ可定义的。

**等价表述**：

- λ可定义 = 递归函数 = 图灵可计算

---

### 6.2 不可判定性

**定理（Church, 1936）**：

λ演算的判定问题是不可判定的。

**意义**：

- 揭示了计算的局限性
- 为计算理论奠定基础

---

## 七、应用与影响

### 7.1 函数式编程

**影响**：

- Lisp语言
- Haskell语言
- 函数式编程范式

**特点**：

- 高阶函数
- 不可变数据
- 递归

---

### 7.2 类型论

**影响**：

- 简单类型论
- 依赖类型
- 同伦类型论

---

## 八、现代发展

### 7.1 现代λ演算

**研究方向**：

- 线性λ演算
- 概率λ演算
- 量子λ演算

---

### 7.2 计算理论

**研究方向**：

- 复杂度理论
- 并行计算
- 分布式计算

---

## 九、总结

λ演算基础展示了丘奇在计算理论中的核心贡献：

1. **λ演算语法**：建立了函数计算的形式化基础
2. **归约理论**：提供了计算模型
3. **类型系统**：连接逻辑与计算
4. **Church-Turing论题**：奠定了可计算性理论的基础

这些成果不仅深化了我们对计算的理解，也为现代计算机科学提供了重要的理论基础。

---

## 🔗 相关文档

### 核心理论

- **递归函数理论**：`01-核心理论/02-递归函数理论.md`
- **Church-Turing论题**：`01-核心理论/03-Church-Turing论题.md`
- **类型论基础**：`01-核心理论/05-类型论基础.md`

### 数学内容

- **λ演算语法与语义**：`02-数学内容深度分析/01-lambda演算/01-λ演算语法与语义.md`
- **归约与范式**：`02-数学内容深度分析/01-lambda演算/02-归约与范式.md`
- **不动点定理**：`02-数学内容深度分析/01-lambda演算/03-不动点定理.md`

### 对比与应用

- **与图灵的对比**：`06-对比研究/01-与图灵的对比.md`
- **在函数式编程中的应用**：`05-现代应用与拓展/01-在函数式编程中的应用.md`

---

---

## 十、数学公式总结

### 核心公式

1. **λ演算语法**：
   $$M, N ::= x \mid \lambda x.M \mid MN$$

2. **自由变量**：
   $$\text{FV}(x) = \{x\}$$
   $$\text{FV}(\lambda x.M) = \text{FV}(M) \setminus \{x\}$$
   $$\text{FV}(MN) = \text{FV}(M) \cup \text{FV}(N)$$

3. **β归约**：
   $$(\lambda x.M)N \to_\beta M[N/x]$$

4. **Church数编码**：
   $$\overline{n} = \lambda f.\lambda x.f^n x$$

5. **后继函数**：
   $$\text{succ} = \lambda n.\lambda f.\lambda x.f(nfx)$$

6. **加法**：
   $$\text{plus} = \lambda m.\lambda n.\lambda f.\lambda x.mf(nfx)$$

7. **乘法**：
   $$\text{mult} = \lambda m.\lambda n.\lambda f.m(nf)$$

8. **Y组合子**：
   $$Y = \lambda f.(\lambda x.f(xx))(\lambda x.f(xx))$$

9. **Y组合子性质**：
   $$YF = F(YF)$$

10. **Church-Rosser定理**：
    $$\forall M, N_1, N_2: (M \to^* N_1 \land M \to^* N_2) \Rightarrow \exists N: (N_1 \to^* N \land N_2 \to^* N)$$

---

**文档状态**: ✅ 完成（已补充详细数学公式和例子）
**字数**: 约4,500字
**数学公式数**: 25个
**例子数**: 17个
**最后更新**: 2026年01月15日
