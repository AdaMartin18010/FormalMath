# 递归函数定义

**创建日期**: 2025年12月15日
**研究领域**: 丘奇数学理念 - 数学内容深度分析 - 递归函数定义
**主题编号**: C.02.02.01 (Church.数学内容深度分析.递归论.递归函数定义)
**优先级**: P0（最高优先级）⭐⭐⭐⭐⭐

---

## 📋 目录

- [递归函数定义](#递归函数定义)
  - [📋 目录](#-目录)
  - [一、引言：递归函数的概念](#一引言递归函数的概念)
    - [1.1 历史背景](#11-历史背景)
    - [1.2 递归函数的等价性](#12-递归函数的等价性)
  - [二、初始函数](#二初始函数)
    - [2.1 基本函数](#21-基本函数)
    - [2.2 初始函数的性质](#22-初始函数的性质)
  - [三、复合](#三复合)
    - [3.1 复合的定义](#31-复合的定义)
    - [3.2 复合的性质](#32-复合的性质)
  - [四、原始递归](#四原始递归)
    - [4.1 原始递归模式](#41-原始递归模式)
    - [4.2 原始递归函数的性质](#42-原始递归函数的性质)
  - [五、μ递归](#五μ递归)
    - [5.1 μ算子](#51-μ算子)
    - [5.2 一般递归函数](#52-一般递归函数)
  - [六、递归函数的例子](#六递归函数的例子)
    - [6.1 基本函数](#61-基本函数)
    - [6.2 复杂函数](#62-复杂函数)
  - [七、应用与影响](#七应用与影响)
    - [7.1 计算理论](#71-计算理论)
    - [7.2 逻辑学](#72-逻辑学)
  - [八、现代发展](#八现代发展)
    - [8.1 计算复杂度](#81-计算复杂度)
    - [8.2 可计算分析](#82-可计算分析)
  - [九、总结](#九总结)
  - [🔗 递归函数定义相关文档](#-递归函数定义相关文档)
    - [核心理论](#核心理论)
    - [数学内容](#数学内容)
    - [对比与应用](#对比与应用)

---

## 一、引言：递归函数的概念

### 1.1 历史背景

**可计算性问题的提出**：

- 什么是可计算函数？
- 如何形式化可计算性？

**主要贡献者**：

- **Gödel（1931）**：原始递归函数
- **Church（1936）**：λ可定义函数
- **Turing（1936）**：图灵可计算函数
- **Kleene（1936）**：一般递归函数

---

### 1.2 递归函数的等价性

**Church-Turing论题**：

以下概念等价：

- λ可定义函数
- 一般递归函数
- 图灵可计算函数
- 可计算函数（直观概念）

---

## 二、初始函数

### 2.1 基本函数

**初始函数（Initial Functions）**：

递归函数理论从三个**初始函数**开始，所有递归函数都可以通过这些初始函数和构造规则得到。

**三个初始函数**：

1. **零函数（Zero Function）**：
   $$Z: \mathbb{N} \to \mathbb{N}, \quad Z(n) = 0$$
   对所有输入返回0

2. **后继函数（Successor Function）**：
   $$S: \mathbb{N} \to \mathbb{N}, \quad S(n) = n+1$$
   返回输入的后继数

3. **投影函数（Projection Function）**：
   $$P_i^k: \mathbb{N}^k \to \mathbb{N}, \quad P_i^k(x_1, \ldots, x_k) = x_i$$
   返回第 $i$ 个参数（$1 \leq i \leq k$）

**数学表述**：

初始函数集合：
$$\mathcal{I} = \{Z, S, \{P_i^k\}_{i,k}\}$$

**例子1：初始函数的应用**：

- $Z(5) = 0$（零函数）
- $S(3) = 4$（后继函数）
- $P_2^3(7, 2, 9) = 2$（投影函数，返回第2个参数）

**为什么选择这些函数？**：

这些函数是最基本的算术操作：
- **零函数**：表示常数0
- **后继函数**：表示递增操作，是自然数的基础
- **投影函数**：表示选择和重排参数

---

### 2.2 初始函数的性质

**基本性质**：

初始函数具有以下重要性质：

1. **可计算性**：所有初始函数都是直观可计算的
2. **简单性**：每个函数都有明确的、简单的定义
3. **完备性**：所有递归函数都可以从初始函数构造

**数学表述**：

初始函数的性质：
- **可计算性**：$\forall f \in \mathcal{I}: f \text{ 是图灵可计算的}$
- **简单性**：每个初始函数都有 $O(1)$ 时间复杂度
- **完备性**：$\text{递归函数} = \text{从 } \mathcal{I} \text{ 通过构造规则得到的函数}$

**例子2：初始函数的可计算性**：

- 零函数：图灵机只需输出0
- 后继函数：图灵机只需在输入上加1
- 投影函数：图灵机只需复制第 $i$ 个输入

**初始函数的作用**：

初始函数提供了递归函数理论的"原子"，所有复杂的函数都通过组合这些原子得到。

---

## 三、复合

### 3.1 复合的定义

**复合（Composition）**：

复合是最基本的函数构造方法，通过将函数的输出作为另一个函数的输入来构造新函数。

**定义**：

给定函数 $g_1, \ldots, g_m: \mathbb{N}^n \to \mathbb{N}$ 和 $h: \mathbb{N}^m \to \mathbb{N}$，定义函数 $f: \mathbb{N}^n \to \mathbb{N}$：
$$f(x_1, \ldots, x_n) = h(g_1(x_1, \ldots, x_n), \ldots, g_m(x_1, \ldots, x_n))$$

**数学表述**：

复合操作：
$$f = h \circ (g_1, \ldots, g_m)$$

其中 $\circ$ 表示复合。

**例子3：简单的复合**：

- **常数函数**：$C_k(x) = k$ 可以通过复合零函数和后继函数得到
- **恒等函数**：$I(x) = P_1^1(x) = x$

**例子4：加法的定义**：

加法可以通过复合定义：
$$+(x, y) = S(P_2^2(x, y)) = S(y) = y+1$$

但这只定义了 $+(0, y)$。完整的加法需要原始递归（见下一节）。

**复合的图示**：

```
输入 (x1, ..., xn)
    |
    v
[g1, ..., gm] 并行计算
    |
    v
(g1(x), ..., gm(x))
    |
    v
    h
    |
    v
输出 f(x)
```

---

### 3.2 复合的性质

**封闭性**：

递归函数类在复合下封闭：如果 $g_1, \ldots, g_m$ 和 $h$ 都是递归函数，则 $f = h \circ (g_1, \ldots, g_m)$ 也是递归函数。

**数学表述**：

复合的封闭性：
$$\text{如果 } g_1, \ldots, g_m, h \in \text{Rec}, \text{ 则 } h \circ (g_1, \ldots, g_m) \in \text{Rec}$$

**可计算性保持**：

复合保持可计算性：如果所有 $g_i$ 和 $h$ 都是图灵可计算的，则 $f$ 也是图灵可计算的。

**数学表述**：

可计算性保持：
$$\text{如果 } g_1, \ldots, g_m, h \text{ 是图灵可计算的，则 } f \text{ 也是图灵可计算的}$$

**例子5：复合的可计算性**：

要计算 $f(x)$，图灵机可以：
1. 并行计算 $g_1(x), \ldots, g_m(x)$
2. 然后计算 $h(g_1(x), \ldots, g_m(x))$

由于每个步骤都是可计算的，整个过程也是可计算的。

---

## 四、原始递归

### 4.1 原始递归模式

**原始递归（Primitive Recursion）**：

原始递归是定义递归函数的基本模式，由Gödel在1931年引入。

**原始递归模式**：

给定函数 $g: \mathbb{N}^n \to \mathbb{N}$ 和 $h: \mathbb{N}^{n+2} \to \mathbb{N}$，定义函数 $f: \mathbb{N}^{n+1} \to \mathbb{N}$：

- **基础情况**：$f(0, x_1, \ldots, x_n) = g(x_1, \ldots, x_n)$
- **递归情况**：$f(n+1, x_1, \ldots, x_n) = h(n, f(n, x_1, \ldots, x_n), x_1, \ldots, x_n)$

**数学表述**：

原始递归定义：
$$f(0, \bar{x}) = g(\bar{x})$$
$$f(n+1, \bar{x}) = h(n, f(n, \bar{x}), \bar{x})$$

其中 $\bar{x} = (x_1, \ldots, x_n)$。

**例子6：加法的原始递归定义**：

定义加法 $+$：
- $+(0, y) = P_1^1(y) = y$（使用投影函数）
- $+(n+1, y) = S(+(n, y))$（使用后继函数）

**验证**：
- $+(0, 3) = 3$ ✓
- $+(1, 3) = S(+(0, 3)) = S(3) = 4$ ✓
- $+(2, 3) = S(+(1, 3)) = S(4) = 5$ ✓

**例子7：乘法的原始递归定义**：

定义乘法 $\times$：
- $\times(0, y) = Z(y) = 0$（零函数）
- $\times(n+1, y) = +(\times(n, y), y)$（使用加法）

**验证**：
- $\times(0, 5) = 0$ ✓
- $\times(1, 5) = +(\times(0, 5), 5) = +(0, 5) = 5$ ✓
- $\times(2, 5) = +(\times(1, 5), 5) = +(5, 5) = 10$ ✓

**例子8：指数函数的定义**：

定义指数 $exp$：
- $exp(0, y) = S(0) = 1$（后继函数）
- $exp(n+1, y) = \times(exp(n, y), y)$（使用乘法）

---

### 4.2 原始递归函数的性质

**重要性质**：

1. **全函数性**：所有原始递归函数都是**全函数**（total），即对所有输入都有定义
2. **封闭性**：原始递归函数类在复合和原始递归下封闭
3. **可计算性**：所有原始递归函数都是图灵可计算的

**数学表述**：

原始递归函数的性质：
- **全函数性**：$\forall f \in \text{PR}: \text{dom}(f) = \mathbb{N}^n$（对所有输入有定义）
- **封闭性**：$\text{PR} \text{ 在复合和原始递归下封闭}$
- **可计算性**：$\forall f \in \text{PR}: f \text{ 是图灵可计算的}$

**局限性**：

尽管原始递归函数类很大，但它**不包含所有可计算函数**。

**Ackermann函数**：

Ackermann函数 $A: \mathbb{N}^2 \to \mathbb{N}$ 定义为：
- $A(0, n) = n+1$
- $A(m+1, 0) = A(m, 1)$
- $A(m+1, n+1) = A(m, A(m+1, n))$

**定理**：Ackermann函数是递归的，但**不是原始递归的**。

**证明思路**：

Ackermann函数增长太快，超过了任何原始递归函数的增长速度。这证明了原始递归的局限性。

---

## 五、μ递归

### 5.1 μ算子

**μ算子（最小化算子）**：

给定函数 $g$，定义函数 $f$：
$$f(\bar{x}) = \mu y[g(\bar{x}, y) = 0]$$

表示最小的 $y$ 使得 $g(\bar{x}, y) = 0$，如果不存在则未定义。

---

### 5.2 一般递归函数

**定义**：

一般递归函数（或μ递归函数）是：

1. 初始函数
2. 通过复合、原始递归和μ算子得到的函数

**性质**：

- 包含部分函数（可能未定义）
- 等价于图灵可计算函数

---

## 六、递归函数的例子

### 6.1 基本函数

**例子**：

- 加法、乘法、指数
- 前驱函数
- 减法（截断减法）

---

### 6.2 复杂函数

**例子**：

- Ackermann函数
- 原始递归但增长极快
- 不是原始递归的函数

---

## 七、应用与影响

### 7.1 计算理论

**影响**：

- 可计算性理论
- 复杂度理论
- 算法理论

---

### 7.2 逻辑学

**影响**：

- 可判定性理论
- 证明论
- 模型论

---

## 八、现代发展

### 8.1 计算复杂度

**研究方向**：

- 递归函数的复杂度
- 原始递归复杂度
- 复杂度层次

---

### 8.2 可计算分析

**研究方向**：

- 实数的可计算性
- 连续函数的可计算性
- 可计算度量空间

---

## 九、总结

递归函数定义展示了丘奇在计算理论中的核心贡献：

1. **递归函数定义**：形式化了可计算性概念
2. **初始函数**：提供了基础
3. **构造方法**：复合、原始递归、μ算子
4. **现代影响**：为计算理论和逻辑学提供基础

这些成果不仅深化了我们对计算的理解，也为现代计算机科学和逻辑学提供了重要的理论基础。

---

## 🔗 递归函数定义相关文档

### 核心理论

- **递归函数理论**：`01-核心理论/02-递归函数理论.md`

### 数学内容

- **原始递归函数**：`02-数学内容深度分析/02-递归论/02-原始递归函数.md`
- **μ递归函数**：`02-数学内容深度分析/02-递归论/03-μ递归函数.md`

### 对比与应用

- **对计算理论的影响**：`03-教育与影响/01-对计算理论的影响.md`

---

---

## 十、数学公式总结

### 核心公式

1. **零函数**：
   $$Z(n) = 0$$

2. **后继函数**：
   $$S(n) = n+1$$

3. **投影函数**：
   $$P_i^k(x_1, \ldots, x_k) = x_i$$

4. **复合**：
   $$f(x_1, \ldots, x_n) = h(g_1(x_1, \ldots, x_n), \ldots, g_m(x_1, \ldots, x_n))$$

5. **原始递归基础情况**：
   $$f(0, x_1, \ldots, x_n) = g(x_1, \ldots, x_n)$$

6. **原始递归递归情况**：
   $$f(n+1, x_1, \ldots, x_n) = h(n, f(n, x_1, \ldots, x_n), x_1, \ldots, x_n)$$

7. **加法的定义**：
   $$+(0, y) = y, \quad +(n+1, y) = S(+(n, y))$$

8. **乘法的定义**：
   $$\times(0, y) = 0, \quad \times(n+1, y) = +(\times(n, y), y)$$

9. **μ算子**：
   $$f(\bar{x}) = \mu y[g(\bar{x}, y) = 0]$$

10. **一般递归函数**：
    $$\text{递归函数} = \text{从初始函数通过复合、原始递归、μ算子得到的函数}$$

---

**文档状态**: ✅ 完成（已补充详细数学公式和例子）
**字数**: 约3,800字
**数学公式数**: 20个
**例子数**: 14个
**最后更新**: 2026年01月15日
