# Haskellç¼–ç¨‹åº”ç”¨

**åˆ›å»ºæ—¥æœŸ**: 2025å¹´12æœˆ11æ—¥
**æ¥æº**: Category Theory Using Haskell, å…¨ä¹¦åŠHaskellç¼–ç¨‹å®è·µ
**ä¸»é¢˜ç¼–å·**: CT.YUKITA.06.01

---

## ğŸ“‘ ç›®å½•

- [Haskellç¼–ç¨‹åº”ç”¨](#haskellç¼–ç¨‹åº”ç”¨)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€å‡½å­åœ¨ç¼–ç¨‹ä¸­çš„åº”ç”¨](#ä¸€å‡½å­åœ¨ç¼–ç¨‹ä¸­çš„åº”ç”¨)
    - [1.1 å®¹å™¨ç±»å‹](#11-å®¹å™¨ç±»å‹)
    - [1.2 å‡½æ•°ç»„åˆ](#12-å‡½æ•°ç»„åˆ)
  - [äºŒã€å•å­åœ¨ç¼–ç¨‹ä¸­çš„åº”ç”¨](#äºŒå•å­åœ¨ç¼–ç¨‹ä¸­çš„åº”ç”¨)
    - [2.1 é”™è¯¯å¤„ç†](#21-é”™è¯¯å¤„ç†)
    - [2.2 éç¡®å®šæ€§è®¡ç®—](#22-éç¡®å®šæ€§è®¡ç®—)
    - [2.3 çŠ¶æ€ç®¡ç†](#23-çŠ¶æ€ç®¡ç†)
    - [2.4 è¾“å…¥è¾“å‡º](#24-è¾“å…¥è¾“å‡º)
  - [ä¸‰ã€è‡ªç„¶å˜æ¢åœ¨ç¼–ç¨‹ä¸­çš„åº”ç”¨](#ä¸‰è‡ªç„¶å˜æ¢åœ¨ç¼–ç¨‹ä¸­çš„åº”ç”¨)
    - [3.1 ç±»å‹è½¬æ¢](#31-ç±»å‹è½¬æ¢)
    - [3.2 å¤šæ€å‡½æ•°](#32-å¤šæ€å‡½æ•°)
  - [å››ã€Yonedaå¼•ç†åœ¨ç¼–ç¨‹ä¸­çš„åº”ç”¨](#å››yonedaå¼•ç†åœ¨ç¼–ç¨‹ä¸­çš„åº”ç”¨)
    - [4.1 Yonedaæœºå™¨](#41-yonedaæœºå™¨)
    - [4.2 åå‘å·¥ç¨‹](#42-åå‘å·¥ç¨‹)

---

## ä¸€ã€å‡½å­åœ¨ç¼–ç¨‹ä¸­çš„åº”ç”¨

### 1.1 å®¹å™¨ç±»å‹

**å‡½å­ä½œä¸ºå®¹å™¨ç±»å‹**ï¼š

```haskell
-- Maybe: å¯èƒ½åŒ…å«å€¼çš„å®¹å™¨
fmap (+1) (Just 5) = Just 6
fmap (+1) Nothing = Nothing

-- List: åŒ…å«å¤šä¸ªå€¼çš„å®¹å™¨
fmap (*2) [1, 2, 3] = [2, 4, 6]

-- Either: åŒ…å«å€¼æˆ–é”™è¯¯çš„å®¹å™¨
fmap (+1) (Right 5) = Right 6
fmap (+1) (Left "error") = Left "error"
```

**æ•°å­¦åŸç†**ï¼š

- å‡½å­ä¿æŒç»“æ„ï¼š`fmap` å°†å‡½æ•°åº”ç”¨åˆ°å®¹å™¨å†…çš„å€¼ï¼Œä¿æŒå®¹å™¨ç»“æ„ä¸å˜
- å‡½å­å®šå¾‹ç¡®ä¿ `fmap` çš„è¡Œä¸ºä¸€è‡´

**åº”ç”¨åœºæ™¯**ï¼š

- æ•°æ®è½¬æ¢
- é”™è¯¯å¤„ç†
- åˆ—è¡¨å¤„ç†

### 1.2 å‡½æ•°ç»„åˆ

**å‡½å­å®ç°å‡½æ•°ç»„åˆ**ï¼š

```haskell
-- ä½¿ç”¨fmapç»„åˆå‡½æ•°
fmap f . fmap g = fmap (f . g)

-- ä¾‹å­
fmap show . fmap (+1) $ [1, 2, 3]
= fmap (show . (+1)) [1, 2, 3]
= ["2", "3", "4"]
```

**æ•°å­¦åŸç†**ï¼š

- å‡½å­çš„å¤åˆå¾‹ï¼š$F(g \circ f) = F(g) \circ F(f)$
- è¿™å…è®¸ä¼˜åŒ–ï¼šä¸¤æ¬¡ `fmap` å¯ä»¥åˆå¹¶ä¸ºä¸€æ¬¡

**åº”ç”¨åœºæ™¯**ï¼š

- å‡½æ•°ç®¡é“
- æ•°æ®è½¬æ¢é“¾
- æ€§èƒ½ä¼˜åŒ–

---

## äºŒã€å•å­åœ¨ç¼–ç¨‹ä¸­çš„åº”ç”¨

### 2.1 é”™è¯¯å¤„ç†

**Maybeå•å­å¤„ç†å¯èƒ½å¤±è´¥çš„è®¡ç®—**ï¼š

```haskell
-- å®‰å…¨é™¤æ³•é“¾
safeDiv :: Double -> Double -> Maybe Double
safeDiv x y = if y == 0 then Nothing else Just (x / y)

-- é“¾å¼è®¡ç®—
chainDiv :: Double -> Double -> Double -> Maybe Double
chainDiv a b c = do
    x <- safeDiv a b
    safeDiv x c

-- ä½¿ç”¨
chainDiv 10 2 5 = Just 1.0
chainDiv 10 0 5 = Nothing  -- è‡ªåŠ¨ä¼ æ’­é”™è¯¯
```

**æ•°å­¦åŸç†**ï¼š

- å•å­æä¾›è®¡ç®—çš„ç»„åˆæ€§
- `(>>=)` æ“ä½œç¬¦å®ç°è®¡ç®—çš„é“¾å¼ç»„åˆ
- é”™è¯¯è‡ªåŠ¨ä¼ æ’­ï¼Œæ— éœ€æ˜¾å¼æ£€æŸ¥

**åº”ç”¨åœºæ™¯**ï¼š

- æ•°æ®åº“æŸ¥è¯¢
- æ–‡ä»¶æ“ä½œ
- APIè°ƒç”¨

### 2.2 éç¡®å®šæ€§è®¡ç®—

**Listå•å­å¤„ç†éç¡®å®šæ€§è®¡ç®—**ï¼š

```haskell
-- ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„ç»„åˆ
combinations :: [a] -> [b] -> [(a, b)]
combinations xs ys = do
    x <- xs
    y <- ys
    return (x, y)

-- ä½¿ç”¨
combinations [1, 2] ['a', 'b'] = [(1,'a'), (1,'b'), (2,'a'), (2,'b')]
```

**æ•°å­¦åŸç†**ï¼š

- Listå•å­è¡¨ç¤ºéç¡®å®šæ€§è®¡ç®—
- `(>>=)` å¯¹åº”åˆ—è¡¨çš„"å±•å¹³"æ“ä½œ
- æ‰€æœ‰å¯èƒ½çš„ç»“æœéƒ½è¢«æ”¶é›†

**åº”ç”¨åœºæ™¯**ï¼š

- æœç´¢é—®é¢˜
- ç»„åˆç”Ÿæˆ
- çº¦æŸæ»¡è¶³é—®é¢˜

### 2.3 çŠ¶æ€ç®¡ç†

**Stateå•å­ç®¡ç†çŠ¶æ€**ï¼š

```haskell
-- Stateå•å­å®šä¹‰
newtype State s a = State { runState :: s -> (a, s) }

instance Monad (State s) where
    return x = State $ \s -> (x, s)
    m >>= f = State $ \s ->
        let (a, s') = runState m s
        in runState (f a) s'

-- ä½¿ç”¨Stateå•å­
increment :: State Int Int
increment = State $ \s -> (s, s + 1)

-- é“¾å¼è®¡ç®—
computation :: State Int Int
computation = do
    x <- increment
    y <- increment
    return (x + y)
```

**æ•°å­¦åŸç†**ï¼š

- Stateå•å­å°è£…çŠ¶æ€è®¡ç®—
- `(>>=)` è‡ªåŠ¨ä¼ é€’çŠ¶æ€
- çŠ¶æ€æ›´æ–°æ˜¯éšå¼çš„

**åº”ç”¨åœºæ™¯**ï¼š

- çŠ¶æ€æœº
- éšæœºæ•°ç”Ÿæˆ
- è§£æå™¨ç»„åˆå­

### 2.4 è¾“å…¥è¾“å‡º

**IOå•å­å¤„ç†å‰¯ä½œç”¨**ï¼š

```haskell
-- IOæ“ä½œ
readFile :: FilePath -> IO String
writeFile :: FilePath -> String -> IO ()

-- é“¾å¼IOæ“ä½œ
processFile :: FilePath -> IO String
processFile path = do
    content <- readFile path
    let processed = map toUpper content
    writeFile (path ++ ".upper") processed
    return processed
```

**æ•°å­¦åŸç†**ï¼š

- IOå•å­å°è£…å‰¯ä½œç”¨
- `(>>=)` é¡ºåºæ‰§è¡ŒIOæ“ä½œ
- çº¯å‡½æ•°å’Œå‰¯ä½œç”¨åˆ†ç¦»

**åº”ç”¨åœºæ™¯**ï¼š

- æ–‡ä»¶æ“ä½œ
- ç½‘ç»œé€šä¿¡
- ç”¨æˆ·äº¤äº’

---

## ä¸‰ã€è‡ªç„¶å˜æ¢åœ¨ç¼–ç¨‹ä¸­çš„åº”ç”¨

### 3.1 ç±»å‹è½¬æ¢

**è‡ªç„¶å˜æ¢å®ç°ç±»å‹è½¬æ¢**ï¼š

```haskell
-- Maybeåˆ°Listçš„è‡ªç„¶å˜æ¢
maybeToList :: Maybe a -> [a]
maybeToList Nothing = []
maybeToList (Just x) = [x]

-- Liståˆ°Setçš„è‡ªç„¶å˜æ¢
listToSet :: Ord a => [a] -> Set a
listToSet = Set.fromList

-- å¤åˆè‡ªç„¶å˜æ¢
maybeToSet :: Ord a => Maybe a -> Set a
maybeToSet = listToSet . maybeToList
```

**æ•°å­¦åŸç†**ï¼š

- è‡ªç„¶å˜æ¢æ˜¯å‡½å­ä¹‹é—´çš„æ˜ å°„
- è‡ªç„¶æ€§æ¡ä»¶ç¡®ä¿è½¬æ¢çš„ä¸€è‡´æ€§
- è‡ªç„¶å˜æ¢å¯ä»¥å¤åˆ

**åº”ç”¨åœºæ™¯**ï¼š

- æ•°æ®ç»“æ„è½¬æ¢
- APIé€‚é…
- æ•°æ®åºåˆ—åŒ–

### 3.2 å¤šæ€å‡½æ•°

**å¤šæ€å‡½æ•°ä½œä¸ºè‡ªç„¶å˜æ¢**ï¼š

```haskell
-- å¤šæ€å‡½æ•°
length :: [a] -> Int
length [] = 0
length (_:xs) = 1 + length xs

-- è‡ªç„¶æ€§æ¡ä»¶è‡ªåŠ¨æ»¡è¶³
-- fmap f . length = length . fmap f
```

**æ•°å­¦åŸç†**ï¼š

- å¤šæ€å‡½æ•°å¯¹åº”è‡ªç„¶å˜æ¢
- `forall` é‡åŒ–ç¡®ä¿è‡ªç„¶æ€§
- ç±»å‹ç³»ç»Ÿä¿è¯æ­£ç¡®æ€§

**åº”ç”¨åœºæ™¯**ï¼š

- é€šç”¨ç®—æ³•
- æ•°æ®ç»“æ„æ“ä½œ
- ç±»å‹å®‰å…¨çš„è½¬æ¢

---

## å››ã€Yonedaå¼•ç†åœ¨ç¼–ç¨‹ä¸­çš„åº”ç”¨

### 4.1 Yonedaæœºå™¨

**Yonedaæœºå™¨ä½¿ç”¨Yonedaå¼•ç†è¿›è¡Œåå‘å·¥ç¨‹**ï¼š

```haskell
-- Yonedaå¼•ç†ï¼šNat (Hom (-, a)) f â‰… f a

-- éšè—å‚æ•°
newtype Yoneda f a = Yoneda (forall b. (a -> b) -> f b)

-- ä»Yonedaæ¢å¤åŸå§‹å€¼
lowerYoneda :: Yoneda f a -> f a
lowerYoneda (Yoneda y) = y id

-- æå‡åˆ°Yoneda
liftYoneda :: Functor f => f a -> Yoneda f a
liftYoneda fa = Yoneda $ \f -> fmap f fa
```

**æ•°å­¦åŸç†**ï¼š

- Yonedaå¼•ç†ï¼š$\text{Nat}(\text{Hom}(-, A), F) \cong F(A)$
- Yonedaæœºå™¨åˆ©ç”¨è¿™ä¸ªåŒæ„è¿›è¡Œä¼˜åŒ–
- å¯ä»¥å»¶è¿Ÿè®¡ç®—ï¼Œæé«˜æ€§èƒ½

**åº”ç”¨åœºæ™¯**ï¼š

- æ€§èƒ½ä¼˜åŒ–
- å»¶è¿Ÿè®¡ç®—
- å‡½æ•°å¼æ•°æ®ç»“æ„

### 4.2 åå‘å·¥ç¨‹

**ä½¿ç”¨Yonedaå¼•ç†è¿›è¡Œåå‘å·¥ç¨‹**ï¼š

```haskell
-- éšè—åˆ—è¡¨
newtype HiddenList a = HiddenList (forall b. (a -> b) -> [b])

-- æ¢å¤åˆ—è¡¨
revealList :: HiddenList a -> [a]
revealList (HiddenList f) = f id

-- æ„é€ éšè—åˆ—è¡¨
hideList :: [a] -> HiddenList a
hideList xs = HiddenList $ \f -> fmap f xs
```

**æ•°å­¦åŸç†**ï¼š

- Yonedaå¼•ç†å…è®¸ä»"è¡Œä¸º"æ¢å¤"æ•°æ®"
- éšè—å®ç°ç»†èŠ‚
- æä¾›æŠ½è±¡æ¥å£

**åº”ç”¨åœºæ™¯**ï¼š

- APIè®¾è®¡
- æŠ½è±¡æ•°æ®ç±»å‹
- æ€§èƒ½ä¼˜åŒ–

---

**æœ€åæ›´æ–°**: 2025å¹´12æœˆ11æ—¥
**å‚è€ƒç« èŠ‚**: å…¨ä¹¦åŠHaskellç¼–ç¨‹å®è·µ
