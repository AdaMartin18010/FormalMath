# èŒƒç•´ä¸Haskellç±»å‹

**åˆ›å»ºæ—¥æœŸ**: 2025å¹´12æœˆ11æ—¥
**æ¥æº**: Category Theory Using Haskell, Chapter 1-2
**ä¸»é¢˜ç¼–å·**: CT.YUKITA.01.01

---

## ğŸ“‘ ç›®å½•

- [èŒƒç•´ä¸Haskellç±»å‹](#èŒƒç•´ä¸haskellç±»å‹)
  - [ğŸ“‘ ç›®å½•](#-ç›®å½•)
  - [ä¸€ã€èŒƒç•´çš„å®šä¹‰](#ä¸€èŒƒç•´çš„å®šä¹‰)
    - [1.1 èŒƒç•´çš„æ•°å­¦å®šä¹‰](#11-èŒƒç•´çš„æ•°å­¦å®šä¹‰)
    - [1.2 Haskellä¸­çš„èŒƒç•´](#12-haskellä¸­çš„èŒƒç•´)
  - [äºŒã€Haskellç±»å‹ä½œä¸ºèŒƒç•´](#äºŒhaskellç±»å‹ä½œä¸ºèŒƒç•´)
    - [2.1 ç±»å‹ç³»ç»Ÿ](#21-ç±»å‹ç³»ç»Ÿ)
    - [2.2 ç±»å‹ç±»ä¸èŒƒç•´](#22-ç±»å‹ç±»ä¸èŒƒç•´)
  - [ä¸‰ã€ç±»å‹ä¸å‡½æ•°](#ä¸‰ç±»å‹ä¸å‡½æ•°)
    - [3.1 å‡½æ•°ç±»å‹](#31-å‡½æ•°ç±»å‹)
    - [3.2 å‡½æ•°çš„æ€§è´¨](#32-å‡½æ•°çš„æ€§è´¨)
  - [å››ã€æ’ç­‰å‡½æ•°ä¸å¤åˆ](#å››æ’ç­‰å‡½æ•°ä¸å¤åˆ)
    - [4.1 æ’ç­‰å‡½æ•°](#41-æ’ç­‰å‡½æ•°)
    - [4.2 å‡½æ•°å¤åˆ](#42-å‡½æ•°å¤åˆ)

---

## ä¸€ã€èŒƒç•´çš„å®šä¹‰

### 1.1 èŒƒç•´çš„æ•°å­¦å®šä¹‰

**èŒƒç•´ (Category)** ç”±ä»¥ä¸‹æ•°æ®ç»„æˆï¼š

1. **å¯¹è±¡ (Objects)**: é›†åˆ $\text{Ob}(\mathcal{C})$
2. **æ˜ å°„ (Morphisms)**: å¯¹æ¯å¯¹å¯¹è±¡ $A, B$ï¼Œé›†åˆ $\text{Hom}(A, B)$
3. **æ’ç­‰æ˜ å°„**: å¯¹æ¯ä¸ªå¯¹è±¡ $A$ï¼Œ$1_A \in \text{Hom}(A, A)$
4. **å¤åˆè¿ç®—**: å¯¹ $f \in \text{Hom}(A, B)$ å’Œ $g \in \text{Hom}(B, C)$ï¼Œ$g \circ f \in \text{Hom}(A, C)$

**æ»¡è¶³çš„è§„åˆ™**ï¼š

- **æ’ç­‰å¾‹**: $f \circ 1_A = f$ ä¸” $1_B \circ f = f$
- **ç»“åˆå¾‹**: $(h \circ g) \circ f = h \circ (g \circ f)$

### 1.2 Haskellä¸­çš„èŒƒç•´

åœ¨Haskellä¸­ï¼Œ**HaskèŒƒç•´**å®šä¹‰å¦‚ä¸‹ï¼š

- **å¯¹è±¡**: Haskellç±»å‹ï¼ˆå¦‚ `Int`, `Bool`, `[Int]`ï¼‰
- **æ˜ å°„**: Haskellå‡½æ•°ï¼ˆå¦‚ `f :: Int -> Bool`ï¼‰
- **æ’ç­‰æ˜ å°„**: `id :: a -> a`
- **å¤åˆ**: `(.) :: (b -> c) -> (a -> b) -> (a -> c)`

**æ•°å­¦è¡¨ç¤º**ï¼š

- å¯¹è±¡ï¼š$A, B, C \in \text{Ob}(\mathbf{Hask})$
- æ˜ å°„ï¼š$f: A \to B$ å¯¹åº” `f :: A -> B`
- æ’ç­‰ï¼š$1_A: A \to A$ å¯¹åº” `id :: A -> A`
- å¤åˆï¼š$g \circ f$ å¯¹åº” `g . f`

---

## äºŒã€Haskellç±»å‹ä½œä¸ºèŒƒç•´

### 2.1 ç±»å‹ç³»ç»Ÿ

**Haskellç±»å‹**å½¢æˆèŒƒç•´çš„å¯¹è±¡ï¼š

- **åŸºæœ¬ç±»å‹**: `Int`, `Bool`, `Char`, `Double`
- **å¤åˆç±»å‹**: `[Int]`ï¼ˆåˆ—è¡¨ï¼‰ï¼Œ`(Int, Bool)`ï¼ˆå…ƒç»„ï¼‰ï¼Œ`Maybe Int`ï¼ˆå¯é€‰ç±»å‹ï¼‰
- **å‡½æ•°ç±»å‹**: `Int -> Bool`ï¼ˆå‡½æ•°ç±»å‹ï¼‰

**ç±»å‹æ„é€ å­**ï¼š

- `[]`ï¼šåˆ—è¡¨æ„é€ å­ï¼Œ`[] :: * -> *`
- `Maybe`ï¼šå¯é€‰ç±»å‹æ„é€ å­ï¼Œ`Maybe :: * -> *`
- `(,)`ï¼šå…ƒç»„æ„é€ å­ï¼Œ`(,) :: * -> * -> *`

### 2.2 ç±»å‹ç±»ä¸èŒƒç•´

**ç±»å‹ç±»**å¯ä»¥çœ‹ä½œèŒƒç•´çš„"ç»“æ„"ï¼š

```haskell
class Category cat where
    id :: cat a a
    (.) :: cat b c -> cat a b -> cat a c
```

**æ•°å­¦è¡¨ç¤º**ï¼š

- `Category` ç±»å‹ç±»å®šä¹‰äº†èŒƒç•´çš„ç»“æ„
- `id` å¯¹åº”æ’ç­‰æ˜ å°„ $1_A$
- `(.)` å¯¹åº”å¤åˆè¿ç®— $\circ$

---

## ä¸‰ã€ç±»å‹ä¸å‡½æ•°

### 3.1 å‡½æ•°ç±»å‹

**å‡½æ•°ç±»å‹** $A \to B$ åœ¨Haskellä¸­è¡¨ç¤ºä¸º `A -> B`ã€‚

**æ•°å­¦å®šä¹‰**ï¼š

- å‡½æ•°ç±»å‹ $B^A$ æ˜¯æ‰€æœ‰ä» $A$ åˆ° $B$ çš„å‡½æ•°çš„é›†åˆ
- åœ¨Haskellä¸­ï¼Œ`A -> B` è¡¨ç¤ºç±»å‹ $A$ åˆ°ç±»å‹ $B$ çš„æ‰€æœ‰å‡½æ•°

**ä¾‹å­**ï¼š

```haskell
-- å‡½æ•°ç±»å‹
f :: Int -> Bool
f x = x > 0

-- æ•°å­¦è¡¨ç¤ºï¼šf: Int â†’ Bool
```

### 3.2 å‡½æ•°çš„æ€§è´¨

**å•å°„ (Injection)**ï¼š

- æ•°å­¦å®šä¹‰ï¼š$f(a_1) = f(a_2) \Rightarrow a_1 = a_2$
- Haskellä¸­éš¾ä»¥ç›´æ¥è¡¨è¾¾ï¼Œä½†å¯ä»¥é€šè¿‡ç±»å‹ç³»ç»Ÿéƒ¨åˆ†ä¿è¯

**æ»¡å°„ (Surjection)**ï¼š

- æ•°å­¦å®šä¹‰ï¼š$\forall b \in B, \exists a \in A, f(a) = b$
- Haskellä¸­éš¾ä»¥ç›´æ¥è¡¨è¾¾

**åŒå°„ (Bijection)**ï¼š

- æ•°å­¦å®šä¹‰ï¼šæ—¢æ˜¯å•å°„åˆæ˜¯æ»¡å°„
- åœ¨Haskellä¸­ï¼ŒåŒæ„ç±»å‹å¯¹åº”åŒå°„

---

## å››ã€æ’ç­‰å‡½æ•°ä¸å¤åˆ

### 4.1 æ’ç­‰å‡½æ•°

**æ’ç­‰å‡½æ•°** `id` åœ¨Haskellä¸­å®šä¹‰ä¸ºï¼š

```haskell
id :: a -> a
id x = x
```

**æ•°å­¦è¡¨ç¤º**ï¼š

- $1_A: A \to A$ï¼Œ$1_A(a) = a$
- åœ¨Haskellä¸­ï¼Œ`id :: A -> A` å¯¹åº” $1_A$

**æ€§è´¨**ï¼š

- **å·¦æ’ç­‰å¾‹**: `f . id = f`
- **å³æ’ç­‰å¾‹**: `id . f = f`

**æ•°å­¦è¯æ˜**ï¼š

- $(f \circ 1_A)(a) = f(1_A(a)) = f(a)$
- $(1_B \circ f)(a) = 1_B(f(a)) = f(a)$

### 4.2 å‡½æ•°å¤åˆ

**å‡½æ•°å¤åˆ** `(.)` åœ¨Haskellä¸­å®šä¹‰ä¸ºï¼š

```haskell
(.) :: (b -> c) -> (a -> b) -> (a -> c)
(.) f g x = f (g x)
```

**æ•°å­¦è¡¨ç¤º**ï¼š

- $g \circ f: A \to C$ï¼Œ$(g \circ f)(a) = g(f(a))$
- åœ¨Haskellä¸­ï¼Œ`g . f` å¯¹åº” $g \circ f$

**æ€§è´¨**ï¼š

- **ç»“åˆå¾‹**: `(h . g) . f = h . (g . f)`

**æ•°å­¦è¯æ˜**ï¼š

- $((h \circ g) \circ f)(a) = (h \circ g)(f(a)) = h(g(f(a)))$
- $(h \circ (g \circ f))(a) = h((g \circ f)(a)) = h(g(f(a)))$

**ä¾‹å­**ï¼š

```haskell
-- å‡½æ•°å¤åˆ
f :: Int -> Bool
f x = x > 0

g :: Bool -> String
g True = "positive"
g False = "non-positive"

-- å¤åˆå‡½æ•°
h = g . f  -- h :: Int -> String

-- æ•°å­¦è¡¨ç¤ºï¼šh = g âˆ˜ f: Int â†’ String
```

---

**æœ€åæ›´æ–°**: 2025å¹´12æœˆ11æ—¥
**å‚è€ƒç« èŠ‚**: Chapter 1-2
